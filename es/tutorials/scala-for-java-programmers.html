<!DOCTYPE html>
<html>
  <head>
    <title>Tutorial de Scala para programadores Java | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/docs.scala-lang/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/docs.scala-lang/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/docs.scala-lang/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs.scala-lang/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/docs.scala-lang/resources/favicon-16x16.png">
    <link rel="manifest" href="/docs.scala-lang/resources/site.webmanifest">
    <link rel="mask-icon" href="/docs.scala-lang/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/docs.scala-lang/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/docs.scala-lang/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/docs.scala-lang/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/docs.scala-lang/" class="navigation-bdand">
        <img src="/docs.scala-lang/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/books.html">Books</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/docs.scala-lang/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/docs.scala-lang/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/docs.scala-lang/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/docs.scala-lang/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>Tutorial de Scala para programadores Java</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p>Por Michel Schinz y Philipp Haller.
Traducción y arreglos Santiago Basulto.</p>

<h2 id="introducción">Introducción</h2>

<p>Este documento provee una rápida introducción al lenguaje Scala como también a su compilador. Está pensado para personas que ya poseen cierta experiencia en programación y quieren una vista rápida de lo que pueden hacer con Scala. Se asume como un conocimiento básico de programación orientada a objetos, especialmente en Java.</p>

<h2 id="un-primer-ejemplo">Un primer ejemplo</h2>

<p>Como primer ejemplo, usaremos el programa <em>Hola mundo</em> estándar. No es muy fascinante, pero de esta manera resulta fácil demostrar el uso de herramientas de Scala sin saber demasiado acerca del lenguaje. Veamos como luce:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object HolaMundo {
  def main(args: Array[String]) {
    println("¡Hola, mundo!")
  }
}
</code></pre></div></div>

<p>La estructura de este programa debería ser familiar para programadores Java: consiste de un método llamado <code class="highlighter-rouge">main</code> que toma los argumentos de la línea de comando (un array de objetos String) como parámetro; el cuerpo de este método consiste en una sola llamada al método predefinido <code class="highlighter-rouge">println</code> con el saludo amistoso como argumento. El método <code class="highlighter-rouge">main</code> no retorna un valor (se puede entender como un procedimiento). Por lo tanto, no es necesario que se declare un tipo retorno.</p>

<p>Lo que es menos familiar a los programadores Java es la declaración de <code class="highlighter-rouge">object</code> que contiene al método <code class="highlighter-rouge">main</code>. Esa declaración introduce lo que es comúnmente conocido como <em>objeto singleton</em>, que es una clase con una sola instancia. Por lo tanto, dicha construcción declara tanto una clase llamada <code class="highlighter-rouge">HolaMundo</code> como una instancia de esa clase también llamada <code class="highlighter-rouge">HolaMundo</code>. Esta instancia es creada bajo demanda, es decir, la primera vez que es utilizada.</p>

<p>El lector astuto notará que el método <code class="highlighter-rouge">main</code> no es declarado como <code class="highlighter-rouge">static</code>. Esto es así porque los miembros estáticos (métodos o campos) no existen en Scala. En vez de definir miembros estáticos, el programador de Scala declara estos miembros en un objeto singleton.</p>

<h3 id="compilando-el-ejemplo">Compilando el ejemplo</h3>

<p>Para compilar el ejemplo utilizaremos <code class="highlighter-rouge">scalac</code>, el compilador de Scala. <code class="highlighter-rouge">scalac</code> funciona como la mayoría de los compiladores. Toma un archivo fuente como argumento, algunas opciones y produce uno o varios archivos objeto. Los archivos objeto que produce son archivos class de Java estándar.</p>

<p>Si guardamos el programa anterior en un archivo llamado <code class="highlighter-rouge">HolaMundo.scala</code>, podemos compilarlo ejecutando el siguiente comando (el símbolo mayor <code class="highlighter-rouge">&gt;</code> representa el prompt del shell y no debe ser escrita):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; scalac HolaMundo.scala
</code></pre></div></div>

<p>Esto generará algunos archivos class en el directorio actual. Uno de ellos se llamará <code class="highlighter-rouge">HolaMundo.class</code> y contiene una clase que puede ser directamente ejecutada utilizando el comando <code class="highlighter-rouge">scala</code>, como mostramos en la siguiente sección.</p>

<h3 id="ejecutando-el-ejemplo">Ejecutando el ejemplo</h3>

<p>Una vez compilado, un programa Scala puede ser ejecutado utilizando el comando <code class="highlighter-rouge">scala</code>. Su uso es muy similar al comando <code class="highlighter-rouge">java</code> utilizado para ejecutar programas Java, y acepta las mismas opciones. El ejemplo de arriba puede ser ejecutado utilizando el siguiente comando, que produce la salida esperada:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; scala -classpath . HolaMundo

¡Hola, mundo!
</code></pre></div></div>

<h2 id="interacción-con-java">Interacción con Java</h2>

<p>Una de las fortalezas de Scala es que hace muy fácil interactuar con código Java. Todas las clases del paquete <code class="highlighter-rouge">java.lang</code> son importadas por defecto, mientras otras necesitan ser importadas explícitamente.</p>

<p>Veamos un ejemplo que demuestra esto. Queremos obtener y formatear la fecha actual de acuerdo a convenciones utilizadas en un país específico, por ejemplo Francia.</p>

<p>Las librerías de clases de Java definen clases de utilería poderosas, como <code class="highlighter-rouge">Date</code> y <code class="highlighter-rouge">DateFormat</code>. Ya que Scala interacciona fácilmente con Java, no es necesario implementar estas clases equivalentes en las librerías de Scala –podemos simplemente importar las clases de los correspondientes paquetes de Java:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.{Date, Locale}
import java.text.DateFormat
import java.text.DateFormat._

object FrenchDate {
  def main(args: Array[String]) {
    val ahora = new Date
    val df = getDateInstance(LONG, Locale.FRANCE)
    println(df format ahora)
  }
}
</code></pre></div></div>

<p>Las declaraciones de importación de Scala lucen muy similares a las de Java, sin embargo, las primeras son bastante más poderosas. Múltiples clases pueden ser importadas desde el mismo paquete al encerrarlas en llaves como se muestra en la primer línea. Otra diferencia es que podemos importar todos los nombres de un paquete o clase, utilizando el carácter guión bajo (<code class="highlighter-rouge">_</code>) en vez del asterisco (<code class="highlighter-rouge">*</code>). Eso es porque el asterisco es un identificador válido en Scala (quiere decir que por ejemplo podemos nombrar a un método <code class="highlighter-rouge">*</code>), como veremos más adelante.</p>

<p>La declaración <code class="highlighter-rouge">import</code> en la tercer línea por lo tanto importa todos los miembros de la clase <code class="highlighter-rouge">DateFormat</code>. Esto hace que el método estático <code class="highlighter-rouge">getDateInstance</code> y el campo estático <code class="highlighter-rouge">LONG</code> sean directamente visibles.</p>

<p>Dentro del método <code class="highlighter-rouge">main</code> primero creamos una instancia de la clase <code class="highlighter-rouge">Date</code> la cual por defecto contiene la fecha actual. A continuación definimos un formateador de fechas utilizando el método estático <code class="highlighter-rouge">getDateInstance</code> que importamos previamente. Finalmente, imprimimos la fecha actual formateada de acuerdo a la instancia de <code class="highlighter-rouge">DateFormat</code> que fue “localizada”. Esta última línea muestra una propiedad interesante de la sintaxis de Scala. Los métodos que toman un solo argumento pueden ser usados con una sintaxis de infijo Es decir, la expresión</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df format ahora
</code></pre></div></div>

<p>es solamente otra manera más corta de escribir la expresión:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df.format(ahora)
</code></pre></div></div>

<p>Esto parece tener como un detalle sintáctico menor, pero tiene importantes consecuencias, una de ellas la exploraremos en la próxima sección.</p>

<p>Para concluir esta sección sobre la interacción con Java, es importante notar que es también posible heredar de clases Java e implementar interfaces Java directamente en Scala.</p>

<h2 id="todo-es-un-objeto">Todo es un objeto</h2>

<p>Scala es un lenguaje puramente orientado a objetos en el sentido de que <em>todo</em> es un objeto, incluyendo números o funciones. Difiere de Java en este aspecto, ya que Java distingue tipos primitivos (como <code class="highlighter-rouge">boolean</code> e <code class="highlighter-rouge">int</code>) de tipos referenciales, y no nos permite manipular las funciones como valores.</p>

<h3 id="los-números-son-objetos">Los números son objetos</h3>

<p>Ya que los números son objetos, estos también tienen métodos. De hecho, una expresión aritmética como la siguiente:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 + 2 * 3 / x
</code></pre></div></div>

<p>Consiste exclusivamente de llamadas a métodos, porque es equivalente a la siguiente expresión, como vimos en la sección anterior:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1).+(((2).*(3))./(x))
</code></pre></div></div>

<p>Esto también indica que <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">*</code>, etc. son identificadores válidos en Scala.</p>

<p>Los paréntesis alrededor de los números en la segunda versión son necesarios porque el analizador léxico de Scala usa la regla de “mayor coincidencia”. Por lo tanto partiría la siguiente expresión:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.+(2)
</code></pre></div></div>

<p>En estas partes: <code class="highlighter-rouge">1.</code>, <code class="highlighter-rouge">+</code>, y <code class="highlighter-rouge">2</code>. La razón que esta regla es elegida es porque <code class="highlighter-rouge">1.</code> es una coincidencia válida y es mayor que <code class="highlighter-rouge">1</code>, haciendo a este un <code class="highlighter-rouge">Double</code> en vez de un <code class="highlighter-rouge">Int</code>. Al escribir la expresión así:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1).+(2)
</code></pre></div></div>

<p>previene que el <code class="highlighter-rouge">1</code> sea tomado como un <code class="highlighter-rouge">Double</code>.</p>

<h3 id="las-funciones-son-objetos">Las funciones son objetos</h3>

<p>Tal vez suene más sorprendente para los programadores Java, las funciones en Scala también son objetos. Por lo tanto es posible pasar funciones como argumentos, almacenarlas en variables, y retornarlas desde otras funciones. Esta habilidad de manipular funciones como valores es una de las valores fundamentales de un paradigma de programación muy interesante llamado <em>programación funcional</em>.</p>

<p>Como un ejemplo muy simple de por qué puede ser útil usar funciones como valores consideremos una función <em>temporizador</em> (o timer, en inglés) cuyo propósito es realizar alguna acción cada un segundo. ¿Cómo pasamos al temporizador la acción a realizar? Bastante lógico, como una función. Este simple concepto de pasar funciones debería ser familiar para muchos programadores: es generalmente utilizado en código relacionado con Interfaces gráficas de usuario (GUIs) para registrar “retrollamadas” (call-back en inglés) que son invocadas cuando un evento ocurre.</p>

<p>En el siguiente programa, la función del temporizador se llama <code class="highlighter-rouge">unaVezPorSegundo</code> y recibe una función call-back como argumento. El tipo de esta función es escrito de la siguiente manera: <code class="highlighter-rouge">() =&gt; Unit</code> y es el tipo de todas las funciones que no toman argumentos ni retornan valores (el tipo <code class="highlighter-rouge">Unit</code> es similar a <code class="highlighter-rouge">void</code> en Java/C/C++). La función principal de este programa simplemente invoca esta función temporizador con una call-back que imprime una sentencia en la terminal. En otras palabras, este programa imprime interminablemente la sentencia “El tiempo vuela como una flecha” cada segundo.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object Temporizador {
  def unaVezPorSegundo(callback: () =&gt; Unit) {
    while (true) { callback(); Thread sleep 1000 }
  }
  def tiempoVuela() {
    println("El tiempo vuela como una flecha...")
  }
  def main(args: Array[String]) {
    unaVezPorSegundo(tiempoVuela)
  }
}
</code></pre></div></div>

<p><em>Nota: si nunca tuviste experiencias previas con programación funcional te recomiendo que te tomes unos segundos para analizar cuando se utilizan paréntesis y cuando no en los lugares donde aparece *callback*. Por ejemplo, dentro de la declaración de <code class="highlighter-rouge">unaVezPorSegundo</code> no aparece, ya que se trata de la función como un “valor”, a diferencia de cómo aparece dentro del método, ya que en ese caso se la está invocando (por eso los paréntesis).</em>
Note that in order to print the string, we used the predefined method
<code class="highlighter-rouge">println</code> instead of using the one from <code class="highlighter-rouge">System.out</code>.</p>

<h4 id="funciones-anónimas">Funciones anónimas</h4>

<p>El programa anterior es fácil de entender, pero puede ser refinado aún más. Primero que nada es interesante notar que la función <code class="highlighter-rouge">tiempoVuela</code> está definida solamente para ser pasada posteriormente a la función <code class="highlighter-rouge">unaVezPorSegundo</code>. Tener que nombrar esa función, que es utilizada solamente una vez parece un poco innecesario y sería bueno poder construirla justo cuando sea pasada a <code class="highlighter-rouge">unaVezPorSegundo</code>. Esto es posible en Scala utilizando <em>funciones anónimas</em>, que son exactamente eso: funciones sin nombre. La versión revisada de nuestro temporizador utilizando una función anónima luce así:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object TemporizadorAnonimo {
  def unaVezPorSegundo(callback: () =&gt; Unit) {
    while (true) { callback(); Thread sleep 1000 }
  }
  def main(args: Array[String]) {
    unaVezPorSegundo(
        () =&gt; println("El tiempo vuela como una flecha...")
    )
  }
}
</code></pre></div></div>

<p>La presencia de una función anónima en este ejemplo es revelada por la flecha a la derecha <code class="highlighter-rouge">=&gt;</code> que separa los argumentos de la función del cuerpo de esta. En este ejemplo, la lista de argumentos está vacía, como se ve por el par de paréntesis vacíos a la izquierda de la flecha. El cuerpo de la función es el mismo que en <code class="highlighter-rouge">tiempoVuela</code> del programa anterior.</p>

<h2 id="clases">Clases</h2>

<p>Como hemos visto anteriormente, Scala es un lenguaje orientado a objetos, y como tal tiene el concepto de Clase (en realidad existen lenguajes orientados a objetos que no cuentan con el concepto de clases, pero Scala no es uno de ellos). Las clases en Scala son declaradas utilizando una sintaxis que es cercana a la de Java. Una diferencia importante es que las clases en Scala pueden tener parámetros. Ilustramos esto en el siguiente ejemplo, la definición de un número complejo:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Complejo(real: Double, imaginaria: Double) {
  def re() = real
  def im() = imaginaria
}
</code></pre></div></div>

<p>Esta clase compleja toma dos argumentos, que son las partes real e imaginarias de un número complejo. Estos argumentos deben ser pasados cuando se crea una instancia de la clase <code class="highlighter-rouge">Complejo</code>, de la siguiente manera:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>new Complejo(1.5, 2.3)
</code></pre></div></div>

<p>La clase contiene dos métodos llamados <code class="highlighter-rouge">re</code> e <code class="highlighter-rouge">im</code>, que proveen acceso a las dos partes del número.</p>

<p>Debe notarse que el tipo de retorno de estos dos métodos no está expresado explícitamente. Será inferido automáticamente por el compilador, que primero mira la parte derecha de estos métodos y puede deducir que ambos retornan un valor de tipo <code class="highlighter-rouge">Double</code>.</p>

<p>El compilador no es siempre capaz de inferir los tipos como lo hace aquí, y desafortunadamente no existe una regla simple para saber cuándo será y cuándo no. En la práctica, esto generalmente no es un problema ya que el compilador se queja cuando no es capaz de inferir un tipo que no fue explícitamente fijado. Como regla simple, los programadores de Scala novatos deberían tratar de omitir las declaraciones de tipos que parecen ser simples de deducir del contexto y ver si el compilador no lanza errores. Después de algún tiempo, el programador debería tener una buena idea de cuando omitir tipos y cuando explicitarlos.</p>

<h3 id="métodos-sin-argumentos">Métodos sin argumentos</h3>

<p>Un pequeño problema de los métodos <code class="highlighter-rouge">re</code> e <code class="highlighter-rouge">im</code> es que para poder llamarlos es necesario agregar un par de paréntesis vacíos después de sus nombres, como muestra el siguiente ejemplo:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object NumerosComplejos {
  def main(args: Array[String]) {
    val c = new Complejo(1.2, 3.4)
    println("Parte imaginaria: " + c.im())
  }
}
</code></pre></div></div>

<p>Sería mejor poder acceder las partes imaginarias y reales como si fueran campos, sin poner los paréntesis vacíos. Esto es perfectamente realizable en Scala, simplemente al definirlos como <em>métodos sin argumentos</em>. Tales métodos difieren de los métodos con cero o más argumentos en que no tienen paréntesis después de su nombre, tanto en la definición como en el uso. Nuestra clase <code class="highlighter-rouge">Complejo</code> puede ser reescrita así:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Complejo(real: Double, imaginaria: Double) {
  def re = real
  def im = imaginaria
}
</code></pre></div></div>

<h3 id="herencia-y-sobreescritura">Herencia y sobreescritura</h3>

<p>Todas las clases en Scala heredan de una superclase. Cuando ninguna superclase es especificada, como es el caso de <code class="highlighter-rouge">Complejo</code> se utiliza implícitamente <code class="highlighter-rouge">scala.AnyRef</code>.</p>

<p>Es posible sobreescribir métodos heredados de una superclase en Scala. Aunque es necesario explicitar específicamente que un método sobreescribe otro utilizando el modificador <code class="highlighter-rouge">override</code>, de manera de evitar sobreescrituras accidentales. Como ejemplo, nuestra clase <code class="highlighter-rouge">Complejo</code> puede ser aumentada con la redefinición del método <code class="highlighter-rouge">toString</code> heredado de <code class="highlighter-rouge">Object</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Complejo(real: Double, imaginaria: Double) {
  def re = real
  def im = imaginaria
  override def toString() =
    "" + re + (if (im &lt; 0) "" else "+") + im + "i"
}
</code></pre></div></div>

<h2 id="clases-case-y-reconocimiento-de-patrones">Clases Case y Reconocimiento de patrones</h2>

<p>Un tipo de estructura de datos que aparece seguido en programas es el Árbol. Por ejemplo, los intérpretes y compiladores usualmente representan los programas internamente como árboles; los documentos XML son árboles; y muchos otros tipos de contenedores están basados en árboles, como los árboles rojo y negro.</p>

<p>Ahora examinaremos cómo estos árboles son representados y manipulados en Scala mediante un pequeño programa que oficie de calculadora. El objetivo de este programa es manipular expresiones aritméticas simples compuestas de sumas de enteros y variables. Dos ejemplos de estas expresiones pueden ser: <code class="highlighter-rouge">1+2</code> y <code class="highlighter-rouge">(x+x)+(7+y)</code>.</p>

<p>Primero tenemos que decidir una representación para tales expresiones. La más natural es un árbol, donde los nodos son las operaciones (la adición en este caso) y las hojas son valores (constantes o variables).</p>

<p>En Java, un árbol así sería representado utilizando una superclase abstracta para los árboles, y una subclase concreta por nodo u hoja. En un lenguaje de programación funcional uno utilizaría un tipo de dato algebraico para el mismo propósito. Scala provee el concepto de <em>clases case</em> que está en el medio de los dos conceptos anteriores. Aquí mostramos como pueden ser usadas para definir el tipo de los árboles en nuestro ejemplo:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abstract class Arbol
case class Sum(l: Arbol, r: Arbol) extends Arbol
case class Var(n: String) extends Arbol
case class Const(v: Int) extends Arbol
</code></pre></div></div>

<p>El hecho de que las clases <code class="highlighter-rouge">Sum</code>, <code class="highlighter-rouge">Var</code> y <code class="highlighter-rouge">Const</code> sean declaradas como clases case significa que dififieren de las clases normales en varios aspectos:</p>

<ul>
  <li>no es obligatorio utilizar la palabra clave <code class="highlighter-rouge">new</code> para crear
instancias de estas clases (es decir, se puede escribir <code class="highlighter-rouge">Const(5)</code>
en lugar de <code class="highlighter-rouge">new Const(5)</code>),</li>
  <li>se crea automáticamente un “getter” (un método para obtener el valor)
para los parámetros utilizados en el constructor (por ejemplo es posible
obtener el valor de <code class="highlighter-rouge">v</code> de una instancia <code class="highlighter-rouge">c</code> de la clase <code class="highlighter-rouge">Const</code> de la
siguiente manera: <code class="highlighter-rouge">c.v</code>),</li>
  <li>se proveen definiciones por defecto de los métodos <code class="highlighter-rouge">equals</code> y <code class="highlighter-rouge">hashCode</code>,
que trabajan sobre la estructura de las instancias y no sobre su identidad,</li>
  <li>se crea una definición por defecto del método <code class="highlighter-rouge">toString</code> que
imprime el valor de una forma “tipo código) (ej: la expresión
del árbol <code class="highlighter-rouge">x+1</code> se imprimiría <code class="highlighter-rouge">Sum(Var(x),Const(1))</code>),</li>
  <li>las instancias de estas clases pueden ser descompuestas
mediante <em>reconocimiento de patrones</em> (pattern matching)
como veremos más abajo.</li>
</ul>

<p>Ahora que hemos definido el tipo de datos para representar nuestra expresión aritmética podemos empezar definiendo operaciones para manipularlas. Empezaremos con una función para evaluar una expresión en un <em>entorno</em>. El objetivo del entorno es darle valores a las variables. Por ejemplo, la expresión <code class="highlighter-rouge">x+1</code> evaluada en un entorno que asocia el valor <code class="highlighter-rouge">5</code> a la variable <code class="highlighter-rouge">x</code>, escrito <code class="highlighter-rouge">{ x -&gt; 5 }</code>, da como resultado <code class="highlighter-rouge">6</code>.</p>

<p>Por lo tanto tenemos que encontrar una manera de representar entornos. Podríamos por supuesto utilizar alguna estructura de datos asociativa como una tabla hash, pero podemos directamente utilizar funciones! Un entorno realmente no es nada más que una función la cual asocia valores a variables. El entorno <code class="highlighter-rouge">{ x -&gt; 5 }</code> mostrado anteriormente puede ser fácilmente escrito de la siguiente manera en Scala:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ case "x" =&gt; 5 }
</code></pre></div></div>

<p>Esta notación define una función la cual, dado un string <code class="highlighter-rouge">"x"</code> como argumento retorna el entero <code class="highlighter-rouge">5</code>, y falla con una excepción si no fuera así.</p>

<p>Antes de escribir la función evaluadora, démosle un nombre al tipo de los entornos. Podríamos por supuesto simplemente utilizar <code class="highlighter-rouge">String =&gt; Int</code> para los entornos, pero simplifica el programa introducir un nombre para este tipo, y hace que los futuros cambios sean más fáciles. Esto lo realizamos de la siguiente manera:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Entorno = String =&gt; Int
</code></pre></div></div>

<p>De ahora en más, el tipo <code class="highlighter-rouge">Entorno</code> puede ser usado como un alias del tipo de funciones definidas de <code class="highlighter-rouge">String</code> a <code class="highlighter-rouge">Int</code>.</p>

<p>Ahora podemos dar la definición de la función evaluadora. Conceptualmente, es muy sencillo: el valor de una suma de dos expresiones es simplemente la suma de los valores de estas expresiones; el valor de una variable es obtenido directamente del entorno; y el valor de una constante es la constante en sí misma. Expresar esto en Scala no resulta para nada difícil:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def eval(a: Arbol, ent: Entorno): Int = a match {
  case Sum(i, d) =&gt; eval(i, ent) + eval(d, env)
  case Var(n)    =&gt; ent(n)
  case Const(v)  =&gt; v
}
</code></pre></div></div>

<p>Esta función evaluadora función realizando un <em>reconocimiento de patrones</em> (pattern matching) en el árbol <code class="highlighter-rouge">a</code>. Intuitivamente, el significado de la definición de arriba debería estar claro:</p>

<ol>
  <li>Primero comprueba si el árbol <code class="highlighter-rouge">t</code>es una <code class="highlighter-rouge">Sum</code>, y si lo es, asocia el sub-arbol izquierdo a una nueva variable llamada <code class="highlighter-rouge">i</code> y el sub-arbol derecho a la variable <code class="highlighter-rouge">r</code>, y después procede con la evaluación de la expresión que sigue a la flecha (<code class="highlighter-rouge">=&gt;</code>); esta expresión puede (y hace) uso de las variables asociadas por el patrón que aparece del lado izquierdo de la flecha.</li>
  <li>si la primer comprobación (la de <code class="highlighter-rouge">Sum</code>) no prospera, es decir que el árbol no es una <code class="highlighter-rouge">Sum</code>, sigue de largo y comprueba si <code class="highlighter-rouge">a</code> es un <code class="highlighter-rouge">Var</code>; si lo es, asocia el nombre contenido en el nodo <code class="highlighter-rouge">Var</code> a la variable <code class="highlighter-rouge">n</code> y procede con la parte derecha de la expresión.</li>
  <li>si la segunda comprobación también falla, resulta que <code class="highlighter-rouge">a</code> no es un <code class="highlighter-rouge">Sum</code> ni un <code class="highlighter-rouge">Var</code>, por lo tanto comprueba que sea un <code class="highlighter-rouge">Const</code>, y si lo es, asocia el valor contenido en el nodo <code class="highlighter-rouge">Const</code> a la variable <code class="highlighter-rouge">v</code>y procede con el lado derecho.</li>
  <li>finalmente, si todos las comprobaciones fallan, una excepción es lanzada para dar cuenta el fallo de la expresión; esto puede pasar solo si existen más subclases de <code class="highlighter-rouge">Arbol</code>.</li>
</ol>

<p>Hemos visto que la idea básica del reconocimiento de patrones es intentar coincidir un valor con una serie de patrones, y tan pronto como un patrón coincida, extraer y nombrar las varias partes del valor para finalmente evaluar algo de código que típicamente hace uso de esas partes nombradas.</p>

<p>Un programador con experiencia en orientación a objetos puede preguntarse por qué no definimos <code class="highlighter-rouge">eval</code> como un método de la clase <code class="highlighter-rouge">Arbol</code> y sus subclases. En realidad podríamos haberlo hecho, ya que Scala permite la definición de métodos en clases case tal como en clases normales. Por lo tanto decidir en usar reconocimiento de patrones o métodos es una cuestión de gustos, pero también tiene grandes implicancias en cuanto a la extensibilidad:</p>

<ul>
  <li>
    <p>cuando usamos métodos, es fácil añadir un nuevo tipo de nodo ya que esto puede ser realizado simplemente al definir una nueva subclase de <code class="highlighter-rouge">Arbol</code>; por otro lado, añadir una nueva operación para manipular el árbol es tedioso, ya que requiere la modificación en todas las subclases.</p>
  </li>
  <li>
    <p>cuando utilizamos reconocimiento de patrones esta situación es inversa: agregar un nuevo tipo de nodo requiere la modificación de todas las funciones que hacen reconocimiento de patrones sobre el árbol, para tomar en cuenta un nuevo nodo; pero por otro lado agregar una nueva operación fácil, solamente definiendolo como una función independiente.</p>
  </li>
</ul>

<p>Para explorar un poco más esto de pattern matching definamos otra operación aritmética: derivación simbólica. El lector recordará las siguientes reglas sobre esta operación:</p>

<ol>
  <li>la derivada de una suma es la suma de las derivadas,</li>
  <li>la derivada de una variable <code class="highlighter-rouge">v</code> es uno (1) si <code class="highlighter-rouge">v</code> es la variable relativa a la cual la derivada toma lugar, y cero (0)de otra manera,</li>
  <li>la derivada de una constante es cero (0).</li>
</ol>

<p>Estas reglas pueden ser traducidas casi literalmente en código Sclaa, para obtener la siguiente definición.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def derivada(a: Arbol, v: String): Arbol = a match {
  case Sum(l, r) =&gt; Sum(derivada(l, v), derivada(r, v))
  case Var(n) if (v == n) =&gt; Const(1)
  case _ =&gt; Const(0)
}
</code></pre></div></div>

<p>Esta función introduce dos nuevos conceptos relacionados al pattern matching. Primero que nada la expresión <code class="highlighter-rouge">case</code> para variables tienen una <em>guarda</em>, una expresión siguiendo la palabra clave <code class="highlighter-rouge">if</code>. Esta guarda previene que el patrón concuerde al menos que la expresión sea verdadera. Aquí es usada para asegurarse que retornamos la constante 1 solo si el nombre de la variable siendo derivada es el mismo que la variable derivada <code class="highlighter-rouge">v</code>. El segundo concepto nuevo usado aquí es el <em>comodín</em>, escrito con el guión bajo <code class="highlighter-rouge">_</code>, que coincide con cualquier valor que aparezca, sin darle un nombre.</p>

<p>No hemos explorado el completo poder del pattern matching aún, pero nos detendremos aquí para mantener este documento corto. Todavía nos queda pendiente ver cómo funcionan las dos funciones de arriba en un ejemplo real. Para ese propósito, escribamos una función main simple que realice algunas operaciones sobre la expresión <code class="highlighter-rouge">(x+x)+(7+y)</code>: primero computa su valor en el entorno <code class="highlighter-rouge">{ x -&gt; 5, y -&gt; 7 }</code> y después computa su derivada con respecto a <code class="highlighter-rouge">x</code> y después a <code class="highlighter-rouge">y</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def main(args: Array[String]) {
  val exp: Arbol = Sum(Sum(Var("x"),Var("x")),Sum(Const(7),Var("y")))
  val ent: Entonrno = { case "x" =&gt; 5 case "y" =&gt; 7 }
  println("Expresión: " + exp)
  println("Evaluación con x=5, y=7: " + eval(exp, ent))
  println("Derivada con respecto a x:\n " + derivada(exp, "x"))
  println("Derivada con respecto a y:\n " + derivada(exp, "y"))
}
</code></pre></div></div>

<p>Al ejecutar este programa obtenemos el siguiente resultado:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Expresión: Sum(Sum(Var(x),Var(x)),Sum(Const(7),Var(y)))
Evaluación con x=5, y=7: 24
Derivada con respecto a x:
 Sum(Sum(Const(1),Const(1)),Sum(Const(0),Const(0)))
Derivada con respecto a y:
 Sum(Sum(Const(0),Const(0)),Sum(Const(0),Const(1)))
</code></pre></div></div>

<p>Al examinar la salida vemos que el resultado de la derivada debería ser simplificado antes de ser presentado al usuario. Definir una función de simplificación básica utilizando reconocimiento de patrones es un problema interesante (y, por no decir complejo, que necesita una solución astuta), lo dejamos para un ejercicio para el lector.</p>

<h2 id="traits">Traits</h2>

<p><em>Nota: La palabra Trait(/treɪt/, pronunciado Treit) puede ser traducida literalmente como “Rasgo”. De todas maneras decido utilizar la notación original por ser un concepto muy arraigado a Scala</em></p>

<p>Aparte de poder heredar código de una super clase, una clase en Scala puede también importar código de uno o varios <em>traits</em>.</p>

<p>Tal vez la forma más fácil para un programador Java de entender qué son los traits es verlos como interfaces que también pueden contener código. En Scala, cuando una clase hereda de un trait, implementa la interface de ese trait, y hereda todo el código contenido en el trait.</p>

<p>Para ver la utilidad de los traits, veamos un ejemplo clásico: objetos ordenados. Generalmente es útil tener la posibilidad de comparar objetos de una clase dada entre ellos, por ejemplo, para ordenarlos. En Java, los objetos que son comparables implementan la interfaz <code class="highlighter-rouge">Comparable</code>. En Scala, podemos hacer algo un poco mejor que en Java al definir un trait equivalente <code class="highlighter-rouge">Comparable</code> que invocará a <code class="highlighter-rouge">Ord</code>.</p>

<p>Cuando comparamos objetos podemos utilizar seis predicados distintos: menor, menor o igual, igual, distinto, mayor o igual y mayor. De todas maneras, definir todos estos es fastidioso, especialmente que cuatro de estos pueden ser expresados en base a los otros dos. Esto es, dados los predicados “igual” y “menor” (por ejemplo), uno puede expresar los otros. En Scala, todas estas observaciones pueden ser fácilmente capturadas mediante la siguiente declaración de un Trait:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait Ord {
  def &lt; (that: Any): Boolean
  def &lt;=(that: Any): Boolean =  (this &lt; that) || (this == that)
  def &gt; (that: Any): Boolean = !(this &lt;= that)
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}
</code></pre></div></div>

<p>Esta definición crea un nuevo tipo llamado <code class="highlighter-rouge">Ord</code> el cual juega el mismo rol que la interfaz <code class="highlighter-rouge">Comparable</code>, como también provee implementaciones de tres predicados en términos de un cuarto, abstracto. Los predicados para igualidad y su inverso (distinto, no igual) no aparecen aquí ya que por defecto están presenten en todos los objetos.</p>

<p>El tipo <code class="highlighter-rouge">Any</code> el cual es usado arriba es el supertipo de todos los otros tipos en Scala. Puede ser visto como una versión más general del tipo <code class="highlighter-rouge">Object</code> en Java, ya que <code class="highlighter-rouge">Any</code> también es supertipo de <code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Float</code>, etc. cosa que no se cumple en Java (<code class="highlighter-rouge">int</code> por ejemplo es un tipo primitivo).</p>

<p>Para hacer a un objeto de la clase comparable es suficiente definir los predicados que comprueban la igualdad y la inferioridad y mezclar la clase <code class="highlighter-rouge">Ord</code> de arriba. Como un ejemplo, definamos una clase <code class="highlighter-rouge">Fecha</code> que representa fechas en el calendario gregoriano.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Fecha(d: Int, m: Int, a: Int) extends Ord {
  def anno = a
  def mes = m
  def dia = d
  override def toString(): String = anno + "-" + mes + "-" + dia
</code></pre></div></div>

<p>La parte importante aquí es la declaración <code class="highlighter-rouge">extends Ord</code> la cual sigue al nombre de la clase y los parámetros. Declara que la clase <code class="highlighter-rouge">Fecha</code> hereda del trait <code class="highlighter-rouge">Ord</code>.</p>

<p>Después redefinimos el método <code class="highlighter-rouge">equals</code>, heredado de <code class="highlighter-rouge">Object</code>, para comparar correctamente fechas mediante sus campos individuales. La implementación por defecto de <code class="highlighter-rouge">equals</code> no es utilizable, porque como en Java, compara los objetos físicamente. Por lo tanto llegamos a esto:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def equals(that: Any): Boolean =
  that.isInstanceOf[Fecha] &amp;&amp; {
    val o = that.asInstanceOf[Fecha]
    o.dia== dia &amp;&amp; o.mes == mes &amp;&amp; o.anno== anno
  }
</code></pre></div></div>

<p>Este método utiliza el método predefinido <code class="highlighter-rouge">isInstanceOf</code> (“es instancia de”) y <code class="highlighter-rouge">asInstanceOf</code> (“como instancia de”). El primero <code class="highlighter-rouge">isInstanceOf</code> se corresponde con el operador java <code class="highlighter-rouge">instanceOf</code> y retorna <code class="highlighter-rouge">true</code> si y solo si el objeto en el cual es aplicado es una instancia del tipo dado. El segundo, <code class="highlighter-rouge">asInstanceOf</code>, corresponde al operador de casteo en Java: si el objeto es una instancia de un tipo dado, esta es vista como tal, de otra manera se lanza una excepción <code class="highlighter-rouge">ClassCastException</code>.</p>

<p>Finalmente el último método para definir es el predicado que comprueba la inferioridad. Este hace uso de otro método predefinido, <code class="highlighter-rouge">error</code> que lanza una excepción con el mensaje de error provisto.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def &lt;(that: Any): Boolean = {
    if (!that.isInstanceOf[Fecha])
      error("no se puede comparar" + that + " y una fecha")

  val o = that.asInstanceOf[Fecha]
  (anno &lt; o.anno) ||
  (anno== o.anno &amp;&amp; (mes &lt; o.mes ||
                     (mes == o.mes &amp;&amp; dia &lt; o.dia)))
}
</code></pre></div></div>

<p>Esto completa la definición de la clase <code class="highlighter-rouge">Fecha</code>. Las instancias de esta clase pueden ser vistas tanto como fechas o como objetos comparables. Además, todas ellas definen los seis predicados de comparación mencionados arriba: <code class="highlighter-rouge">equals</code> y <code class="highlighter-rouge">&lt;</code> porque aparecen directamente en la definición de la clase <code class="highlighter-rouge">Fecha</code> y los otros porque son heredados del trait <code class="highlighter-rouge">Ord</code>.</p>

<p>Los traits son útiles en muchas otras más situaciones que las aquí mostrada, pero discutir sus aplicaciones está fuera del alcance de este documento.</p>

<h2 id="tipos-genéricos">Tipos Genéricos</h2>

<p><em>Nota: El diseñador de los tipos genéricos en Java fue nada más ni nada menos que Martin Odersky, el diseñador de Scala.</em></p>

<p>La última característica de Scala que exploraremos en este tutorial es la de los tipos genéricos. Los programadores de Java deben estar bien al tanto de los problemas que genera la falta de genéricos en su lenguaje, lo cual es solucionado en Java 1.5.</p>

<p>Los tipos genéricos proveen al programador la habilidad de escribir código parametrizado por tipos. Por ejemplo, escribir una librería para listas enlazadas se enfrenta al problema de decidir qué tipo darle a los elementos de la lista. Ya que esta lista está pensada para ser usada en diferentes contextos, no es posible decidir que el tipo de elementos sea, digamos, <code class="highlighter-rouge">Int</code>. Esto sería completamente arbitrario y muy restrictivo.</p>

<p>Los programadores Java cuentan como último recurso con <code class="highlighter-rouge">Object</code>, que es el supertipo de todos los objetos. Esta solución de todas maneras está lejos de ser ideal, ya que no funciona con tipos primitivos (<code class="highlighter-rouge">int</code>, <code class="highlighter-rouge">long</code>, <code class="highlighter-rouge">float</code>, etc.) e implica que el programador tenga que realizar muchos casteos de tipos en su programa.</p>

<p>Scala hace posible definir clases genéricas (y métodos) para resolver este problema. Examinemos esto con un ejemplo del contenedor más simple posible: una referencia, que puede estar tanto vacía como apuntar a un objeto de algún tipo.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Referencia[T] {
  private var contenido: T = _
  def set(valor: T) { contenido = valor }
  def get: T = contenido
}
</code></pre></div></div>

<p>La clase <code class="highlighter-rouge">Referencia</code> es parametrizada por un tipo llamado <code class="highlighter-rouge">T</code>, que es el tipo de sus elementos. Este tipo es usado en el cuerpo de la clase como el tipo de la variable <code class="highlighter-rouge">contenido</code>, el argumento del método <code class="highlighter-rouge">set</code> y el tipo de retorno del método <code class="highlighter-rouge">get</code>.</p>

<p>El ejemplo anterior introduce a las variables en Scala, que no deberían requerir mayor explicación. Es interesante notar que el valor inicial dado a la variable <code class="highlighter-rouge">contenido</code> es <code class="highlighter-rouge">_</code>, que representa un valor por defecto. Este valor por defecto es 0 para tipos numéricos, <code class="highlighter-rouge">false</code> para tipos <code class="highlighter-rouge">Boolean</code>, <code class="highlighter-rouge">()</code> para el tipo <code class="highlighter-rouge">Unit</code> y <code class="highlighter-rouge">null</code> para el resto de los objetos.</p>

<p>Para utilizar esta clase <code class="highlighter-rouge">Referencia</code>, uno necesita especificar qué tipo utilizar por el parámetro <code class="highlighter-rouge">T</code>, es decir, el tipo del elemento contenido por la referencia. Por ejemplo, para crear y utilizar una referencia que contenga un entero, podríamos escribir lo siguiente:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object ReferenciaEntero {
  def main(args: Array[String]) {
    val ref = new Referencia[Int]
    ref.set(13)
    println("La referncia tiene la mitad de " + (ref.get * 2))
  }
}
</code></pre></div></div>

<p>Como puede verse en el ejemplo, no es necesario castear el valor retornado por el método <code class="highlighter-rouge">get</code> antes de usarlo como un entero. Tampoco es posible almacenar otra cosa que no sea un entero en esa referencia en particular, ya que fue declarada como contenedora de un entero.</p>

<h2 id="conclusión">Conclusión</h2>

<p>Scala es un lenguaje tremendamente poderoso que ha sabido heredar las mejores cosas de cada uno de los lenguajes más exitosos que se han conocido. Java no es la excepción, y comparte muchas cosas con este. La diferencia que vemos es que para cada uno de los conceptos de Java, Scala los aumenta, refina y mejora. Poder aprender todas las características de Scala nos equipa con más y mejores herramientas a la hora de escribir nuestros programas.
Si bien la programación funcional no ha sido una característica de Java, el programador experimentado puede notar la falta de soporte de este paradigma en múltiples ocasiones. El solo pensar en el código necesario para proveer a un <code class="highlighter-rouge">JButton</code> con el código que debe ejecutar al ser presionado nos muestra lo necesario que sería contar con herramientas funcionales. Recomendamos entonces tratar de ir incorporando estas características, por más que sea difícil para el programador Java al estar tan acostumbrado al paradigma imperativo de este lenguaje.</p>

<p>Este documento dio una rápida introducción al lenguaje Scala y presento algunos ejemplos básicos. El lector interesado puede seguir, por ejemplo, leyendo el <em>Tutorial de Scala</em> que figura en el sitio de documentación, o <em>Scala by Example</em> (en inglés). También puede consultar la especificación del lenguaje cuando lo desee.</p>

				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">
      <div id="toc"></div>
      
         
         
        <ul id="available-languages" style="display: none;">
          <li><a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">English</a></li>
          
            
            <li><a href="/docs.scala-lang/es/tutorials/scala-for-java-programmers.html" class="lang">Español</a></li>
          
            
            <li><a href="/docs.scala-lang/ko/tutorials/scala-for-java-programmers.html" class="lang">한국어</a></li>
          
            
            <li><a href="/docs.scala-lang/de/tutorials/scala-for-java-programmers.html" class="lang">Deutsch</a></li>
          
            
            <li><a href="/docs.scala-lang/it/tutorials/scala-for-java-programmers.html" class="lang">Italiano</a></li>
          
            
            <li><a href="/docs.scala-lang/zh-tw/tutorials/scala-for-java-programmers.html" class="lang">中文 (繁體)</a></li>
          
        </ul>
      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_es/tutorials/scala-for-java-programmers.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/docs.scala-lang/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/docs.scala-lang/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/docs.scala-lang/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/docs.scala-lang/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/docs.scala-lang/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/docs.scala-lang/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/docs.scala-lang/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/docs.scala-lang/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/docs.scala-lang/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/docs.scala-lang/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/docs.scala-lang/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/docs.scala-lang/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/docs.scala-lang/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

