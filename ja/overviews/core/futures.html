<!DOCTYPE html>
<html>
  <head>
    <title>Future と Promise | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/docs.scala-lang.org/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/docs.scala-lang.org/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/docs.scala-lang.org/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs.scala-lang.org/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/docs.scala-lang.org/resources/favicon-16x16.png">
    <link rel="manifest" href="/docs.scala-lang.org/resources/site.webmanifest">
    <link rel="mask-icon" href="/docs.scala-lang.org/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/docs.scala-lang.org/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/docs.scala-lang.org/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/docs.scala-lang.org/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/docs.scala-lang.org/" class="navigation-bdand">
        <img src="/docs.scala-lang.org/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang.org/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang.org/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang.org/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang.org/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/books.html">Books</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/docs.scala-lang.org/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">Futures</div>
          
          <h1>Future と Promise</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p><strong>Philipp Haller, Aleksandar Prokopec, Heather Miller, Viktor Klang, Roland Kuhn, Vojin Jovanovic 著</strong><br />
<strong>Eugene Yokota 訳</strong></p>

<h2 id="概要">概要</h2>

<p><strong>Future</strong> は並列に実行される複数の演算を取り扱うのに便利な方法を提供する。それは効率的でノンブロッキングな方法だ。
大まかな考え方はシンプルなもので、<code class="highlighter-rouge">Future</code> はまだ存在しない計算結果に対するプレースホルダのようなものだ。
一般的に、<code class="highlighter-rouge">Future</code> の結果は並行に計算され後で集計することができる。
このように並行なタスクを合成することで、より速く、非同期で、ノンブロッキングな並列コードとなることが多い。</p>

<p>デフォルトでは、Future も Promise もノンブロッキングであり、典型的なブロッキング演算の代わりにコールバックを使う。
コールバックの使用を概念的にも構文的にも単純化するために、Scala は Future をノンブロッキングに合成する <code class="highlighter-rouge">flatMap</code>、<code class="highlighter-rouge">foreach</code>、<code class="highlighter-rouge">filter</code> といったコンビネータを提供する。
ブロックすることは可能で、(推奨されないが) 絶対に必要だという場面においては Future をブロックすることもできる。</p>

<!--
The futures and promises API builds upon the notion of an
`ExecutionContext`, an execution environment designed to manage
resources such as thread pools between parallel frameworks and
libraries (detailed in an accompanying SIP, forthcoming). Futures and
promises are created through such `ExecutionContext`s. For example, this makes it possible,
in the case of an application which requires blocking futures, for an underlying execution
environment to resize itself if necessary to guarantee progress.
-->

<h2 id="future">Future</h2>

<p><code class="highlighter-rouge">Future</code> は、ある時点において利用可能となる可能性のある値を保持するオブジェクトだ。
この値は、なんらかの計算結果であることが多い。
その計算が例外とともに失敗する可能性があるため、<code class="highlighter-rouge">Future</code> は計算が例外を投げる場合を想定して例外を保持することもできる。
ある <code class="highlighter-rouge">Future</code> が値もしくは例外を持つとき、<code class="highlighter-rouge">Future</code> は<strong>完了</strong>したという。
<code class="highlighter-rouge">Future</code> が値とともに完了した場合、<code class="highlighter-rouge">Future</code> はその値とともに<strong>成功</strong>したという。
<code class="highlighter-rouge">Future</code> が例外とともに完了した場合、<code class="highlighter-rouge">Future</code> はその例外とともに<strong>失敗</strong>したという。</p>

<p><code class="highlighter-rouge">Future</code> には 1回だけ代入することができるという重要な特性がある。
一度 Future オブジェクトが値もしくは例外を持つと、実質不変となり、それが上書きされることは絶対に無い。</p>

<p>Future オブジェクトを作る最も簡単な方法は、非同期の計算を始めてその結果を持つ <code class="highlighter-rouge">Future</code> を返す
<code class="highlighter-rouge">future</code> メソッドを呼び出すことだ。
計算結果は <code class="highlighter-rouge">Future</code> が完了すると利用可能になる。</p>

<p>ここで注意して欲しいのは <code class="highlighter-rouge">Future[T]</code> は Future オブジェクトの型であり、
<code class="highlighter-rouge">future</code> はなんらかの非同期な計算を作成しスケジュールして、その計算結果とともに完了する
Future オブジェクトを返すメソッドだということだ。</p>

<p>具体例で説明しよう。
ある人気ソーシャルネットワークの API を想定して、与えられたユーザの友達のリストを取得できるものとする。
まず新しいセッションを開いて、ある特定のユーザの友達リストを申請する:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent._
import ExecutionContext.Implicits.global

val session = socialNetwork.createSessionFor("user", credentials)
val f: Future[List[Friend]] = Future {
  session.getFriends()
}
</code></pre></div></div>

<p>上の例では、まず <code class="highlighter-rouge">scala.concurrent</code> パッケージの内容をインポートすることで
<code class="highlighter-rouge">Future</code> 型と <code class="highlighter-rouge">future</code> が見えるようにしている。
2つ目のインポートは追って説明する。</p>

<p>次に、仮想の <code class="highlighter-rouge">createSessionFor</code> メソッドを呼んでサーバにリクエストを送るセッション変数を初期化している。</p>

<p>ユーザの友達リストを取得するには、ネットワークごしにリクエストを送信する必要があり、それは長い時間がかかる可能性がある。
これは <code class="highlighter-rouge">getFriends</code> メソッドで例示されている。
応答が返ってくるまでの間に CPU を有効に使うには、プログラムの残りをブロックするべきではない。
つまり、この計算は非同期にスケジュールされるべきだ。
ここで使われている <code class="highlighter-rouge">future</code> メソッドはまさにそれを行い、与えれたブロックを並行に実行する。
この場合は、リクエストを送信し応答を待ち続ける。</p>

<p>サーバが応答すると Future <code class="highlighter-rouge">f</code> 内において友達リストが利用可能となる。</p>

<p>試みが失敗すると、例外が発生するかもしれない。
以下の例では、<code class="highlighter-rouge">session</code> 変数の初期化が不正なため、<code class="highlighter-rouge">future</code> ブロック内の計算が
<code class="highlighter-rouge">NullPointerException</code> を投げる。この Future <code class="highlighter-rouge">f</code> は、この例外とともに失敗する:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val session = null
val f: Future[List[Friend]] = Future {
  session.getFriends
}
</code></pre></div></div>

<p>上の <code class="highlighter-rouge">import ExecutionContext.Implicits.global</code>
という一文はデフォルトのグローバルな実行コンテキスト (execution context) をインポートする。
実行コンテキストは渡されたタスクを実行し、スレッドプールのようなものだと考えていい。
これらは、非同期計算がいつどのように実行されるかを取り扱うため、<code class="highlighter-rouge">future</code> メソッドに欠かせないものだ。
独自の実行コンテキストを定義して <code class="highlighter-rouge">future</code>
とともに使うことができるが、今のところは上記のようにデフォルトの実行コンテキストをインポートできるということが分かれば十分だ。</p>

<p>この例ではネットワークごしにリクエストを送信して応答を待つという仮想のソーシャルネットワーク API を考えてみた。
すぐに試してみることができる非同期の計算の例も考えてみよう。
テキストファイルがあったとして、その中である特定のキーワードが最初に出てきた位置を知りたいとする。
この計算はファイルの内容をディスクから読み込むのにブロッキングする可能性があるため、他の計算と並行実行するのは理にかなっている。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val firstOccurence: Future[Int] = Future {
  val source = scala.io.Source.fromFile("myText.txt")
  source.toSeq.indexOfSlice("myKeyword")
}
</code></pre></div></div>

<h3 id="コールバック">コールバック</h3>

<p>これで非同期な計算を始めて新しい Future オブジェクトを作る方法は分かったけども、計算結果が利用可能となったときにそれを使って何かをする方法をまだみていない。
多くの場合、計算の副作用だけじゃなくて、その結果に興味がある。</p>

<p>Future の実装の多くは、Future の結果を知りたくなったクライアントは Future が完了するまで自分の計算をブロックすることを強要する。そうしてやっと Future の計算結果を得られた後に自分の計算を続行できるようになる。
後でみるように、この方式も Scala の Future API で可能となっているが、性能という観点から見ると Future
にコールバックを登録することで完全にノンブロッキングで行う方が好ましいと言える。
このコールバックは Future が完了すると非同期に呼び出される。
コールバックの登録時に Future が既に完了している場合は、コールバックは非同期に実行されるか、もしくは同じスレッドで逐次的に実行される。</p>

<p>コールバックを登録する最も汎用的な方法は、<code class="highlighter-rouge">Try[T] =&gt; U</code> 型の関数を受け取る <code class="highlighter-rouge">onComplete</code> メソッドを使うことだ。
このコールバックは、Future が成功すれば <code class="highlighter-rouge">Success[T]</code> 型の値に適用され、失敗すれば <code class="highlighter-rouge">Failure[T]</code> 型の値に適用される。</p>

<p>この <code class="highlighter-rouge">Try[T]</code> は、それが何らか型の値を潜在的に保持するモナドだという意味において
<code class="highlighter-rouge">Option[T]</code> や <code class="highlighter-rouge">Either[T, S]</code> に似ている。
しかし、これは値か Throwable なオブジェクトを保持することに特化して設計されている。
<code class="highlighter-rouge">Option[T]</code> が値 (つまり <code class="highlighter-rouge">Some[T]</code>) を持つか、何も持たない (つまり <code class="highlighter-rouge">None</code>)
のに対して、<code class="highlighter-rouge">Try[T]</code> は値を持つ場合は <code class="highlighter-rouge">Success[T]</code> で、それ以外の場合は <code class="highlighter-rouge">Failure[T]</code> で必ず例外を持つ。
<code class="highlighter-rouge">Failure[T]</code> は、何故値が無いのかを説明できるため、<code class="highlighter-rouge">None</code> よりも多くの情報を持つ。
同様に <code class="highlighter-rouge">Try[T]</code> を <code class="highlighter-rouge">Either[Throwable, T]</code>、つまり左値を <code class="highlighter-rouge">Throwable</code> に固定した特殊形だと考えることもできる。</p>

<p>ソーシャルネットワークの例に戻って、最近の自分の投稿した文のリストを取得して画面に表示したいとする。
これは <code class="highlighter-rouge">List[String]</code> を返す <code class="highlighter-rouge">getRecentPosts</code> メソッドを呼ぶことで行われ、戻り値には最近の文のリストが入っている:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onComplete {
  case Success(posts) =&gt; for (post &lt;- posts) println(post)
  case Failure(t) =&gt; println("エラーが発生した: " + t.getMessage)
}
</code></pre></div></div>

<p><code class="highlighter-rouge">onComplete</code> メソッドは、Future 計算の失敗と成功の両方の結果を扱えるため、汎用性が高い。
成功した結果のみ扱う場合は、(部分関数を受け取る) <code class="highlighter-rouge">onSuccess</code> コールバックを使う:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onSuccess {
  case posts =&gt; for (post &lt;- posts) println(post)
}
</code></pre></div></div>

<p>失敗した結果のみ扱う場合は、<code class="highlighter-rouge">onFailure</code> コールバックを使う:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onFailure {
  case t =&gt; println("エラーが発生した: " + t.getMessage)
}

f onSuccess {
  case posts =&gt; for (post &lt;- posts) println(post)
}
</code></pre></div></div>

<p><code class="highlighter-rouge">onFalure</code> コールバックは Future が失敗した場合、つまりそれが例外を保持する場合のみ実行される。</p>

<p>部分関数は <code class="highlighter-rouge">isDefinedAt</code> メソッドを持つため、<code class="highlighter-rouge">onFailure</code> メソッドはコールバックが特定の <code class="highlighter-rouge">Throwable</code> に対して定義されている場合のみ発火される。
以下の例では、登録された <code class="highlighter-rouge">onFailure</code> コールバックは発火されない:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future {
  2 / 0
}

f onFailure {
  case npe: NullPointerException =&gt;
    println("これが表示されているとしたらビックリ。")
}
</code></pre></div></div>

<p>キーワードの初出の位置を検索する例に戻ると、キーワードの位置を画面に表示したいかもしれない:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val firstOccurence: Future[Int] = Future {
  val source = scala.io.Source.fromFile("myText.txt")
  source.toSeq.indexOfSlice("myKeyword")
}

firstOccurence onSuccess {
  case idx =&gt; println("キーワードの初出位置: " + idx)
}

firstOccurence onFailure {
  case t =&gt; println("ファイルの処理に失敗した: " + t.getMessage)
}
</code></pre></div></div>

<p><code class="highlighter-rouge">onComplete</code>、<code class="highlighter-rouge">onSuccess</code>、および <code class="highlighter-rouge">onFailure</code> メソッドは全て <code class="highlighter-rouge">Unit</code> 型を返すため、これらの呼び出しを連鎖させることができない。
これは意図的な設計で、連鎖された呼び出しが登録されたコールバックの実行の順序を暗示しないようにしている
(同じ Future に登録されたコールバックは順不同に発火される)。</p>

<p>ここで、コールバックが実際のところ<strong>いつ</strong>呼ばれるのかに関して説明する必要がある。
Future 内の値が利用可能となることを必要とするため、Future が完了した後でのみ呼び出されることができる。
しかし、Future を完了したスレッドかコールバックを作成したスレッドのいずれかにより呼び出されるという保証は無い。
かわりに、コールバックは Future オブジェクトが完了した後のいつかに何らかスレッドにより実行される。
これをコールバックが実行されるのは <strong>eventually</strong> だという。</p>

<p>さらに、コールバックが実行される順序は、たとえ同じアプリケーションを複数回実行した間だけでも決定してない。
実際、コールバックは逐次的に呼び出されるとは限らず、一度に並行実行されるかもしれない。
そのため、以下の例における変数 <code class="highlighter-rouge">totalA</code> は計算されたテキスト内の正しい小文字と大文字の <code class="highlighter-rouge">a</code> の合計数を持たない場合がある。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@volatile var totalA = 0

val text = Future {
  "na" * 16 + "BATMAN!!!"
}

text onSuccess {
  case txt =&gt; totalA += txt.count(_ == 'a')
}

text onSuccess {
  case txt =&gt; totalA += txt.count(_ == 'A')
}
</code></pre></div></div>

<p>2つのコールバックが順次に実行された場合は、変数 <code class="highlighter-rouge">totalA</code> は期待される値 <code class="highlighter-rouge">18</code> を持つ。
しかし、これらは並行して実行される可能性もあるため、その場合は <code class="highlighter-rouge">totalA</code> は
<code class="highlighter-rouge">+=</code> が atomic な演算ではないため、
(つまり、読み込みと書き込みというステップから構成されており、それが他の読み込みと書き込みの間に挟まって実行される可能性がある)
<code class="highlighter-rouge">16</code> または <code class="highlighter-rouge">2</code> という値になってしまう可能性もある。</p>

<p>万全を期して、以下にコールバックの意味論を列挙する:</p>

<!-- keep this html -->
<ol>
<li>Future に <code>onComplete</code> コールバックを登録することで、対応するクロージャが Future が完了した後に eventually に実行されることが保証される。</li>

<li><code>onSuccess</code> や <code>onFailure</code> コールバックを登録することは <code>onComplete</code> と同じ意味論を持つ。ただし、クロージャがそれぞれ成功したか失敗した場合のみに呼ばれるという違いがある。</li>

<li>既に完了した Future にコールバックを登録することは (1 により) コールバックが eventually に実行されることとなる。</li>

<li>Future に複数のコールバックが登録された場合は、それらが実行される順序は定義されない。それどころか、コールバックは並行に実行される可能性がある。しかし、<code>ExecutionContext</code> の実装によっては明確に定義された順序となる可能性もある。</li>

<li>例外を投げるコールバックがあったとしても、他のコールバックは実行される。</li>

<li>完了しないコールバックがあった場合 (つまりコールバックに無限ループがあった場合)他のコールバックは実行されない可能性がある。そのような場合はブロックする可能性のあるコールバックは <code>blocking</code> 構文を使うべきだ (以下参照)。</li>

<li>コールバックの実行後はそれは Future オブジェクトから削除され、GC 対象となる。</li>
</ol>

<h3 id="関数型合成と-for-内包表記">関数型合成と for 内包表記</h3>

<p>上でみたコールバック機構により Future の結果を後続の計算に連鎖することが可能となった。
しかし、場合によっては不便だったり、コードが肥大化することもある。
具体例で説明しよう。
為替トレードサービスの API があって、米ドルを有利な場合のみ買いたいとする。
まずコールバックを使ってこれを実現してみよう:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val rateQuote = Future {
  connection.getCurrentValue(USD)
}

rateQuote onSuccess { case quote =&gt;
  val purchase = Future {
    if (isProfitable(quote)) connection.buy(amount, quote)
    else throw new Exception("有益ではない")
  }

  purchase onSuccess {
    case _ =&gt; println(amount + " USD を購入した")
  }
}
</code></pre></div></div>

<p>まずは現在の為替相場を取得する <code class="highlighter-rouge">rateQuote</code> という <code class="highlighter-rouge">Future</code> を作る。
この値がサーバから取得できて Future が成功した場合は、計算は
<code class="highlighter-rouge">onSuccess</code> コールバックに進み、ここで買うかどうかの決断をすることができる。
ここでもう 1つの Future である <code class="highlighter-rouge">purchase</code> を作って、有利な場合のみ買う決定をしてリクエストを送信する。
最後に、<code class="highlighter-rouge">purchase</code> が完了すると、通知メッセージを標準出力に表示する。</p>

<p>これは動作するが、2つの理由により不便だ。
第一に、<code class="highlighter-rouge">onSuccess</code> を使わなくてはいけなくて、2つ目の Future である
<code class="highlighter-rouge">purchase</code> をその中に入れ子にする必要があることだ。
例えば <code class="highlighter-rouge">purchase</code> が完了した後に別の貨幣を売却したいとする。
それはまた <code class="highlighter-rouge">onSuccess</code> の中でこのパターンを繰り返すことになり、インデントしすぎで理解しづらく肥大化したコードとなる。</p>

<p>第二に、<code class="highlighter-rouge">purchase</code> は他のコードのスコープ外にあり、<code class="highlighter-rouge">onSuccess</code>
コールバック内においてのみ操作することができる。
そのため、アプリケーションの他の部分は <code class="highlighter-rouge">purchase</code> を見ることができず、他の貨幣を売るために別の
<code class="highlighter-rouge">onSuccess</code> コールバックを登録することもできない。</p>

<p>これらの 2つの理由から Future はより自然な合成を行うコンビネータを提供する。
基本的なコンビネータの 1つが <code class="highlighter-rouge">map</code> で、これは与えられた Future
とその値に対する投射関数から、元の Future が成功した場合に投射した値とともに完了する新しい Future を生成する。
Future の投射はコレクションの投射と同様に考えることができる。</p>

<p>上の例を <code class="highlighter-rouge">map</code> コンビネータを使って書き換えてみよう:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val rateQuote = Future {
  connection.getCurrentValue(USD)
}

val purchase = rateQuote map { quote =&gt;
  if (isProfitable(quote)) connection.buy(amount, quote)
  else throw new Exception("有益ではない")
}

purchase onSuccess {
  case _ =&gt; println(amount + " USD を購入した")
}
</code></pre></div></div>

<p><code class="highlighter-rouge">rateQuote</code> に対して <code class="highlighter-rouge">map</code> を使うことで <code class="highlighter-rouge">onSuccess</code> コールバックを一切使わないようになった。
それと、より重要なのが入れ子が無くなったことだ。
ここで他の貨幣を売却したいと思えば、<code class="highlighter-rouge">purchase</code> に再び <code class="highlighter-rouge">map</code> するだけでいい。</p>

<p>しかし、<code class="highlighter-rouge">isProfitable</code> が <code class="highlighter-rouge">false</code> を返して、例外が投げられた場合はどうなるだろう?
その場合は <code class="highlighter-rouge">purchase</code> は例外とともに失敗する。
さらに、コネクションが壊れて <code class="highlighter-rouge">getCurrentValue</code> が例外を投げて <code class="highlighter-rouge">rateQuote</code>
が失敗した場合を想像してほしい。
その場合は、投射する値が無いため <code class="highlighter-rouge">purchase</code> は自動的に <code class="highlighter-rouge">rateQuote</code> と同じ例外とともに失敗する。</p>

<p>結果として、もし元の Future が成功した場合は、返される Future は元の Future の値を投射したものとともに完了する。
もし投射関数が例外を投げた場合は Future はその例外とともに完了する。
もし元の Future が例外とともに失敗した場合は、返される Future も同じ例外を持つ。
この例外を伝搬させる意味論は他のコンビネータにおいても同様だ。</p>

<p>Future の設計指針の 1つは for 内包表記から利用できるようにすることだった。
このため、Future は <code class="highlighter-rouge">flatMap</code>、<code class="highlighter-rouge">filter</code> そして <code class="highlighter-rouge">foreach</code> コンビネータを持つ。
<code class="highlighter-rouge">flatMap</code> メソッドは値を新しい Future <code class="highlighter-rouge">g</code> に投射する関数を受け取り、<code class="highlighter-rouge">g</code>
が完了したときに完了する新たな Future を返す。</p>

<p>米ドルをスイス・フラン (CHF) と交換したいとする。
両方の貨幣の為替レートを取得して、両者の値に応じて購入を決定する必要がある。
以下に for 内包表記を使った <code class="highlighter-rouge">flatMap</code> と <code class="highlighter-rouge">withFilter</code> の例をみてみよう:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val usdQuote = Future { connection.getCurrentValue(USD) }
val chfQuote = Future { connection.getCurrentValue(CHF) }

val purchase = for {
  usd &lt;- usdQuote
  chf &lt;- chfQuote
  if isProfitable(usd, chf)
} yield connection.buy(amount, chf)

purchase onSuccess {
  case _ =&gt; println(amount + " CHF を購入した")
}
</code></pre></div></div>

<p>この <code class="highlighter-rouge">purchase</code> は <code class="highlighter-rouge">usdQuote</code> と <code class="highlighter-rouge">chfQuote</code> が完了した場合のみ完了する。
これら 2つの Future の値に依存するため、それよりも早く自分の計算を始めることができない。</p>

<p>上の for 内包表記は以下のように翻訳される:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val purchase = usdQuote flatMap {
  usd =&gt;
  chfQuote
    .withFilter(chf =&gt; isProfitable(usd, chf))
    .map(chf =&gt; connection.buy(amount, chf))
}
</code></pre></div></div>

<p>これは for 内包表記に比べて分かりづらいが、<code class="highlighter-rouge">flatMap</code> 演算をより良く理解するために解析してみよう。
<code class="highlighter-rouge">flatMap</code> 演算は自身の値を別の Future へと投射する。
この別の Future が完了すると、戻り値の Future もその値とともに完了する。
上記の例では、<code class="highlighter-rouge">flatMap</code> は <code class="highlighter-rouge">usdQuote</code> Future の値を用いて <code class="highlighter-rouge">chfQuote</code>
の値をある特定の値のスイス・フランを購入するリクエストを送信する 3つ目の Future に投射している。
結果の Future である <code class="highlighter-rouge">purchase</code> は、この 3つ目の Future が <code class="highlighter-rouge">map</code> から帰ってきた後にのみ完了する。</p>

<p>これは難解だが、幸いな事に <code class="highlighter-rouge">flatMap</code> 演算は使いやすく、また分かりやすい
for 内包表記以外の場合はあまり使われない。</p>

<p><code class="highlighter-rouge">filter</code> コンビネータは、元の Future の値が条件関数を満たした場合のみその値を持つ新たな Future を作成する。
それ以外の場合は新しい Future は <code class="highlighter-rouge">NoSuchElementException</code> とともに失敗する。
Future に関しては、<code class="highlighter-rouge">filter</code> の呼び出しは <code class="highlighter-rouge">withFilter</code> の呼び出しと全く同様の効果がある。</p>

<p><code class="highlighter-rouge">collect</code> と <code class="highlighter-rouge">filter</code> コンビネータの関係はコレクション API におけるこれらのメソッドの関係に似ている。</p>

<p><code class="highlighter-rouge">foreach</code> コンビネータで注意しなければいけないのは値が利用可能となった場合に走査するのにブロックしないということだ。
かわりに、<code class="highlighter-rouge">foreach</code> のための関数は Future が成功した場合のみ非同期に実行される。
そのため、<code class="highlighter-rouge">foreach</code> は <code class="highlighter-rouge">onSuccess</code> コールバックと全く同じ意味を持つ。</p>

<p><code class="highlighter-rouge">Future</code> トレイトは概念的に (計算結果と例外という) 2つの型の値を保持することができるため、例外処理のためのコンビネータが必要となる。</p>

<p><code class="highlighter-rouge">rateQuote</code> に基いて何らかの額を買うとする。
<code class="highlighter-rouge">connection.buy</code> メソッドは <code class="highlighter-rouge">amount</code> と期待する <code class="highlighter-rouge">quote</code> を受け取る。
これは買われた額を返す。
<code class="highlighter-rouge">quote</code> に変更があった場合は、何も買わずに <code class="highlighter-rouge">QuoteChangedException</code> を投げる。
例外の代わりに <code class="highlighter-rouge">0</code> を持つ Future を作りたければ <code class="highlighter-rouge">recover</code> コンビネータを用いる:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val purchase: Future[Int] = rateQuote map {
  quote =&gt; connection.buy(amount, quote)
} recover {
  case QuoteChangedException() =&gt; 0
}
</code></pre></div></div>

<p><code class="highlighter-rouge">recover</code> コンビネータは元の Future が成功した場合は同一の結果を持つ新たな Future
を作成する。成功しなかった場合は、元の Future を失敗させた <code class="highlighter-rouge">Throwable</code>
に渡された部分関数が適用される。
もしそれが <code class="highlighter-rouge">Throwable</code> を何らかの値に投射すれば、新しい Future はその値とともに成功する。
もしその <code class="highlighter-rouge">Throwable</code> に関して部分関数が定義されていなければ、結果となる
Future は同じ <code class="highlighter-rouge">Throwable</code> とともに失敗する。</p>

<p><code class="highlighter-rouge">recoverWith</code> コンビネータは元の Future が成功した場合は同一の結果を持つ新たな Future
を作成する。成功しなかった場合は、元の Future を失敗させた <code class="highlighter-rouge">Throwable</code>
に渡された部分関数が適用される。
もしそれが <code class="highlighter-rouge">Throwable</code> を何らかの Future に投射すれば、新しい Future はその Future とともに成功する。
<code class="highlighter-rouge">recover</code> に対する関係は <code class="highlighter-rouge">flatMap</code> と <code class="highlighter-rouge">map</code> の関係に似ている。</p>

<p><code class="highlighter-rouge">fallbackTo</code> コンビネータは元の Future が成功した場合は同一の結果を持ち、成功しなかった場合は引数として渡された Future の成功した値を持つ新たな Future を作成する。
この Future と引数の Future が両方失敗した場合は、新しい Future はこの Future の例外とともに失敗する。
以下に米ドルの値を表示することを試みて、米ドルの取得に失敗した場合はスイス・フランの値を表示する具体例をみてみよう:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val usdQuote = Future {
  connection.getCurrentValue(USD)
} map {
  usd =&gt; "値: " + usd + " USD"
}
val chfQuote = Future {
  connection.getCurrentValue(CHF)
} map {
  chf =&gt; "値: " + chf + "CHF"
}

val anyQuote = usdQuote fallbackTo chfQuote

anyQuote onSuccess { println(_) }
</code></pre></div></div>

<p><code class="highlighter-rouge">andThen</code> コンビネータは副作用の目的のためだけに用いられる。
これは、成功したか失敗したかに関わらず現在の Future と全く同一の結果を返す新たな Future を作成する。
現在の Future が完了すると、<code class="highlighter-rouge">andThen</code> に渡されたクロージャが呼び出され、新たな Future
はこの Future と同じ結果とともに完了する。
これは複数の <code class="highlighter-rouge">andThen</code> 呼び出しが順序付けられていることを保証する。
ソーシャルネットワークからの最近の投稿文を可変セットに保存して、全ての投稿文を画面に表示する以下の具体例をみてみよう:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val allposts = mutable.Set[String]()

Future {
  session.getRecentPosts
} andThen {
  case Success(posts) =&gt; allposts ++= posts
} andThen {
  case _ =&gt;
  clearAll()
  for (post &lt;- allposts) render(post)
}
</code></pre></div></div>

<p>まとめると、Future に対する全てのコンビネータは元の Future に関連する新たな Future
を返すため、純粋関数型だといえる。</p>

<h3 id="投射">投射</h3>

<p>例外として返ってきた結果に対して for 内包表記が使えるように Future は投射を持つ。
元の Future が失敗した場合は、<code class="highlighter-rouge">failed</code> 投射は <code class="highlighter-rouge">Throwable</code> 型の値を持つ Future を返す。
もし元の Future が成功した場合は、<code class="highlighter-rouge">failed</code> 投射は <code class="highlighter-rouge">NoSuchElementException</code>
とともに失敗する。以下は例外を画面に表示する具体例だ:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future {
  2 / 0
}
for (exc &lt;- f.failed) println(exc)
</code></pre></div></div>

<p>以下の例は画面に何も表示しない:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future {
  4 / 2
}
for (exc &lt;- f.failed) println(exc)
</code></pre></div></div>

<!--
There is another projection called `timedout` which is specific to the
`FutureTimeoutException`. It works in exactly the same way as the
`failed` projection, but is triggered only for this exception type. In
all other cases, it fails with a `NoSuchElementException`.
-->

<!--
TODO: the `failed` projection can be extended to be parametric in
the throwable types it matches.
-->

<!--
Invoking the `Future` construct uses an implicit execution context to start an asynchronous computation. In the case the client desires to use a custom execution context to start an asynchronous computation:

    val f = Future {
      4 / 2
    }(customExecutionContext)
-->

<h3 id="future-の拡張">Future の拡張</h3>

<p>Future API にユーティリティメソッドを追加して拡張できるようにすることを予定している。
これによって、外部フレームワークはより特化した使い方を提供できるようになる。</p>

<h2 id="ブロッキング">ブロッキング</h2>

<p>前述のとおり、性能とデッドロックの回避という理由から Future をブロックしないことを強く推奨する。
コールバックとコンビネータを使うことが Future の結果を利用するのに適した方法だ。
しかし、状況によってはブロックすることが必要となるため、Future API と Promise API
においてサポートされている。</p>

<p>前にみた為替取引の例だと、アプリケーションの最後に全ての Future
が完了することを保証するためにブロックする必要がある。
Future の結果に対してブロックする方法を以下に具体例で説明しよう:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent._
import scala.concurrent.duration._

def main(args: Array[String]) {
  val rateQuote = Future {
    connection.getCurrentValue(USD)
  }

  val purchase = rateQuote map { quote =&gt;
    if (isProfitable(quote)) connection.buy(amount, quote)
    else throw new Exception("有益ではない")
  }

  Await.result(purchase, 0 nanos)
}
</code></pre></div></div>

<p>Future が失敗した場合は、呼び出し元には Future が失敗した例外が送られてくる。
これは <code class="highlighter-rouge">failed</code> 投射を含むため、元の Future が成功した場合は
<code class="highlighter-rouge">NoSuchElementException</code> が投げられることとなる。</p>

<p>代わりに、<code class="highlighter-rouge">Await.ready</code> を呼ぶことで Future が完了するまで待機するがその結果を取得しないことができる。
同様に、このメソッドを呼んだ時に Future が失敗したとしても例外は投げられない。</p>

<p><code class="highlighter-rouge">Future</code> トレイトは <code class="highlighter-rouge">ready()</code> と <code class="highlighter-rouge">result()</code> というメソッドを持つ <code class="highlighter-rouge">Awaitable</code> トレイトを実装する。
これらのメソッドはクライアントからは直接呼ばれず、実行コンテキストからのみ呼ばれる。</p>

<p><code class="highlighter-rouge">Awaitable</code> トレイトを実装することなくブロックする可能性のある第三者のコードを呼び出すために、以下のように
<code class="highlighter-rouge">blocking</code> 構文を使うことができる:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blocking {
  potentiallyBlockingCall()
}
</code></pre></div></div>

<p>ブロックされたコードは例外を投げるかもしれない。その場合は、呼び出し元に例外が送られる。</p>

<h2 id="例外処理">例外処理</h2>

<p>非同期の計算が処理されない例外を投げた場合、その計算が行われた Future は失敗する。
失敗した Future は計算値のかわりに <code class="highlighter-rouge">Throwable</code> のインスタンスを格納する。
<code class="highlighter-rouge">Future</code> は、<code class="highlighter-rouge">Throwable</code> に適用することができる <code class="highlighter-rouge">PartialFunction</code> を受け取る
<code class="highlighter-rouge">onFailure</code> コールバックメソッドを提供する。
以下の特別な例外に対しては異なる処理が行われる:</p>

<ol>
  <li>
    <p><code class="highlighter-rouge">scala.runtime.NonLocalReturnControl[_]</code>。この例外は戻り値に関連する値を保持する。
典型的にはメソッド本文内の <code class="highlighter-rouge">return</code> 構文はこの例外を用いた <code class="highlighter-rouge">throw</code> へと翻訳される。
この例外を保持するかわりに、関連する値が Future もしくは Promise に保存される。</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ExecutionException</code>。<code class="highlighter-rouge">InterruptedException</code>、<code class="highlighter-rouge">Error</code>、もしくは <code class="highlighter-rouge">scala.util.control.ControlThrowable</code>
が処理されないことで計算が失敗した場合に格納される。
この場合は、処理されなかった例外は <code class="highlighter-rouge">ExecutionException</code> に保持される。
これらの例外は非同期計算を実行するスレッド内で再び投げられる。
この理由は、通常クライアント側で処理されないクリティカルもしくは制御フロー関連の例外が伝搬することを回避し、同時に Future の計算が失敗したことをクライアントに通知するためだ。</p>
  </li>
</ol>

<p>より正確な意味論の説明は <a href="http://www.scala-lang.org/api/current/index.html#scala.util.control.NonFatal$"><code class="highlighter-rouge">NonFatal</code></a> を参照。</p>

<h2 id="promise">Promise</h2>

<p>これまでの所、<code class="highlighter-rouge">future</code> メソッドを用いた非同期計算により作成される <code class="highlighter-rouge">Future</code> オブジェクトのみをみてきた。
しかし、Future は <strong>Promise</strong> を用いて作成することもできる。</p>

<p>Future がリードオンリーのまだ存在しない値に対するプレースホルダ・オブジェクトの一種だと定義されるのに対して、Promise
は書き込み可能で、1度だけ代入できるコンテナで Future を完了させるものだと考えることができる。
つまり、Promise は <code class="highlighter-rouge">success</code> メソッドを用いて (約束を「完了させる」ことで) Future を値とともに成功させることができる。
逆に、Promise  は <code class="highlighter-rouge">failure</code> メソッドを用いて Future を例外とともに失敗させることもできる。</p>

<p>Promise の <code class="highlighter-rouge">p</code> は <code class="highlighter-rouge">p.future</code> によって返される Future を完了させる。
この Future は Promise <code class="highlighter-rouge">p</code> に特定のものだ。実装によっては <code class="highlighter-rouge">p.future eq p</code> の場合もある。</p>

<p>ある計算が値を生産し、別の計算がそれを消費する Producer-Consumer の具体例を使って説明しよう。
この値の受け渡しは Promise を使って実現している。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent.{ Future, Promise }
import scala.concurrent.ExecutionContext.Implicits.global

val p = Promise[T]()
val f = p.future

val producer = Future {
  val r = produceSomething()
  p success r
  continueDoingSomethingUnrelated()
}

val consumer = Future {
  startDoingSomething()
  f onSuccess {
    case r =&gt; doSomethingWithResult()
  }
}
</code></pre></div></div>

<p>ここでは、まず Promise を作って、その <code class="highlighter-rouge">future</code> メソッドを用いて完了される <code class="highlighter-rouge">Future</code>
を取得する。
まず何らかの計算が実行され、<code class="highlighter-rouge">r</code> という結果となり、これを用いて Future <code class="highlighter-rouge">f</code> を完了させ、<code class="highlighter-rouge">p</code> という約束を果たす。
ここで注意してほしいのは、<code class="highlighter-rouge">consumer</code> は <code class="highlighter-rouge">producer</code> が <code class="highlighter-rouge">continueDoingSomethingUnrelated()</code> を実行し終えてタスクが完了する前に結果を取得できることだ。</p>

<p>前述の通り、Promise は 1度だけ代入できるという意味論を持つ。
そのため、完了させるのも 1回だけだ。
既に完了 (もしくは失敗した) Promise に対して <code class="highlighter-rouge">success</code> を呼び出すと
<code class="highlighter-rouge">IllegalStateException</code> が投げられる。</p>

<p>以下は Promise を失敗させる具体例だ。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val p = Promise[T]()
val f = p.future

val producer = Future {
  val r = someComputation
  if (isInvalid(r))
    p failure (new IllegalStateException)
  else {
    val q = doSomeMoreComputation(r)
    p success q
  }
}
</code></pre></div></div>

<p>ここでは <code class="highlighter-rouge">producer</code> は中間結果 <code class="highlighter-rouge">r</code> を計算して、それが妥当であるか検証する。
不正であれば、Promise <code class="highlighter-rouge">p</code> を例外を用いて完了させることで Promise を失敗させる。
それ以外の場合は、<code class="highlighter-rouge">producer</code> は計算を続行して Promise <code class="highlighter-rouge">p</code> を妥当な結果用いて完了させることで、Future
<code class="highlighter-rouge">f</code> を完了させる。</p>

<p>Promise は潜在的な値である <code class="highlighter-rouge">Try[T]</code> (失敗した結果の <code class="highlighter-rouge">Failure[Throwable]</code>
もしくは成功した結果の <code class="highlighter-rouge">Success[T]</code>)
を受け取る <code class="highlighter-rouge">complete</code> メソッドを使って完了させることもできる。</p>

<p><code class="highlighter-rouge">success</code> 同様に、既に完了した Promise に対して <code class="highlighter-rouge">failure</code> や <code class="highlighter-rouge">complete</code> を呼び出すと
<code class="highlighter-rouge">IllegalStateException</code> が投げられる。</p>

<p>これまでに説明した Promise の演算とモナディックで副作用を持たない演算を用いて合成した Future
を使って書いたプログラムの便利な特性としてそれらが決定的 (deterministic) であることが挙げられる。
ここで決定的とは、プログラムで例外が投げられなければ、並列プログラムの実行スケジュールのいかんに関わらずプログラムの結果
(Future から観測される値) は常に同じものとなるという意味だ。</p>

<p>場合によってはクライアントは Promise が既に完了していないときにのみ完了させたいこともある
(例えば、複数の HTTP がそれぞれ別の Future から実行されていて、クライアントは最初の戻ってきた
HTTP レスポンスにのみ興味がある場合で、これは最初に Promise を完了させる Future に対応する)。
これらの理由のため、Promise には <code class="highlighter-rouge">tryComplete</code>、<code class="highlighter-rouge">trySuccess</code>、および <code class="highlighter-rouge">tryFailure</code> というメソッドがある。
クライアントはこれらのメソッドを使った場合はプログラムの結果は決定的でなくなり実行スケジュールに依存することに注意するべきだ。</p>

<p><code class="highlighter-rouge">completeWith</code> メソッドは別の Future を用いて Promise を完了させる。
渡された Future が完了すると、その Promise も Future の値とともに完了する。
以下のプログラムは <code class="highlighter-rouge">1</code> と表示する:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future { 1 }
val p = Promise[Int]()

p completeWith f

p.future onSuccess {
  case x =&gt; println(x)
}
</code></pre></div></div>

<p>Promise を例外とともに失敗させる場合は、<code class="highlighter-rouge">Throwable</code> の 3つのサブタイプが特殊扱いされる。
Promise を失敗させた <code class="highlighter-rouge">Throwable</code> が <code class="highlighter-rouge">scala.runtime.NonLocalReturnControl</code>
の場合は、Promise は関連する値によって完了させる。
Promise を失敗させた <code class="highlighter-rouge">Throwable</code> が <code class="highlighter-rouge">Error</code>、<code class="highlighter-rouge">InterruptedException</code>、もしくは
<code class="highlighter-rouge">scala.util.control.ControlThrowable</code> の場合は、<code class="highlighter-rouge">Throwable</code>
は新たな <code class="highlighter-rouge">ExecutionException</code> の理由としてラッピングされ Promise が失敗させられる。</p>

<p>Promise、Future の <code class="highlighter-rouge">onComplete</code> メソッド、そして <code class="highlighter-rouge">future</code>
構文を使うことで前述の関数型合成に用いられるコンビネータの全てを実装することができる。
例えば、2つの Future <code class="highlighter-rouge">f</code> と <code class="highlighter-rouge">g</code> を受け取って、(最初に成功した) <code class="highlighter-rouge">f</code> か <code class="highlighter-rouge">g</code>
のどちらかを返す <code class="highlighter-rouge">first</code> という新しいコンビネータを実装したいとする。
以下のように書くことができる:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def first[T](f: Future[T], g: Future[T]): Future[T] = {
  val p = Promise[T]()

  f onSuccess {
    case x =&gt; p.tryComplete(x)
  }

  g onSuccess {
    case x =&gt; p.tryComplete(x)
  }

  p.future
}
</code></pre></div></div>

<!--
## Migration p

scala.actor.Futures?
for clients


## Implementing custom futures and promises p
for library writers
-->

<h2 id="ユーティリティ">ユーティリティ</h2>

<p>並列アプリケーション内における時間の扱いを単純化するために　<code class="highlighter-rouge">scala.concurrent</code>
は <code class="highlighter-rouge">Duration</code> という抽象体を導入する。
<code class="highlighter-rouge">Duration</code> は既に他にもある一般的な時間の抽象化を目的としていない。
並列ライブラリとともに使うことを目的とするため、<code class="highlighter-rouge">scala.concurrent</code> パッケージ内に置かれている。</p>

<p><code class="highlighter-rouge">Duration</code> は時の長さを表す基底クラスで、それは有限でも無限でもありうる。
有限の時間は <code class="highlighter-rouge">FiniteDuration</code> クラスによって表され <code class="highlighter-rouge">Long</code> の長さと <code class="highlighter-rouge">java.util.concurrent.TimeUnit</code>
によって構成される。
無限時間も <code class="highlighter-rouge">Duration</code> を継承し、これは <code class="highlighter-rouge">Duration.Inf</code> と <code class="highlighter-rouge">Duration.MinusInf</code> という 2つのインスタンスのみが存在する。
このライブラリは暗黙の変換のためのいくつかの <code class="highlighter-rouge">Duration</code> のサブクラスを提供するが、これらは使用されるべきではない。</p>

<p>抽象クラスの <code class="highlighter-rouge">Duration</code> は以下のメソッドを定義する:</p>

<ol>
  <li>時間の単位の変換 (<code class="highlighter-rouge">toNanos</code>、<code class="highlighter-rouge">toMicros</code>、<code class="highlighter-rouge">toMillis</code>、
<code class="highlighter-rouge">toSeconds</code>、<code class="highlighter-rouge">toMinutes</code>、<code class="highlighter-rouge">toHours</code>、<code class="highlighter-rouge">toDays</code>、及び <code class="highlighter-rouge">toUnit(unit: TimeUnit)</code>)。</li>
  <li>時間の比較 (<code class="highlighter-rouge">&lt;</code>、<code class="highlighter-rouge">&lt;=</code>、<code class="highlighter-rouge">&gt;</code>、および <code class="highlighter-rouge">&gt;=</code>)。</li>
  <li>算術演算 (<code class="highlighter-rouge">+</code>、<code class="highlighter-rouge">-</code>、<code class="highlighter-rouge">*</code>、<code class="highlighter-rouge">/</code>、および <code class="highlighter-rouge">unary_-</code>)。</li>
  <li>この時間 <code class="highlighter-rouge">this</code> と引数として渡された時間の間の最小値と最大値 (<code class="highlighter-rouge">min</code>、<code class="highlighter-rouge">max</code>)。</li>
  <li>時間が有限かの検査 (<code class="highlighter-rouge">isFinite</code>)。</li>
</ol>

<p><code class="highlighter-rouge">Duration</code> は以下の方法で作成することができる:</p>

<ol>
  <li><code class="highlighter-rouge">Int</code> もしくは <code class="highlighter-rouge">Long</code> 型からの暗黙の変換する。例: <code class="highlighter-rouge">val d = 100 millis</code>。</li>
  <li><code class="highlighter-rouge">Long</code> の長さと <code class="highlighter-rouge">java.util.concurrent.TimeUnit</code> を渡す。例: <code class="highlighter-rouge">val d = Duration(100, MILLISECONDS)</code>。</li>
  <li>時間の長さを表す文字列をパースする。例: <code class="highlighter-rouge">val d = Duration("1.2 µs")</code>。</li>
</ol>

<p><code class="highlighter-rouge">Duration</code> は <code class="highlighter-rouge">unapply</code> メソッドも提供するため、パータンマッチング構文の中から使うこともできる。以下に具体例をみる:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent.duration._
import java.util.concurrent.TimeUnit._

// 作成
val d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit
val d2 = Duration(100, "millis") // from Long and String
val d3 = 100 millis // implicitly from Long, Int or Double
val d4 = Duration("1.2 µs") // from String

// パターンマッチング
val Duration(length, unit) = 5 millis
</code></pre></div></div>

				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">
      <div id="toc"></div>
      
         
         
        <ul id="available-languages" style="display: none;">
          <li><a href="/docs.scala-lang.org/overviews/core/futures.html">English</a></li>
          
            
            <li><a href="/docs.scala-lang.org/ja/overviews/core/futures.html" class="lang">日本語</a></li>
          
            
            <li><a href="/docs.scala-lang.org/zh-cn/overviews/core/futures.html" class="lang">中文 (简体)</a></li>
          
        </ul>
      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_ja/overviews/core/futures.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/docs.scala-lang.org/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/docs.scala-lang.org/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/docs.scala-lang.org/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/docs.scala-lang.org/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/docs.scala-lang.org/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/docs.scala-lang.org/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/docs.scala-lang.org/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/docs.scala-lang.org/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/docs.scala-lang.org/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/docs.scala-lang.org/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/docs.scala-lang.org/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/docs.scala-lang.org/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/docs.scala-lang.org/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

