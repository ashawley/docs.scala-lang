<!DOCTYPE html>
<html>
  <head>
    <title>Expression details | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
    <link rel="manifest" href="/resources/site.webmanifest">
    <link rel="mask-icon" href="/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/" class="navigation-bdand">
        <img src="/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/books.html">Books</a>
              </li>
            
              <li>
                <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">Quasiquotes</div>
          
          <h1>Expression details</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p><strong>Denys Shabalin</strong> <span class="tag" style="float: right;">EXPERIMENTAL</span></p>

<h2 id="empty">Empty</h2>

<p><code class="highlighter-rouge">q""</code> is used to indicate that some part of the tree is not provided by the user:</p>

<ol>
  <li><code class="highlighter-rouge">Val</code>s, <code class="highlighter-rouge">Var</code>s and <code class="highlighter-rouge">Def</code>s without the right-hand side have it set to <code class="highlighter-rouge">q""</code>.</li>
  <li>Abstract type definitions without bounds have them set to <code class="highlighter-rouge">q""</code>.</li>
  <li><code class="highlighter-rouge">Try</code> expressions without a finally clause have it set to <code class="highlighter-rouge">q""</code>.</li>
  <li><code class="highlighter-rouge">Case</code> clauses without guards have them set to <code class="highlighter-rouge">q""</code>.</li>
</ol>

<p>The default <code class="highlighter-rouge">toString</code> formats <code class="highlighter-rouge">q""</code> as <code class="highlighter-rouge">&lt;empty&gt;</code>.</p>

<h2 id="literal">Literal</h2>

<p>Scala has a number of default built-in literals:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q"1", q"1L"              // integer literals
q"1.0f", q"1.0", q"1.0d" // floating point literals
q"true", q"false"        // boolean literals
q"'c'"                   // character literal
q""" "string" """        // string literal
q"'symbol"               // symbol literal
q"null"                  // null literal
q"()"                    // unit literal
</code></pre></div></div>

<p>All of those values are of type <code class="highlighter-rouge">Literal</code> except symbols, which have a different representation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val foo = q"'foo"
foo: universe.Tree = scala.Symbol("foo")
</code></pre></div></div>

<p>Thanks to <a href="/overviews/quasiquotes/lifting.html">lifting</a>, you can also easily create literal trees directly from values of corresponding types:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val x = 1
scala&gt; val one = q"$x"
one: universe.Tree = 1
</code></pre></div></div>

<p>This would work the same way for all literal types (see <a href="/overviews/quasiquotes/lifting.html#standard-liftables">standard liftables</a> except <code class="highlighter-rouge">Null</code>. Lifting of the <code class="highlighter-rouge">null</code> value into the <code class="highlighter-rouge">Null</code> type isn’t supported; use <code class="highlighter-rouge">q"null"</code> if you really want to create a <code class="highlighter-rouge">null</code> literal:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val x = null
scala&gt; q"$x"
&lt;console&gt;:31: error: Can't unquote Null, bottom type values often indicate programmer mistake
              q"$x"
                 ^
</code></pre></div></div>

<p>During deconstruction you can use <a href="/overviews/quasiquotes/unlifting.html">unlifting</a> to extract values out of <code class="highlighter-rouge">Literal</code> trees:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"${x: Int}" = q"1"
x: Int = 1
</code></pre></div></div>

<p>Similarly it would work with all the literal types except <code class="highlighter-rouge">Null</code>. (see <a href="/overviews/quasiquotes/unlifting.html#standard-unliftables">standard unliftables</a>)</p>

<h2 id="identifier-and-selection">Identifier and Selection</h2>

<p>Identifiers and member selections are two fundamental primitives that let you refer to other definitions. A combination of two of them is also known as a <code class="highlighter-rouge">RefTree</code>.</p>

<p>Each term identifier is defined by its name and whether or not it is backquoted:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val name = TermName("Foo")
name: universe.TermName = Foo

scala&gt; val foo = q"$name"
foo: universe.Ident = Foo

scala&gt; val backquoted = q"`$name`"
backquoted: universe.Ident = `Foo`
</code></pre></div></div>

<p>Although backquoted and non-backquoted identifiers may refer to the same thing they are not syntactically equivalent:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"`Foo`" = q"Foo"
scala.MatchError: Foo (of class scala.reflect.internal.Trees$Ident)
  ... 32 elided
</code></pre></div></div>

<p>This is because backquoted identifiers have different semantics in pattern patching.</p>

<p>Apart from matching on identifiers with a given name, you can also extract their name values with the help of <a href="/overviews/quasiquotes/unlifting.html">unlifting</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"${name: TermName}" = q"Foo"
name: universe.TermName = Foo
</code></pre></div></div>

<p>Name ascription is important here because without it you’ll get a pattern that is equivalent to regular pattern variable binding.</p>

<p>Similarly you can create and extract member selections:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val member = TermName("bar")
member: universe.TermName = bar

scala&gt; val q"foo.$name" = selected
name: universe.TermName = bar
</code></pre></div></div>

<h2 id="super-and-this">Super and This</h2>

<p>One can use <code class="highlighter-rouge">this</code> and <code class="highlighter-rouge">super</code> to select precise members within an inheritance chain.</p>

<p>This tree supports following variations:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"$name.this" = q"this"
name: universe.TypeName =

scala&gt; val q"$name.this" = q"foo.this"
name: universe.TypeName = foo
</code></pre></div></div>

<p>So an unqualified <code class="highlighter-rouge">q"this"</code> is equivalent to <code class="highlighter-rouge">q"${tpnme.EMPTY}.this"</code>.</p>

<p>Similarly for <code class="highlighter-rouge">super</code> we have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"$name.super[$qual].$field" = q"super.foo"
name: universe.TypeName =
qual: universe.TypeName =
field: universe.Name = foo

scala&gt; val q"$name.super[$qual].$field" = q"super[T].foo"
name: universe.TypeName =
qual: universe.TypeName = T
field: universe.Name = foo

scala&gt; val q"$name.super[$qual].$field" = q"other.super[T].foo"
name: universe.TypeName = other
qual: universe.TypeName = T
field: universe.Name = foo
</code></pre></div></div>

<h2 id="application-and-type-application">Application and Type Application</h2>

<p>Value applications and type applications are two fundamental parts from which one can construct calls to Scala functions and methods. Let’s assume that we would like to handle function calls to the following method:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def f[T](xs: T*): List[T] = xs.toList
</code></pre></div></div>

<p>This can be accomplished with the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val apps = List(q"f[Int](1, 2)", q"f('a, 'b)")
scala&gt; apps.foreach {
         case q"f[..$ts](..$args)" =&gt;
           println(s"type arguments: $ts, value arguments: $args")
       }
type arguments: List(Int), value arguments: List(1, 2)
type arguments: List(), value arguments: List(scala.Symbol("a"), scala.Symbol("b"))
</code></pre></div></div>

<p>As you can see, we were able to match both calls regardless as to whether or not a specific type application exists. This happens because the type application matcher extracts the empty list of type arguments if the tree is not an actual type application, making it possible to handle both situations uniformly.</p>

<p>It is recommended to always include type applications when you match on a function with type arguments, as they will be inserted by the compiler during type checking, even if the user didn’t write them explicitly:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"$_; f[..$ts](..$args)" = toolbox.typecheck(q"""
         def f[T](xs: T*): List[T] = xs.toList
         f(1, 2, 3)
       """)
ts: List[universe.Tree] = List(Int)
args: List[universe.Tree] = List(1, 2, 3)
</code></pre></div></div>

<p>Other important features of Scala method calls are multiple argument lists and implicit arguments:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def g(x: Int)(implicit y: Int) = x + y
</code></pre></div></div>

<p>Here we might get one, or two subsequent value applications:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val apps = List(q"g(1)", q"g(1)(2)")
scala&gt; apps.foreach {
         case q"g(...$argss)" if argss.nonEmpty =&gt;
           println(s"argss: $argss")
       }
argss: List(List(1))
argss: List(List(1), List(2))
</code></pre></div></div>

<p><code class="highlighter-rouge">...$</code>, in a pattern, allows us to greedily match all subsequent value applications. Similarly to the type arguments matcher, one needs to be careful because it always matches even in the case where no actual value applications exist:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"g(...$argss)" = q"g"
argss: List[List[universe.Tree]] = List()
</code></pre></div></div>

<p>Therefore it’s recommended to use more specific patterns that check that ensure the extracted <code class="highlighter-rouge">argss</code> is not empty.</p>

<p>Similarly to type arguments, implicit value arguments are automatically inferred during type checking:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"..$stats; g(...$argss)" = toolbox.typecheck(q"""
         def g(x: Int)(implicit y: Int) = x + y
         implicit val y = 3
         g(2)
       """)
stats: List[universe.Tree] = List(def g(x: Int)(implicit y: Int): Int = x.+(y), implicit val y: Int = 3)
argss: List[List[universe.Tree]] = List(List(2), List(y))
</code></pre></div></div>

<h2 id="assign-and-update">Assign and Update</h2>

<p>Assign and update are two related ways to explicitly mutate a variable or collection:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val assign = q"x = 2"
assign: universe.Tree = x = 2

scala&gt; val update = q"array(0) = 1"
update: universe.Tree = array.update(0, 1)
</code></pre></div></div>

<p>As you can see, the update syntax is just syntactic sugar that gets represented as an update method call on given object.</p>

<p>Nevertheless, quasiquotes let you deconstruct both of them uniformly according to their user-facing syntax:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; List(assign, update).foreach {
         case q"$left = $right" =&gt;
           println(s"left = $left, right = $right")
       }
left = x, right = 2
left = array(0), right = 1
</code></pre></div></div>

<p>Where <code class="highlighter-rouge">array(0)</code> has the same AST as function application.</p>

<p>On the other hand if you want to treat this two cases separately, it’s possible with the following, more specific pattern:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; List(assign, update).foreach {
         case q"${ref: RefTree} = $expr" =&gt;
           println(s"assign $expr to $ref")
         case q"$obj(..$args) = $expr" =&gt;
           println(s"update $obj at $args with $expr")
       }
assign 2 to x
update array at List(0) with 1
</code></pre></div></div>

<h2 id="return">Return</h2>

<p>The <em>return</em> expression is used to perform an early return from a function.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val ret = q"return 2 + 2"
ret: universe.Return = return 2.$plus(2)

scala&gt; val q"return $expr" = ret
expr: universe.Tree = 2.$plus(2)
</code></pre></div></div>

<h2 id="throw">Throw</h2>

<p>The <em>throw</em> expression is used to throw a throwable:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val thr = q"throw new Exception"
thr: universe.Throw = throw new Exception()

scala&gt; val q"throw $expr" = thr
expr: universe.Tree = new Exception()
</code></pre></div></div>

<h2 id="ascription">Ascription</h2>

<p>Ascriptions let users annotate the type of an intermediate expression:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val ascribed = q"(1 + 1): Int"
ascribed: universe.Typed = (1.$plus(1): Int)

scala&gt; val q"$expr: $tpt" = ascribed
expr: universe.Tree = 1.$plus(1)
tpt: universe.Tree = Int
</code></pre></div></div>

<h2 id="annotation">Annotation</h2>

<p>Expressions can be annotated:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val annotated = q"(1 + 1): @positive"
annotated: universe.Annotated = 1.$plus(1): @positive

scala&gt; val q"$expr: @$annot" = annotated
expr: universe.Tree = 1.$plus(1)
annot: universe.Tree = positive
</code></pre></div></div>

<p>It’s important to mention that such a pattern won’t match if we combine annotation with ascription:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"$expr: @$annot" = q"(1 + 1): Int @positive"
scala.MatchError: (1.$plus(1): Int @positive) (of class scala.reflect.internal.Trees$Typed)
  ... 32 elided
</code></pre></div></div>

<p>In this case we need to deconstruct it as an <a href="#ascription">ascription</a> and then deconstruct <code class="highlighter-rouge">tpt</code> as an <a href="/overviews/quasiquotes/type-details.html#annotated-type">annotated type</a>.</p>

<h2 id="tuple">Tuple</h2>

<p>Tuples are heteregeneous data structures with built-in user-friendly syntax. The syntax itself is just syntactic sugar that maps onto <code class="highlighter-rouge">scala.TupleN</code> calls:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val tup = q"(a, b)"
tup: universe.Tree = scala.Tuple2(a, b)
</code></pre></div></div>

<p>At the moment, tuples are only supported up to an arity of 22, but this is just an implementation restriction that might be lifted in the future. To find out if a given arity is supported use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val `tuple 10 supported?` = definitions.TupleClass(10) != NoSymbol
tuple 10 supported?: Boolean = true

scala&gt; val `tuple 23 supported?` = definitions.TupleClass(23) != NoSymbol
tuple 23 supported?: Boolean = false
</code></pre></div></div>

<p>Despited the fact that <code class="highlighter-rouge">Tuple1</code> class exists there is no built-in syntax for it. Single parens around expression do not change its meaning:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val inparens = q"(a)"
inparens: universe.Ident = a
</code></pre></div></div>

<p>It is also common to treat <code class="highlighter-rouge">Unit</code> as a nullary tuple:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val elems = List.empty[Tree]
scala&gt; val nullary = q"(..$elems)"
nullary: universe.Tree = ()
</code></pre></div></div>

<p>Quasiquotes also support deconstruction of tuples of arbitrary arity:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"(..$elems)" = q"(a, b)"
elems: List[universe.Tree] = List(a, b)
</code></pre></div></div>

<p>This pattern also matches expressions as single-element tuples:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"(..$elems)" = q"(a)"
elems: List[universe.Tree] = List(a)
</code></pre></div></div>

<p>And <code class="highlighter-rouge">Unit</code> as a nullary tuple:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"(..$elems)" = q"()"
elems: List[universe.Tree] = List()
</code></pre></div></div>

<h2 id="block">Block</h2>

<p>Blocks are a fundamental primitive used to express a sequence of actions or bindings. The <code class="highlighter-rouge">q"..."</code> interpolator is an equivalent of a block. It allows you to convey more than one expression, separated by a semicolon or a newline:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val t = q"a; b; c"
t: universe.Tree =
{
  a;
  b;
  c
}
</code></pre></div></div>

<p>The only difference between <code class="highlighter-rouge">q"{...}"</code> and <code class="highlighter-rouge">q"..."</code> is how they handle the of case just a single element.  <code class="highlighter-rouge">q"..."</code> always returns an element itself while a block still remains a block if a single element is not an expression:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val t = q"val x = 2"
t: universe.ValDef = val x = 2

scala&gt; val t = q"{ val x = 2 }"
t: universe.Tree =
{
  val x = 2;
  ()
}
</code></pre></div></div>

<p>Blocks can also be flattened into other blocks with <code class="highlighter-rouge">..$</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val ab = q"a; b"
ab: universe.Tree =
{
  a;
  b
}

scala&gt; val abc = q"..$ab; c"
abc: universe.Tree =
{
  a;
  b;
  c
}
</code></pre></div></div>

<p>The same syntax can be used to deconstruct blocks:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"..$stats" = q"a; b; c"
stats: List[universe.Tree] = List(a, b, c)
</code></pre></div></div>

<p>Deconstruction always returns the user-defined contents of a block:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"..$stats" = q"{ val x = 2 }"
stats: List[universe.Tree] = List(val x = 2)
</code></pre></div></div>

<p>Due to automatic flattening of single-element blocks with expressions, expressions themselves are considered to be single-element blocks:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"..$stats" = q"foo"
stats: List[universe.Tree] = List(foo)
</code></pre></div></div>

<p>Except for empty tree which is not considered to be a block:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"..$stats" = q""
scala.MatchError: &lt;empty&gt; (of class scala.reflect.internal.Trees$EmptyTree$)
  ... 32 elided
</code></pre></div></div>

<p>A zero-element block is equivalent to a synthetic unit (one that was inserted by the compiler rather than written by the user):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"..$stats" = q"{}"
stats: List[universe.Tree] = List()

scala&gt; val syntheticUnit = q"..$stats"
syntheticUnit: universe.Tree = ()
</code></pre></div></div>

<p>Such units are used in empty <code class="highlighter-rouge">else</code> branches of <a href="#if">ifs</a> and empty bodies of <a href="#pattern-match">case clauses</a>, making it as convenient to work with those cases as with zero-element blocks.</p>

<h2 id="if">If</h2>

<p>There are two varieties of if expressions: those with an <code class="highlighter-rouge">else</code> clause and without it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"if ($cond) $thenp else $elsep" = q"if (true) a else b"
cond: universe.Tree = true
thenp: universe.Tree = a
elsep: universe.Tree = b

scala&gt; val q"if ($cond) $thenp else $elsep" = q"if (true) a"
cond: universe.Tree = true
thenp: universe.Tree = a
elsep: universe.Tree = ()
</code></pre></div></div>

<p>A missing <code class="highlighter-rouge">else</code> clause is equivalent to an <code class="highlighter-rouge">else</code> clause that contains a synthetic unit literal (<a href="#block">empty block</a>).</p>

<h2 id="pattern-match">Pattern Match</h2>

<p>Pattern matching is a cornerstone feature of Scala that lets you deconstruct values into their components:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q"$expr match { case ..$cases } "
</code></pre></div></div>

<p>Where <code class="highlighter-rouge">expr</code> is some non-empty expression and each case is represented with a <code class="highlighter-rouge">cq"..."</code> quote:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cq"$pat if $expr =&gt; $expr"
</code></pre></div></div>

<p>A combination of the two forms allows you to construct and deconstruct arbitrary pattern matches:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"$expr match { case ..$cases }" =
           q"foo match { case _: Foo =&gt; 'foo case _ =&gt; 'notfoo }"
expr: universe.Tree = foo
cases: List[universe.CaseDef] = List(case (_: Foo) =&gt; scala.Symbol("foo"), case _ =&gt; scala.Symbol("notfoo"))

scala&gt; val cq"$pat1 =&gt; $body1" :: cq"$pat2 =&gt; $body2" :: Nil = cases
pat1: universe.Tree = (_: Foo)
body1: universe.Tree = scala.Symbol("foo")
pat2: universe.Tree = _
body2: universe.Tree = scala.Symbol("notfoo")
</code></pre></div></div>

<p>A case clause without a body is equivalent to one holding a synthetic unit literal (<a href="#block">empty block</a>):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val cq"$pat if $expr1 =&gt; $expr2" = cq"_ =&gt;"
pat: universe.Tree = _
expr1: universe.Tree = &lt;empty&gt;
expr2: universe.Tree = ()
</code></pre></div></div>

<p>The lack of a guard is represented with the help of an <a href="#empty">empty expression</a>.</p>

<h2 id="try">Try</h2>

<p>A <code class="highlighter-rouge">try</code> expression is used to handle possible error conditions and to ensure a consistent state via <code class="highlighter-rouge">finally</code>. Both error handling cases and the <code class="highlighter-rouge">finally</code> clause are optional.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"try $a catch { case ..$b } finally $c" = q"try t"
a: universe.Tree = t
b: List[universe.CaseDef] = List()
c: universe.Tree = &lt;empty&gt;

scala&gt; val q"try $a catch { case ..$b } finally $c" =
           q"try t catch { case _: C =&gt; }"
a: universe.Tree = t
b: List[universe.CaseDef] = List(case (_: C) =&gt; ())
c: universe.Tree = &lt;empty&gt;

scala&gt; val q"try $a catch { case ..$b } finally $c" =
           q"try t finally f"
a: universe.Tree = t
b: List[universe.CaseDef] = List()
c: universe.Tree = f
</code></pre></div></div>

<p>Similar to <a href="#pattern-match">pattern matching</a>, cases can be further deconstructed with <code class="highlighter-rouge">cq"..."</code>. The lack of a <code class="highlighter-rouge">finally</code> clause is represented with the help of an <a href="#empty">empty expression</a>.</p>

<h2 id="function">Function</h2>

<p>There are three ways to create anonymous function:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val f1 = q"_ + 1"
anon1: universe.Function = ((x$4) =&gt; x$4.$plus(1))

scala&gt; val f2 = q"(a =&gt; a + 1)"
anon2: universe.Function = ((a) =&gt; a.$plus(1))

scala&gt; val f3 = q"(a: Int) =&gt; a + 1"
anon3: universe.Function = ((a: Int) =&gt; a.$plus(1))
</code></pre></div></div>

<p>The first one uses the placeholder syntax. The second one names the function parameter but still relies on type inference to infer its type. An the last one explicitly defines the function parameter. Due to an implementation restriction, the second notation can only be used in parentheses or inside another expression. If you leave them out the you must specify the parameter types.</p>

<p>Parameters are represented as <a href="/overviews/quasiquotes/definition-details.html#val-and-var-definitions">Vals</a>. If you want to programmatically create a <code class="highlighter-rouge">val</code> that should have its type inferred you need to use the <a href="/overviews/quasiquotes/type-details.html#empty-type">empty type</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val tpt = tq""
tpt: universe.TypeTree = &lt;type ?&gt;

scala&gt; val param = q"val x: $tpt"
param: universe.ValDef = val x

scala&gt; val fun = q"($param =&gt; x)"
fun: universe.Function = ((x) =&gt; x)
</code></pre></div></div>

<p>All of the given forms are represented in the same way and may be matched uniformly:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; List(f1, f2, f3).foreach {
         case q"(..$params) =&gt; $body" =&gt;
           println(s"params = $params, body = $body")
       }
params = List(&lt;synthetic&gt; val x$5 = _), body = x$5.$plus(1)
params = List(val a = _), body = a.$plus(1)
params = List(val a: Int = _), body = a.$plus(1)
</code></pre></div></div>

<p>You can also tear arguments apart even further:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"(..$params) =&gt; $_" = f3
params: List[universe.ValDef] = List(val a: Int = _)

scala&gt; val List(q"$_ val $name: $tpt") = params
name: universe.TermName = a
tpt: universe.Tree = Int
</code></pre></div></div>

<p>It is recommended that you use the underscore pattern in place of <a href="/overviews/quasiquotes/definition-details.html#modifiers">modifiers</a>, even if you don’t plan to work with them as parameters, they may contain additional flags which might cause match failures.</p>

<h2 id="partial-function">Partial Function</h2>

<p>Partial functions are a neat syntax that let you express functions with a limited domain by using pattern matching:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val pf = q"{ case i: Int if i &gt; 0 =&gt; i * i }"
pf: universe.Match =
&lt;empty&gt; match {
  case (i @ (_: Int)) if i.$greater(0) =&gt; i.$times(i)
}

scala&gt; val q"{ case ..$cases }" = pf
cases: List[universe.CaseDef] = List(case (i @ (_: Int)) if i.$greater(0) =&gt; i.$times(i))
</code></pre></div></div>

<p>A weird default for the “pretty printed” view on the tree represents the fact that they share a similar data structure as do trees for match expressions. Despite this fact, they do not match one another:</p>

<p>scala&gt; val q”$expr match { case ..$cases }” = pf
  scala.MatchError: …</p>

<h2 id="while-and-do-while-loops">While and Do-While Loops</h2>

<p>While and do-while loops are low-level control structures that can be used when performance of a particular iteration is critical:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val `while` = q"while(x &gt; 0) x -= 1"
while: universe.LabelDef =
while$6(){
  if (x.$greater(0))
    {
      x.$minus$eq(1);
      while$6()
    }
  else
    ()
}

scala&gt; val q"while($cond) $body" = `while`
cond: universe.Tree = x.$greater(0)
body: universe.Tree = x.$minus$eq(1)

scala&gt; val `do-while` = q"do x -= 1 while (x &gt; 0)"
do-while: universe.LabelDef =
doWhile$2(){
  x.$minus$eq(1);
  if (x.$greater(0))
    doWhile$2()
  else
    ()
}

scala&gt; val q"do $body while($cond)" = `do-while`
body: universe.Tree = x.$minus$eq(1)
cond: universe.Tree = x.$greater(0)
</code></pre></div></div>

<h2 id="for-and-for-yield-loops">For and For-Yield Loops</h2>

<p><code class="highlighter-rouge">for</code> and <code class="highlighter-rouge">for-yield</code> expressions allow us to write a monadic style comprehension that desugar into calls to <code class="highlighter-rouge">map</code>, <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">foreach</code> and <code class="highlighter-rouge">withFilter</code> methods:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val `for-yield` = q"for (x &lt;- xs; if x &gt; 0; y = x * 2) yield x"
for-yield: universe.Tree =
xs.withFilter(((x) =&gt; x.$greater(0))).map(((x) =&gt; {
  val y = x.$times(2);
  scala.Tuple2(x, y)
})).map(((x$3) =&gt; x$3: @scala.unchecked match {
  case scala.Tuple2((x @ _), (y @ _)) =&gt; x
}))
</code></pre></div></div>

<p>Each enumerator in the comprehension can be expressed with the <code class="highlighter-rouge">fq"..."</code> interpolator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val enums = List(fq"x &lt;- xs", fq"if x &gt; 0", fq"y = x * 2")
enums: List[universe.Tree] = List(`&lt;-`((x @ _), xs), `if`(x.$greater(0)), (y @ _) = x.$times(2))

scala&gt; val `for-yield` = q"for (..$enums) yield y"
for-yield: universe.Tree
</code></pre></div></div>

<p>Similarly one can deconstruct the <code class="highlighter-rouge">for-yield</code> back into a list of enumerators and body:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"for (..$enums) yield $body" = `for-yield`
enums: List[universe.Tree] = List(`&lt;-`((x @ _), xs), `if`(x.$greater(0)), (y @ _) = x.$times(2))
body: universe.Tree = x
</code></pre></div></div>

<p>It’s important to mention that <code class="highlighter-rouge">for</code> and <code class="highlighter-rouge">for-yield</code> do not cross-match each other:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"for (..$enums) $body" = `for-yield`
scala.MatchError: ...
</code></pre></div></div>

<h2 id="new">New</h2>

<p>New expressions let you construct an instance of given type, possibly refining it with other types or definitions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"new ..$parents { ..$body }" = q"new Foo(1) with Bar { def baz = 2 }"
parents: List[universe.Tree] = List(Foo(1), Bar)
body: List[universe.Tree] = List(def baz = 2)
</code></pre></div></div>

<p>See the <a href="/overviews/quasiquotes/definition-details.html#templates">templates</a> section for details.</p>

<h2 id="import">Import</h2>

<p>Import trees consist of a reference and a list of selectors:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val q"import $ref.{..$sels}" = q"import foo.{bar, baz =&gt; boo, poison =&gt; _, _}"
ref: universe.Tree = foo
sels: List[universe.Tree] = List((bar @ _), $minus$greater((baz @ _), (boo @ _)), $minus$greater((poison @ _), _), _)
</code></pre></div></div>

<p>Selectors are extracted as pattern trees that are syntactically similar to selectors:</p>

<ol>
  <li>Simple identifier selectors are represented as pattern bindings: <code class="highlighter-rouge">pq"bar"</code></li>
  <li>Renaming selectors are represented as thin arrow patterns: <code class="highlighter-rouge">pq"baz -&gt; boo"</code></li>
  <li>Unimport selectors are represented as thin arrows with a wildcard right hand side: <code class="highlighter-rouge">pq"poison -&gt; _"</code></li>
  <li>The wildcard selector is represented as a wildcard pattern: <code class="highlighter-rouge">pq"_"</code></li>
</ol>

<p>Similarly one construct imports back from a programmatically created list of selectors:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; val ref = q"a.b"
scala&gt; val sels = List(pq"foo -&gt; _", pq"_")
scala&gt; val imp = q"import $ref.{..$sels}"
imp: universe.Import = import a.b.{foo=&gt;_, _}
</code></pre></div></div>

				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">

      <ul>
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/setup.html">Dependencies and setup</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/intro.html">Introduction</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/lifting.html">Lifting</a></li>
            
            
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/unlifting.html">Unlifting</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/hygiene.html">Hygiene</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/usecases.html">Use cases</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/syntax-summary.html">Syntax summary</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/expression-details.html">Expression details</a></li>
            
            <div id="toc"></div>
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/type-details.html">Type details</a></li>
            
            
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/pattern-details.html">Pattern details</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/definition-details.html">Definition and import details</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/terminology.html">Terminology summary</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/quasiquotes/future.html">Future prospects</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>

      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_overviews/quasiquotes/expression-details.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

