<!DOCTYPE html>
<html>
  <head>
    <title>SIP-23 - Literal-based singleton types | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/docs.scala-lang/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/docs.scala-lang/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/docs.scala-lang/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs.scala-lang/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/docs.scala-lang/resources/favicon-16x16.png">
    <link rel="manifest" href="/docs.scala-lang/resources/site.webmanifest">
    <link rel="mask-icon" href="/docs.scala-lang/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/docs.scala-lang/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/docs.scala-lang/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/docs.scala-lang/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/docs.scala-lang/" class="navigation-bdand">
        <img src="/docs.scala-lang/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/books.html">Books</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/docs.scala-lang/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/docs.scala-lang/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/docs.scala-lang/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/docs.scala-lang/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>SIP-23 - Literal-based singleton types</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box toc-context">
				<p><strong>Authors: George Leontiev, Eugene Burmako, Jason Zaugg, Adriaan Moors, Paul Phillips, Oron Port, Miles
Sabin</strong></p>

<p><strong>Supervisor and advisor: Adriaan Moors</strong></p>

<h2 id="history">History</h2>

<table>
  <thead>
    <tr>
      <th>Date</th>
      <th>Version</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Jun 27th 2014</td>
      <td>Initial SIP</td>
    </tr>
    <tr>
      <td>Jul 15th 2014</td>
      <td>Last update to SIP before declared dormant</td>
    </tr>
    <tr>
      <td>TBD</td>
      <td>Dormant because original authors are not available for its review</td>
    </tr>
    <tr>
      <td>Feb 9th 2017</td>
      <td>New author volunteered to update the SIP for review</td>
    </tr>
    <tr>
      <td>Nov 16th 2017</td>
      <td>Updated following implementation experience in Typelevel Scala</td>
    </tr>
    <tr>
      <td>Aug 7th 2018</td>
      <td>Updated to remove Symbol literals, which won’t be supported in 3</td>
    </tr>
  </tbody>
</table>

<h2 id="introduction">Introduction</h2>

<p>Singleton types, types which have a unique inhabitant, have been a fundamental component of Scala’s
semantics dating back to the earliest published work on its type system. They are ubiquitous in
ordinary Scala code, typically as the types of Scala object definitions understood as modules, where
their role is to give the meaning of paths selecting types and terms from nested values. Selector
paths have an intuitive meaning to programmers from a wide range of backgrounds which belies their
underpinning by a somewhat “advanced” concept in type theory.</p>

<p>Nevertheless, by pairing a type with it’s unique inhabitant, singleton types bridge the gap between
types and values, and their presence in Scala has over the years allowed Scala programmers to explore
techniques which would typically only be available in languages, such as Agda or Idris, with support
for full-spectrum dependent types.</p>

<p>Scala’s semantics have up until now been richer than its syntax. The only singleton types which are
currently <em>directly</em> expressible are those of the form <code class="highlighter-rouge">p.type</code> where <code class="highlighter-rouge">p</code> is a path pointing to a
value of some subtype of <code class="highlighter-rouge">AnyRef</code>. Internally the Scala compiler also represents singleton types for
individual values of subtypes of <code class="highlighter-rouge">AnyVal</code>, such as <code class="highlighter-rouge">Int</code> or values of type <code class="highlighter-rouge">String</code> which don’t
correspond to paths. These types are inferred in some circumstances, notably as the types of <code class="highlighter-rouge">final</code>
vals. Their primary purpose has been to represent compile time constants (see <a href="http://scala-lang.org/files/archive/spec/2.12/06-expressions.html#constant-expressions">6.24 Constant
Expressions</a>
and the discussion of “constant value definitions” in <a href="http://scala-lang.org/files/archive/spec/2.12/04-basic-declarations-and-definitions.html#value-declarations-and-definitions">4.1 Value Declarations and
Definitions</a>).
The types here correspond to <em>literal</em> values (ie. values which programmers can directly write as
terms, see <a href="http://scala-lang.org/files/archive/spec/2.12/01-lexical-syntax.html#literals">1.3
Literals</a>) such as
<code class="highlighter-rouge">23</code>, <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">"foo"</code> of the larger non-singleton types they inhabit (<code class="highlighter-rouge">Int</code>, <code class="highlighter-rouge">Boolean</code> or <code class="highlighter-rouge">String</code>
respectively). However, there is no surface syntax to express these types.</p>

<p>As we will see in the motivation section of the proposal below, singleton types corresponding to
literal values (henceforth <em>literal types</em>) have many important uses and are already widely used in
many important Scala libraries. The lack of first class syntax for literal types has forced library
authors to use the experimental Scala macro system to provide a means to express them. Whilst this
has proved to be extremely successful, it has poor ergonomics (although this can typically be hidden
from library <em>users</em>) and is not portable – because Scala macros in general and the mechanisms used
to expose literal types to Scala programmes in particular depend on internal implementation details
of the current Scala compiler.</p>

<p>The poor ergonomics of macro-based exposure of literal types was the original motivation for this
SIP. The development of Dotty and other Scala dialects since then has made the portability issue
more urgent.</p>

<h3 id="implementation-status">Implementation status</h3>

<p>Literal types have been implemented in both <a href="https://github.com/typelevel/scala">Typelevel Scala</a>
and <a href="http://dotty.epfl.ch/">Dotty</a>.</p>

<p>There has been a great deal of useful experience with the Typelevel Scala implementation in
<a href="https://github.com/search?p=1&amp;q=-Yliteral-types&amp;type=Code">a variety of projects</a> which has
resulted in several improvements which are incorporated in the latest iteration of this document. A
full implementation of this proposal exists as a pull request relative to the 2.13.x branch of the
Lightbend Scala compiler.</p>

<h2 id="proposal">Proposal</h2>

<h3 id="proposal-summary">Proposal summary</h3>

<ul>
  <li>Literals can now appear in type position, designating the corresponding singleton type.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val one: 1 = 1                     // val declaration
def foo(x: 1): Option[1] = Some(x) // param type, type arg
def bar[T &lt;: 1](t: T): T = t       // type parameter bound
foo(1: 1)                          // type ascription
</code></pre></div>    </div>
  </li>
  <li>The <code class="highlighter-rouge">.type</code> singleton type forming operator can be applied to values of all subtypes of <code class="highlighter-rouge">Any</code>.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def foo[T](t: T): t.type = t
foo(23)                            // result is 23: 23
</code></pre></div>    </div>
  </li>
  <li>The presence of an upper bound of <code class="highlighter-rouge">Singleton</code> on a formal type parameter indicates that
singleton types should be inferred for type parameters at call sites.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def wide[T](t: T): T = t
wide(13)                           // result is 13: Int
def narrow[T &lt;: Singleton](t: T): T = t
narrow(23)                         // result is 23: 23
</code></pre></div>    </div>
  </li>
  <li>Pattern matching against literal types and <code class="highlighter-rouge">isInstanceOf</code>/<code class="highlighter-rouge">asInstanceOf</code> tests/conversions are
implemented via equality/identity tests of the corresponding values.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1: Any) match {
  case one: 1 =&gt; true
  case _ =&gt; false
}                                  // result is true
(1: Any).isInstanceOf[1]           // result is true
(1: Any).asInstanceOf[1]           // result is 1: 1
(1: Any).asInstanceOf[2]           // ClassCastException
</code></pre></div>    </div>
  </li>
  <li>A <code class="highlighter-rouge">scala.ValueOf[T]</code> type class and corresponding <code class="highlighter-rouge">scala.Predef.valueOf[T]</code> operator has been
added yielding the unique value of types with a single inhabitant.
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def foo[T](implicit v: ValueOf[T]): T = v.value
foo[13]                            // result is 13: 13
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="motivating-examples">Motivating examples</h3>

<p>Many of the examples below use primitives provided by the Scala generic programming library
<a href="https://github.com/milessabin/shapeless/">shapeless</a>. It provides a <code class="highlighter-rouge">Witness</code> type class and a
family of Scala macro based methods and conversions for working with singleton types and shifting
from the value to the type level and vice versa. One of the goals of this SIP is to enable Scala
programmers to achieve similar results without having to rely on a third party library or fragile
and non-portable macros.</p>

<p>The relevant parts of shapeless are excerpted in <a href="#appendix-1--shapeless-excerpts">Appendix 1</a>.
Given the definitions there, some of forms summarized above can be expressed in current Scala,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val wOne = Witness(1)
val one: wOne.T = wOne.value  // wOne.T is the type 1
                              // wOne.value is 1: 1

def foo[T](implicit w: Witness[T]): w.T = w.value
foo[wOne.T]                   // result is 1: 1

"foo" -&gt;&gt; 23      // shapeless record field constructor
                  // result type is FieldType["foo", Int]
</code></pre></div></div>
<p>The syntax is awkward and hiding it from library users is challenging. Nevertheless they enable many
constructs which have proven valuable in practice.</p>

<h4 id="shapeless-records">shapeless records</h4>

<p>shapeless models records as HLists (essentially nested pairs) of record values with their types
tagged with the singleton types of their keys. The library provides user friendly mechanisms for
constructing record <em>values</em>, however it is extremely laborious to express the corresponding <em>types</em>.
Consider the following record value,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val book =
  ("author" -&gt;&gt; "Benjamin Pierce") ::
  ("title"  -&gt;&gt; "Types and Programming Languages") ::
  ("id"     -&gt;&gt;  262162091) ::
  ("price"  -&gt;&gt;  44.11) ::
  HNil
</code></pre></div></div>

<p>Using shapeless and current Scala the following would be required to give <code class="highlighter-rouge">book</code> an explicit type
annotation,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val wAuthor = Witness("author")
val wTitle = Witness("title")
val wId = Witness("id")
val wPrice = Witness("price")
type Book =
  (wAuthor.T -&gt;&gt; String) ::
  (wTitle.T  -&gt;&gt; String) ::
  (wId.T     -&gt;&gt; Int) ::
  (wPrice.T  -&gt;&gt; Double) ::
  HNil

val book: Book =
  ("author" -&gt;&gt; "Benjamin Pierce") ::
  ("title"  -&gt;&gt; "Types and Programming Languages") ::
  ("id"     -&gt;&gt;  262162091) ::
  ("price"  -&gt;&gt;  44.11) ::
  HNil
</code></pre></div></div>
<p>Notice that here the <code class="highlighter-rouge">val</code> definitions are essential – they are needed to create the stable path
required for selection of the member types <code class="highlighter-rouge">T</code>.</p>

<p>Under this proposal we can express the record type directly,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Book =
  ("author" -&gt;&gt; String) ::
  ("title"  -&gt;&gt; String) ::
  ("id"     -&gt;&gt; Int) ::
  ("price"  -&gt;&gt; Double) ::
  HNil

val book: Book =
  ("author" -&gt;&gt; "Benjamin Pierce") ::
  ("title"  -&gt;&gt; "Types and Programming Languages") ::
  ("id"     -&gt;&gt;  262162091) ::
  ("price"  -&gt;&gt;  44.11) ::
  HNil
</code></pre></div></div>

<p>shapeless enables generic programming and type class derivation by providing a mechanism for mapping
a value of a standard Scala algebraic data type onto a sum of products representation type,
essentially nested labelled <code class="highlighter-rouge">Either</code>’s of the records discussed above. Techniques of this sort are
widely used, and removing the incidental complexity that comes with encoding via macros will improve
the experience for many users across a wide variety of domains.</p>

<h4 id="refined-and-singleton-ops">refined and singleton-ops</h4>

<p><a href="https://github.com/fthomas/refined">refined</a> and
<a href="https://github.com/fthomas/singleton-ops">singleton-ops</a> are two libraries which build on
shapeless’s <code class="highlighter-rouge">Witness</code> to support refinement types for Scala. A refinement is a type-level predictate
which constrains a set of values relative to some base type, for example, the type of integers
greater thar 5.</p>

<p>refined allows such types to be expressed in Scala using shapeless’s <code class="highlighter-rouge">Witness</code>,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val w5 = Witness(5)
val a: Int Refined Greater[w5.T] = 10

// Since every value greater than 5 is also greater than 4,
// `a` can be ascribed the type Int Refined Greater[w4.T]:
val w4 = Witness(4)
val b: Int Refined Greater[w4.T] = a

// An unsound ascription leads to a compile error:
val w6 = Witness(6)
val c: Int Refined Greater[w6.T] = a

//&lt;console&gt;:23: error: type mismatch (invalid inference):
// Greater[Int(5)] does not imply
// Greater[Int(6)]
//       val c: Int Refined Greater[W.`6`.T] = a
                                             ^
</code></pre></div></div>

<p>Under this proposal we can express these refinements much more succinctly,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val a: Int Refined Greater[5] = 10

val b: Int Refined Greater[4] = a
</code></pre></div></div>

<p>Type level predicates of this kind have proved to be useful in practice and are supported by modules
of a <a href="https://github.com/fthomas/refined#external-modules">number of important libraries</a>.</p>

<p>Experience with those libraries has led to a desire to compute directly over singleton types, in
effect to lift whole term-level expressions to the type-level which has resulted in the development
of the <a href="https://github.com/fthomas/singleton-ops">singleton-ops</a> library. singleton-ops is built
with Typelevel Scala which allows it to use literal types as discussed in this SIP.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import singleton.ops._

class MyVec[L] {
  def doubleSize = new MyVec[2 * L]
  def nSize[N] = new MyVec[N * L]
  def getLength(implicit length : SafeInt[L]) : Int = length
}
object MyVec {
  implicit def apply[L]
    (implicit check : Require[L &gt; 0]) : MyVec[L] =
       new MyVec[L]()
}
val myVec : MyVec[10] = MyVec[4 + 1].doubleSize
val myBadVec = MyVec[-1] //fails compilation, as required
</code></pre></div></div>

<p>singleton-ops is used by a number of libraries, most notably our next motivating example, Libra.</p>

<h4 id="libra">Libra</h4>

<p><a href="https://github.com/to-ithaca/libra">Libra</a> is a a dimensional analysis library based on shapeless,
spire and singleton-ops. It support SI units at the type level for all numeric types. Like
singleton-ops Libra is built using Typelevel Scala and so is able to use literal types as discussed
in this SIP.</p>

<p>Libra allows numeric computations to be checked for dimensional correctness as follows,</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import spire.implicits._
// import spire.implicits._

import libra._, libra.si._
// import libra._
// import libra.si._

(3.m + 2.m).show
// res0: String = 5 m [L]

(3.m * 2.m).show
// res1: String = 6 m^2 [L^2]

(1.0.km.to[Metre] + 2.0.m + 3.0.mm.to[Metre]).show
// res2: String = 1002.003 m [L]

(3.0.s.to[Millisecond] / 3.0.ms).show
// res3: String = 1000.0  []

3.m + 2.kg //this should fail
// &lt;console&gt;:22: error: These quantities can't be added!
//        3.m + 2.kg //this should fail
//            ^
</code></pre></div></div>

<h4 id="spire">Spire</h4>

<p>The Scala numeric library <a href="https://github.com/non/spire">Spire</a> provides us with another example
where it is useful to be able to use literal types as a constraint.</p>

<p>Spire has an open issue to add a <code class="highlighter-rouge">Residue</code> type to model modular arithmetic. An implementation might
look something like this,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case class Residue[M &lt;: Int](n: Int) extends AnyVal {
  def +(rhs: Residue[M])(implicit m: ValueOf[M]): Residue[M] =
    Residue((this.n + rhs.n) % valueOf[M])
}
</code></pre></div></div>

<p>Given this definition we can work with modular numbers without any danger of mixing numbers with
different modulii,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val fiveModTen = Residue[10](5)
val nineModTen = Residue[10](9)

fiveModTen + nineModTen    // OK == Residue[10](4)

val fourModEleven = Residue[11](4)

fiveModTen + fourModEleven
// compiler error: type mismatch;
//   found   : Residue[11]
//   required: Residue[10]
</code></pre></div></div>

<p>Also note that the use of <code class="highlighter-rouge">ValueOf</code> as an implicit argument of <code class="highlighter-rouge">+</code> means that the modulus does not
need to be stored along with the <code class="highlighter-rouge">Int</code> in the <code class="highlighter-rouge">Residue</code> value which could be beneficial in
applications which work with large datasets.</p>

<h3 id="proposal-details">Proposal details</h3>

<ul>
  <li>
    <p>Literals can now appear in type position, designating the corresponding singleton type. The
<a href="http://scala-lang.org/files/archive/spec/2.12/03-types.html"><code class="highlighter-rouge">SimpleType</code></a> production is extended
to include syntactic literals.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SimpleType        ::=  SimpleType TypeArgs
                    |  SimpleType ‘#’ id
                    |  StableId
                    |  Path ‘.’ ‘type’
                    |  Literal
                    |  ‘(’ Types ‘)’
</code></pre></div>    </div>

    <p>Examples,</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val one: 1 = 1                     // val declaration
def foo(x: 1): Option[1] = Some(x) // param type, type arg
def bar[T &lt;: 1](t: T): T = t       // type parameter bound
foo(1: 1)                          // type ascription
</code></pre></div>    </div>
  </li>
  <li>
    <p>The restriction that the singleton type forming operator <code class="highlighter-rouge">.type</code> can only be appended to
stable paths designating a value which conforms to <code class="highlighter-rouge">AnyRef</code> is dropped – the path may now conform
to <code class="highlighter-rouge">Any</code>. Section
<a href="http://scala-lang.org/files/archive/spec/2.12/03-types.html#singleton-types">3.2.1</a> of the SLS is
updated as follows,</p>

    <blockquote>
      <p><strong>Singleton Types</strong></p>

      <pre><code class="language-ebnf">SimpleType  ::=  Path ‘.’ ‘type’
</code></pre>

      <p>A <strong>singleton type</strong> is of the form <code class="highlighter-rouge">p.type</code>. Where <code class="highlighter-rouge">p</code> is a path pointing to a value which
conforms to <code class="highlighter-rouge">scala.AnyRef</code>, the type denotes the set of values consisting of <code class="highlighter-rouge">null</code> and the value
denoted by <code class="highlighter-rouge">p</code> (i.e., the value <code class="highlighter-rouge">v</code> for which <code class="highlighter-rouge">v eq p</code>). Where the path does not conform to
<code class="highlighter-rouge">scala.AnyRef</code> the type denotes the set consisting of only the value denoted by <code class="highlighter-rouge">p</code>.</p>
    </blockquote>

    <p>Example,</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def foo[T](t: T): t.type = t
foo(23)                            // result is 23: 23
</code></pre></div>    </div>
  </li>
  <li>
    <p>The presence of an upper bound of <code class="highlighter-rouge">Singleton</code> on a formal type parameter indicates that
singleton types should be inferred for type parameters at call sites.</p>

    <p>This SIP aims to leave the meaning of all currently valid programmes unchanged, which entails that
it must not alter type inference in currently valid programmes. Current Scala will generally widen
the types of literal values from their singleton type to their natural non-singleton type when
they occur in expressions. For example in,</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val foo = 23
def id[T](t: T): T = t
id(23)
</code></pre></div>    </div>

    <p>we expect the inferred type of <code class="highlighter-rouge">foo</code> and the actual type parameter inferred for <code class="highlighter-rouge">T</code> in the
application of <code class="highlighter-rouge">id</code> to both be <code class="highlighter-rouge">Int</code> rather than <code class="highlighter-rouge">23</code>. This behaviour seems to be natural and
appropriate in circumstances where the programmer is not deliberately working with singleton
types.</p>

    <p>With the introduction of literal types, however, we do want to be able to infer singleton types in
cases such as these,</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case class Show[T](val s: String)
object Show {
  implicit val showTrue: Show[true] = Show[true]("yes")
  implicit val showFalse: Show[false] = Show[false]("no")
}

def show[T](t: T)(implicit st: Show[T]): String = st.s
show(true)   // currently rejected
</code></pre></div>    </div>

    <p>The proposal in this SIP is that we use an upper bound of <code class="highlighter-rouge">Singleton</code> on a formal type parameter
to indicate that a singleton type should be inferred. The above example would then be written
as,</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def show[T &lt;: Singleton](t: T)
  (implicit st: Show[T]): String = st.s
show(true)  // compiles and yields "yes"
</code></pre></div>    </div>

    <p>This change will not affect the meaning of currently valid programmes, because the widened types
inferred for literal values at call sites do not currently conform to <code class="highlighter-rouge">Singleton</code>, hence all call
sites of the form in the above example would currently be rejected as invalid.</p>

    <p>Whilst type inference in Scala is not fully specified, section <a href="http://scala-lang.org/files/archive/spec/2.12/06-expressions.html#local-type-inference">6.26.4 Local Type
Inference</a>
contains language which explicitly excludes the inference of singleton types (see cases 2 and 3,
“None of the inferred types Ti is a singleton type”). This does not match the current Scala or
Dotty compiler implementations, where singleton types are inferred where a definition is final,
specifically non-lazy final val definitions and object definitions. Where a definition has had a
singleton type inferred for it, singleton types will be inferred from its uses,</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final val narrow = 23      // inferred type of narrow: 23

class Widen
object Narrow extends Wide
def id[T](t: T): T = t
id(Narrow)                 // result is Narrow: Narrow.type
</code></pre></div>    </div>

    <p>This SIP updates the specification to match the current implementation and then adds the further
refinement that an explict upper bound of <code class="highlighter-rouge">Singleton</code> indicates that a singleton type should be
inferred.</p>

    <p>Given,</p>

    <blockquote>
      <p>A <strong>singleton-apt</strong> definition is</p>
      <ol>
        <li>An object definition, or</li>
        <li>A non-lazy final val definition</li>
      </ol>
    </blockquote>

    <p>the relevant clauses of 6.26.4 are revised as follows,</p>

    <blockquote>
      <p>None of the inferred types Ti is a singleton type unless, (1) Ti is a singleton type
corresponding to a singleton-apt definition, or (2) The upper bound Ui of Ti conforms to
<code class="highlighter-rouge">Singleton</code>.</p>
    </blockquote>

    <p>Example,</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def wide[T](t: T): T = t
wide(13)                           // result is 13: Int
def narrow[T &lt;: Singleton](t: T): T = t
narrow(23)                         // result is 23: 23
</code></pre></div>    </div>
  </li>
  <li>
    <p>A <code class="highlighter-rouge">scala.ValueOf[T]</code> type class and corresponding <code class="highlighter-rouge">scala.Predef.valueOf[T]</code> operator has been
added yielding the unique value of types with a single inhabitant.</p>

    <p>Type inference allows us to infer a singleton type from a literal value. It is natural to want to
be able to go in the other direction and infer a value from a singleton type.  This latter
capability was exploited in the motivating <code class="highlighter-rouge">Residue</code> example given earlier, and is widely relied
on in current Scala in uses of shapeless’s records, and <code class="highlighter-rouge">LabelledGeneric</code> based type class
derivation.</p>

    <p>Implicit resolution is Scala’s mechanism for inferring values from types and in current Scala
shapeless provides a macro-based materializer for instances of its <code class="highlighter-rouge">Witness</code> type class. This SIP
adds a directly compiler supported type class as a replacement,</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final class ValueOf[T](val value: T) extends AnyVal
</code></pre></div>    </div>

    <p>Instances are automatically provided for all types with a single inhabitant, which includes
literal and non-literal singleton types and <code class="highlighter-rouge">Unit</code>.</p>

    <p>Example,</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def foo[T](implicit v: ValueOf[T]): T = v.value
foo[13]                            // result is 13: 13
</code></pre></div>    </div>

    <p>A method <code class="highlighter-rouge">valueOf</code> is also added to <code class="highlighter-rouge">scala.Predef</code> analogously to existing operators such as
<code class="highlighter-rouge">classOf</code>, <code class="highlighter-rouge">typeOf</code> etc.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def valueOf[T](implicit vt: ValueOf[T]): T = vt.value
</code></pre></div>    </div>

    <p>Example,</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object Foo
valueOf[Foo.type]       // result is Foo: Foo.type

valueOf[23]             // result is 23: 23
</code></pre></div>    </div>
  </li>
  <li>
    <p>Pattern matching against literal types and <code class="highlighter-rouge">isInstanceOf</code>/<code class="highlighter-rouge">asInstanceOf</code> tests/conversions are
implemented via equality/identity tests of the corresponding values.</p>

    <p>Pattern matching against typed patterns (see <a href="http://scala-lang.org/files/archive/spec/2.12/08-pattern-matching.html#typed-patterns">8.1.2 Typed
Patterns</a>)
where the <code class="highlighter-rouge">TypePat</code> is a literal type is translated as a match against the subsuming non-singleton
type followed by an equality test with the value corresponding to the literal type.</p>

    <p>Where applied to literal types <code class="highlighter-rouge">isInstanceOf</code> and <code class="highlighter-rouge">asInstanceOf</code> are translated to a test against
the subsuming non-singleton type and an equality test with the value corresponding to the literal
type. In the case of <code class="highlighter-rouge">asInstanceOf</code> a <code class="highlighter-rouge">ClassCastException</code> is thrown if the test fails.</p>

    <p>Examples,</p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1: Any) match {
  case one: 1 =&gt; true
  case _ =&gt; false
}                                  // result is true
(1: Any).isInstanceOf[1]           // result is true
(1: Any).asInstanceOf[1]           // result is 1: 1
(1: Any).asInstanceOf[2]           // ClassCastException
</code></pre></div>    </div>
  </li>
  <li>
    <p>Default initialization for vars with literal types is forbidden.</p>

    <p>The default initializer for a var is already mandated to be it’s natural zero element (<code class="highlighter-rouge">0</code>,
<code class="highlighter-rouge">false</code>, <code class="highlighter-rouge">null</code> etc.). This is inconsistent with the var being given a non-zero literal type,</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var bad: 1 = _
</code></pre></div>    </div>
    <p>Whilst we could, in principle, provide an implicit non-default initializer for cases such as these
it is the view of the authors of this SIP that there is nothing to be gained from enabling this
construction and that default initializer should be forbidden.</p>
  </li>
</ul>

<h2 id="follow-on-work-from-this-sip">Follow on work from this SIP</h2>

<p>Whilst the authors of this SIP believe that it stands on its own merits, we think that there are two
areas where follow on work is desirable, and one area where another SIP might improve the implementation of SIP-23.</p>

<h3 id="infix-and-prefix-types">Infix and prefix types</h3>

<p><a href="http://docs.scala-lang.org/sips/make-types-behave-like-expressions.html">SIP-33 Match Infix and Prefix Types to Meet Expression Rules</a>
has emerged from the work on refined types and computation over singleton types mentioned in the
motivation section above.</p>

<p>Once literal types are available it is natural to want to lift entire expressions to the type level
as is done already in libraries such as <a href="https://github.com/fthomas/singleton-ops">singleton-ops</a>.
However, the precedence and associativity of symbolic infix <em>type constructors</em> don’t match the
precedence and associativity of symbolic infix <em>value operators</em>, and prefix type constructors don’t
exist at all. It would be valuable to continue the process of aligning the form of the types and
terms.</p>

<h3 id="byte-and-short-literals">Byte and short literals</h3>

<p><code class="highlighter-rouge">Byte</code> and <code class="highlighter-rouge">Short</code> have singleton types, but lack any corresponding syntax either at the type or at the term level. 
These types are important in libraries which deal with low level numerics and protocol implementation
(see eg. <a href="https://github.com/non/spire">Spire</a> and <a href="https://github.com/scodec/scodec">Scodec</a>) and
elsewhere, and the ability to, for instance, index a type class by a byte or short literal would be
valuable.</p>

<p>A prototype of this syntax extension existed at an early stage in the development of Typelevel Scala
but never matured. The possibility of useful literal types adds impetus.</p>

<h3 id="opaque-types">Opaque types</h3>

<p>In the reference implementation of SIP-23, the <code class="highlighter-rouge">ValueOf[A]</code> type is implemented as a value class.
This means that implicit evidence of <code class="highlighter-rouge">ValueOf[A]</code> will erase to <code class="highlighter-rouge">A</code> (the value associated with
the singleton types). This is desirable, but due to value class restrictions, ends up boxing
primitive types (such as <code class="highlighter-rouge">Int</code>).</p>

<p>If we implemented <code class="highlighter-rouge">ValueOf[A]</code> as an opaque type instead of a value class, then this boxing
would be ellided, and the <code class="highlighter-rouge">valueOf[A]</code> method would be compiled to an identity function.</p>

<h2 id="related-scala-issues-resolved-by-the-literal-types-implementation">Related Scala issues resolved by the literal types implementation</h2>

<ul>
  <li><a href="https://github.com/scala/bug/issues/1273">SI-1273</a> Singleton type has wrong bounds</li>
  <li><a href="https://github.com/scala/bug/issues/5103">SI-5103</a> Singleton types not inferred in all places they should be</li>
  <li><a href="https://github.com/scala/bug/issues/8323">SI-8323</a> Duplicate method name &amp; signature with singleton type parameters over constant types</li>
  <li><a href="https://github.com/scala/bug/issues/8564">SI-8564</a> Methods with ConstantType results get the inhabitant of ConstantType as their body</li>
</ul>

<h2 id="appendix-1--shapeless-excerpts">Appendix 1 – shapeless excerpts</h2>

<p>Extracts from shapeless relevant to the motivating examples for this SIP,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait Witness {
  type T           // the singleton type represented by this Witness
  val value: T {}  // the unique inhabitant of that type
}

object Witness extends Dynamic {
  type Aux[T0] = Witness { type T = T0 }
  type Lt[Lub] = Witness { type T &lt;: Lub }

  /**
   * Materialize the Witness for singleton type T
   */
  implicit def apply[T]: Witness.Aux[T] = macro ...

  /**
   * Convert a literal value to its Witness
   */
  implicit def apply[T](t: T): Witness.Lt[T] = macro ...
}

object labelled {
  /**
   * The type of fields with keys of singleton type `K` and value type `V`.
   */
  type FieldType[K, +V] = V with KeyTag[K, V]
  trait KeyTag[K, +V]

  /**
   * Yields a result encoding the supplied value with the singleton type `K' as its key.
   */
  def field[K] = new FieldBuilder[K]

  class FieldBuilder[K] {
    def apply[V](v : V): FieldType[K, V] = v.asInstanceOf[FieldType[K, V]]
  }
}

object singleton {
  implicit def mkSingletonOps(t: Any): SingletonOps = macro ...
}

trait SingletonOps {
  import labelled._

  type T

  /**
   * Returns a Witness of the singleton type of this value.
   */
  val witness: Witness.Aux[T]

  /**
   * Narrows this value to its singleton type.
   */
  def narrow: T {} = witness.value

  /**
   * Returns the provided value tagged with the singleton type
   * of this value as its key in a record-like structure.
   */
  def -&gt;&gt;[V](v: V): FieldType[T, V] = field[T](v)
}

</code></pre></div></div>

			</div>
		</div>

		<!-- TOC -->
    <div class="content-nav">
    	<div class="inner-box sidebar-toc-wrapper sip-toc" style="">
      
        <h5 class="contents">SIP Committee Decision</h5>
         <div class="tag" style="background-color: #859900">Complete</div>
           <p class="vote-text" style="color: #859900">
             
           </p>
        
    		<h5 class="contents">SIP Contents</h5>
    		<div class="inner-toc" id="sidebar-toc">
          <div id="toc"></div>
    		</div>
    		<hr>
    		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_sips/sips/2014-06-27-42.type.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
    	</div>
    </div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/docs.scala-lang/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/docs.scala-lang/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/docs.scala-lang/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/docs.scala-lang/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/docs.scala-lang/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/docs.scala-lang/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/docs.scala-lang/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/docs.scala-lang/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/docs.scala-lang/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/docs.scala-lang/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/docs.scala-lang/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/docs.scala-lang/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/docs.scala-lang/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

