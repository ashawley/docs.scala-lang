<!DOCTYPE html>
<html>
  <head>
    <title>SIP-21 - Spores | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/docs.scala-lang.org/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/docs.scala-lang.org/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/docs.scala-lang.org/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs.scala-lang.org/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/docs.scala-lang.org/resources/favicon-16x16.png">
    <link rel="manifest" href="/docs.scala-lang.org/resources/site.webmanifest">
    <link rel="mask-icon" href="/docs.scala-lang.org/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/docs.scala-lang.org/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/docs.scala-lang.org/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/docs.scala-lang.org/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/docs.scala-lang.org/" class="navigation-bdand">
        <img src="/docs.scala-lang.org/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang.org/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang.org/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang.org/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang.org/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/books.html">Books</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/docs.scala-lang.org/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>SIP-21 - Spores</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box toc-context">
				<p><strong>By: Heather Miller, Martin Odersky, and Philipp Haller</strong></p>

<p><span class="label success">Updated September 15th, 2013</span></p>

<p> </p>

<p>Functional programming languages are regularly touted as an enabling force, as
an increasing number of applications become concurrent and distributed.
However, managing closures in a concurrent or distributed environment, or
writing APIs to be used by clients in such an environment, remains
considerably precarious– complicated environments can be captured by these
closures, which regularly leads to a whole host of potential hazards across
libraries/frameworks in Scala’s standard library and its ecosystem.</p>

<p>Potential hazards when using closures incorrectly:</p>

<ul>
  <li>Memory leaks</li>
  <li>Race conditions, due to capturing mutable references</li>
  <li>Runtime serialization errors, due to unintended capture of references</li>
</ul>

<p>This SIP outlines an abstraction, called <em>spores</em>, which enables safer use of
closures in concurrent and distributed environments. This is achieved by
controlling the environment which a spore can capture. Using an
<em>assignment-on-capture</em> semantics, certain concurrency bugs due to capturing mutable
references can be avoided.</p>

<h2 id="motivating-examples">Motivating Examples</h2>

<h3 id="futures-and-akka-actors">Futures and Akka Actors</h3>

<p>In the following example, an Akka actor spawns a future to concurrently
process incoming requests.</p>

<p><strong>Example 1:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def receive = {
  case Request(data) =&gt;
    Future {
      val result = transform(data)
      sender ! Response(result)
    }
}
</code></pre></div></div>

<p>Capturing <code class="highlighter-rouge">sender</code> in the above example is problematic, since it does not
return a stable value. It is possible that the future’s body is executed at a
time when the actor has started processing the next <code class="highlighter-rouge">Request</code> message which
could be originating from a different actor. As a result, the <code class="highlighter-rouge">Response</code>
message of the future might be sent to the wrong receiver.</p>

<h3 id="serialization">Serialization</h3>

<p>The following example uses Java Serialization to serialize a closure. However,
serialization fails with a <code class="highlighter-rouge">NotSerializableException</code> due to the unintended
capture of a reference to an enclosing object.</p>

<p><strong>Example 2:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case class Helper(name: String)

class Main {
  val helper = Helper("the helper")

  val fun: Int =&gt; Unit = (x: Int) =&gt; {
    val result = x + " " + helper.toString
    println("The result is: " + result)
  }
}
</code></pre></div></div>

<p>Given the above class definitions, serializing the <code class="highlighter-rouge">fun</code> member of an instance
of <code class="highlighter-rouge">Main</code> throws a <code class="highlighter-rouge">NotSerializableException</code>. This is unexpected, since <code class="highlighter-rouge">fun</code>
refers only to serializable objects: <code class="highlighter-rouge">x</code> (an <code class="highlighter-rouge">Int</code>) and <code class="highlighter-rouge">helper</code> (an instance
of a case class).</p>

<p>Here is an explanation of why the serialization of <code class="highlighter-rouge">fun</code> fails: since <code class="highlighter-rouge">helper</code>
is a field, it is not actually copied when it is captured by the closure.
Instead, when accessing helper its getter is invoked. This can be made
explicit by replacing <code class="highlighter-rouge">helper.toString</code> by the invocation of its getter,
<code class="highlighter-rouge">this.helper.toString</code>. Consequently, the <code class="highlighter-rouge">fun</code> closure captures <code class="highlighter-rouge">this</code>, not
just a copy of <code class="highlighter-rouge">helper</code>. However, <code class="highlighter-rouge">this</code> is a reference to class <code class="highlighter-rouge">Main</code> which
is not serializable.</p>

<p>The above example is not the only possible situation in which a closure can
capture a reference to <code class="highlighter-rouge">this</code> or to an enclosing object in an unintended way.
Thus, runtime errors when serializing closures are common.</p>

<h2 id="basic-usage">Basic Usage</h2>

<p>Spores have a few modes of usage. The simplest form is:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val s = spore {
  val h = helper
  (x: Int) =&gt; {
    val result = x + " " + h.toString
    println("The result is: " + result)
  }
}
</code></pre></div></div>

<p>In this example, no transformation is actually performed. Instead, the
compiler simply ensures that the spore is <em>well-formed</em>, i.e., anything that’s
captured is explicitly listed as a value definition before the spore’s
closure. This ensures that the enclosing <code class="highlighter-rouge">this</code> instance is not accidentally
captured, in this example.</p>

<p>Spores can also be used in for-comprehensions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for { i &lt;- collection
      j &lt;- doSomething(i)
} yield s"${capture(i)}: result: $j"
</code></pre></div></div>

<p>Here, the fact that a spore is created is implicit, that is, the <code class="highlighter-rouge">spore</code>
marker is not used explicitly. Spores come into play because the underlying
<code class="highlighter-rouge">map</code> method of the type of <code class="highlighter-rouge">doSomething(i)</code> takes a spore as a parameter. The
<code class="highlighter-rouge">capture(i)</code> syntax is an alternative way of declaring captured variables, in
particular for use in for-comprehensions.</p>

<p>Finally, a regular function literal can be used as a spore. That is, a method
that expects a spore can be passed a function literal so long as the function
literal is well-formed.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def sendOverWire(s: Spore[Int, Int]): Unit = ...
sendOverWire((x: Int) =&gt; x * x - 2)
</code></pre></div></div>

<h2 id="design">Design</h2>

<p>The main idea behind spores is to provide an alternative way to create
closure-like objects, in a way where the environment is controlled.</p>

<p>A spore is created as follows.</p>

<p><strong>Example 3:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val s = spore {
  val h = helper
  (x: Int) =&gt; {
    val result = x + " " + h.toString
    println("The result is: " + result)
  }
}
</code></pre></div></div>

<p>The body of a spore consists of two parts:</p>

<ol>
  <li><strong>the spore header:</strong> a sequence of local value (val) declarations only, and</li>
  <li><strong>the closure</strong>.</li>
</ol>

<p>In general, a <code class="highlighter-rouge">spore { ... }</code> expression has the following shape.</p>

<p>Note that the value declarations described in point 1 above can be <code class="highlighter-rouge">implicit</code>
but not <code class="highlighter-rouge">lazy</code>.</p>

<p><strong>Figure 1:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spore {
  val x_1: T_1 = init_1
  ...
  val x_n: T_n = init_n
  (p_1: S_1, ..., p_m: S_m) =&gt; {
    &lt;body&gt;
  }
}
</code></pre></div></div>

<p>The types <code class="highlighter-rouge">T_1, ..., T_n</code> can also be inferred.</p>

<p>The closure of a spore has to satisfy the following rule. All free variables
of the closure body have to be either</p>

<ol>
  <li>parameters of the closure, or</li>
  <li>declared in the preceding sequence of local value declarations, or</li>
  <li>marked using <code class="highlighter-rouge">capture</code> (see corresponding section  below).</li>
</ol>

<p><strong>Example 4:</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case class Person(name: String, age: Int)
val outer1 = 0
val outer2 = Person("Jim", 35)
val s = spore {
  val inner = outer2
  (x: Int) =&gt; {
    s"The result is: ${x + inner.age + outer1}"
  }
}
</code></pre></div></div>

<p>In the above example, the spore’s closure is invalid, and would be rejected
during compilation. The reason is that the variable <code class="highlighter-rouge">outer1</code> is neither a
parameter of the closure nor one of the spore’s value declarations (the only
value declaration is: <code class="highlighter-rouge">val inner = outer2</code>).</p>

<h3 id="evaluation-semantics">Evaluation Semantics</h3>

<p>In order to make the runtime behavior of a spore as intuitive as possible, the
design leaves the evaluation semantics unchanged compared to regular closures.
Basically, leaving out the <code class="highlighter-rouge">spore</code> marker results in a closure with the same
runtime behavior.</p>

<p>For example,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spore {
  val l = this.logger
  () =&gt; new LoggingActor(l)
}
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  val l = this.logger
  () =&gt; new LoggingActor(l)
}
</code></pre></div></div>

<p>have the same behavior at runtime. The rationale for this design decision is
that the runtime behavior of closure-heavy code can already be hard to reason
about. It would become even more difficult if we would introduce additional
rules for spores.</p>

<h3 id="spore-type">Spore Type</h3>

<p>The type of the spore is determined by the type and arity of the closure. If
the closure has type <code class="highlighter-rouge">A =&gt; B</code>, then the spore has type <code class="highlighter-rouge">Spore[A, B]</code>. For
convenience we also define spore types for two or more parameters.</p>

<p>In example 3, the type of s is <code class="highlighter-rouge">Spore[Int, Unit]</code>.
Implementation
The spore construct is a macro which</p>

<ul>
  <li>performs the checking described above, and which</li>
  <li>replaces the spore body so that it creates an instance of one of the Spore traits, according to the arity of the closure of the spore.</li>
</ul>

<p>The <code class="highlighter-rouge">Spore</code> trait for spores of arity 1 is declared as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait Spore[-T, +R] extends Function1[T, R]
</code></pre></div></div>

<p>For each function arity there exists a corresponding <code class="highlighter-rouge">Spore</code> trait of the same
arity (called <code class="highlighter-rouge">Spore2</code>, <code class="highlighter-rouge">Spore3</code>, etc.)</p>

<h3 id="implicit-conversion">Implicit Conversion</h3>

<p>Regular function literals can be implicitly converted to spores. This implicit
conversion has two benefits:</p>

<ol>
  <li>it enables the use of spores in for-comprehensions.</li>
  <li>it makes the spore syntax more lightweight, which is important in frameworks such as <a href="http://spark.incubator.apache.org/">Spark</a> where users often create many small function literals.</li>
</ol>

<p>This conversion is defined as a member of the <code class="highlighter-rouge">Spore</code> companion object, so
it’s always in the implicit scope when passing a function literal as a method
argument when a <code class="highlighter-rouge">Spore</code> is expected. For example, one can do the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def sendOverWire(s: Spore[Int, Int]): Unit = ...
sendOverWire((x: Int) =&gt; x * x - 2)
</code></pre></div></div>

<p>This is arguably much lighter-weight than having to declare a spore before
passing it to <code class="highlighter-rouge">sendOverWire</code>.</p>

<p>In general, the implicit conversion will be successful if and only if the
function literal is well-formed according to the spore rules (defined above in
the <em>Design</em> section). Note that <em>only function literals can be converted to spores</em>.
This is due to the fact that the body of the function literal has to be checked
by the spore macro to make sure that the conversion is safe. For <em>named</em> function
values (i.e., not literals) on the other hand, it’s not guaranteed that the
function value’s body is available for the spore macro to check.</p>

<h3 id="capture-syntax-and-for-comprehensions">Capture Syntax and For-Comprehensions</h3>

<p>To enable the use of spores with for-comprehensions, a <code class="highlighter-rouge">capture</code> syntax has
been introduced to assist in the spore checking.</p>

<p>To see why this is necessary, let’s start with an example. Suppose we have a
type for distributed collections:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait DCollection[A] {
  def map[B](sp: Spore[A, B]): DCollection[B]
  def flatMap[B](sp: Spore[A, DCollection[B]]): DCollection[B]
}
</code></pre></div></div>

<p>This type, <code class="highlighter-rouge">DCollection</code>, might be implemented in a way where the data is
distributed across machines in a cluster. Thus, the functions passed to <code class="highlighter-rouge">map</code>,
<code class="highlighter-rouge">flatMap</code>, etc. have to be serializable. A simple way to ensure this is to
require these arguments to be spores. However, we also would like for-comprehensions
like the following to work:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def lookup(i: Int): DCollection[Int] = ...
val indices: DCollection[Int] = ...

for { i &lt;- indices
      j &lt;- lookup(i)
} yield j + i
</code></pre></div></div>

<p>A problem here is that the desugaring done by the compiler for
for-comprehensions doesn’t know anything about spores. This is what
the compiler produces from the above expression:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>indices.flatMap(i =&gt; lookup(i).map(j =&gt; j + i))
</code></pre></div></div>

<p>The problem is that <code class="highlighter-rouge">(j =&gt; j + i)</code> is not a spore. Furthermore, making it a
spore is not straightforward, as we can’t change the way for-comprehensions
are translated.</p>

<p>We can overcome this by using the implicit conversion introduced in the
previous section to convert the function literal implicitly to a spore.</p>

<p>However, in continuing to look at this example, it’s evident that the lambda
still has the wrong shape. The captured variable <code class="highlighter-rouge">i</code> is not declared in the
spore header (the list of value definitions preceding the closure within the
spore), like a spore demands.</p>

<p>We can overcome this using the <code class="highlighter-rouge">capture</code> syntax – an alternative way of
capturing paths. That is, instead of having to write:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  val captured = i
  j =&gt; j + i
}
</code></pre></div></div>

<p>One can also write:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(j =&gt; j + capture(i))
</code></pre></div></div>

<p>Thus, the above for-comprehension can be rewritten using spores and <code class="highlighter-rouge">capture</code>
as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for { i &lt;- indices
      j &lt;- lookup(i)
} yield j + capture(i)
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">i</code> is “captured” as it occurs syntactically after the arrow of another
generator (it occurs after <code class="highlighter-rouge">j &lt;- lookup(i)</code>, the second generator in the
for-comprehension).</p>

<p><strong>Note:</strong> anything that is “captured” using <code class="highlighter-rouge">capture</code> may only be a path.</p>

<p><strong>A path</strong> (as defined by the Scala Language Specification, section 3.1) is:</p>

<ul>
  <li>The empty path ε (which cannot be written explicitly in user programs).</li>
  <li><code class="highlighter-rouge">C.this</code>, where <code class="highlighter-rouge">C</code> references a class.</li>
  <li><code class="highlighter-rouge">p.x</code> where <code class="highlighter-rouge">p</code> is a path and <code class="highlighter-rouge">x</code> is a stable member of <code class="highlighter-rouge">p</code>.</li>
  <li><code class="highlighter-rouge">C.super.x</code> or <code class="highlighter-rouge">C.super[M].x</code> where <code class="highlighter-rouge">C</code> references a class and <code class="highlighter-rouge">x</code> references a stable member of the super class or designated parent class <code class="highlighter-rouge">M</code> of <code class="highlighter-rouge">C</code>.</li>
</ul>

<p>The reason why captured expressions are restricted to paths is that otherwise
the two closures</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x =&gt; &lt;expr1&gt; + capture(&lt;expr2&gt;))
</code></pre></div></div>

<p>and</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(x =&gt; &lt;expr1&gt; + &lt;expr2&gt;)
</code></pre></div></div>

<p>(where <code class="highlighter-rouge">&lt;expr1&gt;</code> and <code class="highlighter-rouge">&lt;expr2&gt;</code> are not just paths) would not have the same
runtime behavior, because in the first case, the closure would have to be
transformed in a way that would evaluate <code class="highlighter-rouge">&lt;expr2&gt;</code> “outside of the closure”.
Not only would this complicate the reasoning about spore-based code (see the
section Evaluation Semantics above), but it’s not clear what “outside of the
closure” even means in a context such as for-comprehensions.</p>

<h3 id="macro-expansion">Macro Expansion</h3>

<p>An invocation of the spore macro expands the spore’s body as follows. Given
the general shape of a spore as shown above, the spore macro produces the
following code:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  new &lt;spore implementation class&gt;[S_1, ..., S_m, R]({
    val x_1: T_1 = init_1
    ...
    val x_n: T_n = init_n
    (p_1: S_1, ..., p_m: S_m) =&gt; {
      &lt;body&gt;
    }
  })
</code></pre></div></div>

<p>Note that, after checking, the spore macro need not do any further
transformation, since implementation details such as unneeded remaining outer
references are removed by the new backend intended for inclusion in Scala
2.11. It’s also useful to note that in some cases these unwanted outer
references are already removed by the existing backend.</p>

<p>The spore implementation classes follow a simple pattern. For example, for
arity 1, the implementation class is declared as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class SporeImpl[-T, +R](f: T =&gt; R) extends Spore[T, R] {
    def apply(x: T): R = f(x)
  }
</code></pre></div></div>

<h3 id="type-inference">Type Inference</h3>

<p>Similar to regular functions and closures, the type of a spore should be
inferred. Inferring the type of a spore amounts to inferring the type
arguments when instantiating a spore implementation class:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  new &lt;spore implementation class&gt;[S_1, ..., S_m, R]({
    // ...
  })
</code></pre></div></div>

<p>In the above expression, the type arguments <code class="highlighter-rouge">S_1, ..., S_m</code>, and <code class="highlighter-rouge">R</code> should be
inferred from the expected type.</p>

<p>Our current proposal is to solve this type inference problem in the context of
the integration of Java SAM closures into Scala. Given that it is planned to
eventually support such closures, and to support type inference for these
closures as well, we plan to piggyback on the work done on type inference for
SAMs in general to achieve type inference for spores.</p>

<h2 id="motivating-examples-revisited">Motivating Examples, Revisited</h2>

<p>We now revisit the motivating examples we described in the above section, this
time in the context of spores.</p>

<h3 id="futures-and-akka-actors-1">Futures and Akka actors</h3>

<p>The safety of futures can be improved by requiring the body of a new future to
be a nullary spore (a spore with an empty parameter list).</p>

<p>Using spores, example 1 can be re-written as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def receive = {
  case Request(data) =&gt;
    future(spore {
      val from = sender
      val d = data
      () =&gt; {
        val result = transform(d)
        from ! Response(result)
      }
    })
}
</code></pre></div></div>

<p>In this case, the problematic capturing of <code class="highlighter-rouge">this</code> is avoided, since the result
of <code class="highlighter-rouge">this.sender</code> is assigned to the spore’s local value <code class="highlighter-rouge">from</code> when the spore
is created. The spore conformity checking ensures that within the spore’s
closure, only <code class="highlighter-rouge">from</code> and <code class="highlighter-rouge">d</code> are used.</p>

<h3 id="serialization-1">Serialization</h3>

<p>Using spores, example 2 can be re-written as follows:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case class Helper(name: String)

class Main {
  val helper = Helper("the helper")

  val fun: Spore[Int, Unit] = spore {
    val h = helper
    (x: Int) =&gt; {
      val result = x + " " + h.toString
      println("The result is: " + result)
    }
  }
}
</code></pre></div></div>

<p>Similar to example 1, the problematic capturing of <code class="highlighter-rouge">this</code> is avoided, since
<code class="highlighter-rouge">helper</code> has to be assigned to a local value (here, <code class="highlighter-rouge">h</code>) so that it can be
used inside the spore’s closure. As a result, <code class="highlighter-rouge">fun</code> can now be serialized
without runtime errors, since <code class="highlighter-rouge">h</code> refers to a serializable object (a case
class instance).</p>

			</div>
		</div>

		<!-- TOC -->
    <div class="content-nav">
    	<div class="inner-box sidebar-toc-wrapper sip-toc" style="">
      
        <h5 class="contents">SIP Committee Decision</h5>
         <div class="tag" style="background-color: #b58900">Under Review</div>
           <p class="vote-text" style="color: #b58900">
             Next iteration takes place in January/February 2017 by request of the authors.
           </p>
        
    		<h5 class="contents">SIP Contents</h5>
    		<div class="inner-toc" id="sidebar-toc">
          <div id="toc"></div>
    		</div>
    		<hr>
    		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_sips/sips/2013-06-10-spores.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
    	</div>
    </div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/docs.scala-lang.org/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/docs.scala-lang.org/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/docs.scala-lang.org/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/docs.scala-lang.org/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/docs.scala-lang.org/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/docs.scala-lang.org/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/docs.scala-lang.org/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/docs.scala-lang.org/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/docs.scala-lang.org/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/docs.scala-lang.org/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/docs.scala-lang.org/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/docs.scala-lang.org/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/docs.scala-lang.org/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

