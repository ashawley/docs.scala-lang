<!DOCTYPE html>
<html>
  <head>
    <title>Where does Scala look for implicits? | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/docs.scala-lang.org/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/docs.scala-lang.org/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/docs.scala-lang.org/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs.scala-lang.org/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/docs.scala-lang.org/resources/favicon-16x16.png">
    <link rel="manifest" href="/docs.scala-lang.org/resources/site.webmanifest">
    <link rel="mask-icon" href="/docs.scala-lang.org/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/docs.scala-lang.org/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/docs.scala-lang.org/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang.org/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/docs.scala-lang.org/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/docs.scala-lang.org/" class="navigation-bdand">
        <img src="/docs.scala-lang.org/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang.org/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang.org/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang.org/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang.org/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang.org/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang.org/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/books.html">Books</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang.org/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/docs.scala-lang.org/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/docs.scala-lang.org/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">FAQ</div>
          
          <h1>Where does Scala look for implicits?</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p>Newcomers to Scala often ask: Where does the compiler look for implicits?</p>

<p>For example, where do the values for <code class="highlighter-rouge">integral</code> below come from?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; import scala.math._
import scala.math._

scala&gt; def foo[T](t: T)(implicit integral: Integral[T]): Unit = {
    println(integral)
}
foo: [T](t: T)(implicit integral: scala.math.Integral[T])Unit

scala&gt; foo(0)
scala.math.Numeric$IntIsIntegral$@3dbea611

scala&gt; foo(0L)
scala.math.Numeric$LongIsIntegral$@48c610af
</code></pre></div></div>

<p>The natural continuation of this line of inquiry leads to a second question: How
does the compiler choose which implicit to use, in certain situations of apparent
ambiguity (but that compile anyway)?</p>

<p>For instance, <code class="highlighter-rouge">scala.Predef</code> defines two conversions from <code class="highlighter-rouge">String</code>: one to
<code class="highlighter-rouge">WrappedString</code> and another to <code class="highlighter-rouge">StringOps</code>. Both classes, however, share a lot
of methods, so why doesn’t Scala complain about ambiguity when, say, calling
<code class="highlighter-rouge">map</code>?</p>

<p><strong>Note:</strong> this question was inspired by <a href="http://stackoverflow.com/questions/5512397/passing-scala-math-integral-as-implicit-parameter">this other question on Stack
Overflow</a>, but states the problem in more general terms.  The example was
copied from there, because it is referred to in the answer.</p>

<h2 id="types-of-implicits">Types of Implicits</h2>

<p>Implicits in Scala refers to either a value that can be passed “automatically”,
so to speak, or a conversion from one type to another that is made
automatically.</p>

<h3 id="implicit-conversion">Implicit Conversion</h3>

<p>Speaking very briefly about the latter type, if one calls a method <code class="highlighter-rouge">m</code> on an
object <code class="highlighter-rouge">o</code> of a class <code class="highlighter-rouge">C</code>, and that class does not support method <code class="highlighter-rouge">m</code>, then
Scala will look for an implicit conversion from <code class="highlighter-rouge">C</code> to something that <em>does</em>
support <code class="highlighter-rouge">m</code>. A simple example would be the method <code class="highlighter-rouge">map</code> on <code class="highlighter-rouge">String</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"abc".map(_.toInt)
</code></pre></div></div>

<p><code class="highlighter-rouge">String</code> does not support the method <code class="highlighter-rouge">map</code>, but <code class="highlighter-rouge">StringOps</code> does, and there’s
an implicit conversion from <code class="highlighter-rouge">String</code> to <code class="highlighter-rouge">StringOps</code> available (see <code class="highlighter-rouge">implicit
def augmentString</code> on <code class="highlighter-rouge">Predef</code>).</p>

<h3 id="implicit-parameters">Implicit Parameters</h3>

<p>The other kind of implicit is the implicit <em>parameter</em>. These are passed to
method calls like any other parameter, but the compiler tries to fill them in
automatically. If it can’t, it will complain. One <em>can</em> pass these parameters
explicitly, which is how one uses <code class="highlighter-rouge">breakOut</code>, for example (see question about
<code class="highlighter-rouge">breakOut</code>, on a day you are feeling up for a challenge).</p>

<p>In this case, one has to declare the need for an implicit, such as the <code class="highlighter-rouge">foo</code>
method declaration:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def foo[T](t: T)(implicit integral: Integral[T]): Unit = {
    println(integral)
}
</code></pre></div></div>

<h3 id="implicit-conversions-as-implicit-parameters">Implicit conversions as implicit parameters</h3>

<p>There’s one situation where an implicit is both an implicit conversion and an
implicit parameter. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def getIndex[T, CC](seq: CC, value: T)(implicit conv: CC =&gt; Seq[T]) = seq.indexOf(value)

getIndex("abc", 'a')
</code></pre></div></div>

<p>The method <code class="highlighter-rouge">getIndex</code> can receive any object, as long as there is an implicit
conversion available from its class to <code class="highlighter-rouge">Seq[T]</code>. Because of that, a <code class="highlighter-rouge">String</code> can be
passed to <code class="highlighter-rouge">getIndex</code>, and it will work.</p>

<p>Behind the scenes, the compiler changes <code class="highlighter-rouge">seq.IndexOf(value)</code> to
<code class="highlighter-rouge">conv(seq).indexOf(value)</code>.</p>

<h3 id="context-bounds">Context Bounds</h3>

<p>Another common pattern in implicit parameters is the <em>type class pattern</em>. This
pattern enables the provision of common interfaces to classes which did not
declare them. It can both serve as a bridge pattern – gaining separation of
concerns – and as an adapter pattern.</p>

<p>The <code class="highlighter-rouge">Integral</code> class mentioned above is a classic example of type class pattern.
Another example on Scala’s standard library is <code class="highlighter-rouge">Ordering</code>. Scalaz is a library
that makes heavy use of this pattern.</p>

<p>This is an example of its use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def sum[T](list: List[T])(implicit integral: Integral[T]): T = {
    import integral._   // get the implicits in question into scope
    list.foldLeft(integral.zero)(_ + _)
}
</code></pre></div></div>

<p>There is also a syntactic sugar for it, called a <em>context bound</em>, which is made
less useful by the need to refer to the implicit. A straight conversion of that
method looks like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def sum[T : Integral](list: List[T]): T = {
    val integral = implicitly[Integral[T]]
    import integral._   // get the implicits in question into scope
    list.foldLeft(integral.zero)(_ + _)
}
</code></pre></div></div>

<p>Context bounds are more useful when you just need to <em>pass</em> them to other
methods that use them. For example, the method <code class="highlighter-rouge">sorted</code> on <code class="highlighter-rouge">Seq</code> needs an
implicit <code class="highlighter-rouge">Ordering</code>. To create a method <code class="highlighter-rouge">reverseSort</code>, one could write:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def reverseSort[T : Ordering](seq: Seq[T]) = seq.reverse.sorted
</code></pre></div></div>

<p>Because <code class="highlighter-rouge">Ordering[T]</code> was implicitly passed to <code class="highlighter-rouge">reverseSort</code>, it can then pass
it implicitly to <code class="highlighter-rouge">sorted</code>.</p>

<h2 id="where-do-implicits-come-from">Where do Implicits Come From?</h2>

<p>As described above, there are several contexts in which an implicit value may be required 
for an expression to typecheck. The required implicit type is what determines
which value is selected. That value is found either in lexical scope or,
failing that, in what is called implicit scope.</p>

<h3 id="implicits-defined-in-lexical-scope">Implicits Defined in Lexical Scope</h3>

<p>When a value of a certain name is required, lexical scope is searched for
a value with that name. Similarly, when an implicit value of a certain type is required,
lexical scope is searched for a value with that type.</p>

<p>Any such value which can be referenced with its “simple” name, without
selecting from another value using dotted syntax, is an eligible implicit value.</p>

<p>For example, here is a function that takes an implicit scaling factor.
The function requires a parameter of type <code class="highlighter-rouge">Int</code>, and there is a value
of that type in scope. The variable name <code class="highlighter-rouge">n</code> does not matter in this
case.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>implicit val n: Int = 5
def scale(x: Int)(implicit y: Int) = x * y
scale(5) // takes n from the current scope, with the result 25
</code></pre></div></div>

<p>The invocation can be rewritten <code class="highlighter-rouge">scale(5)(n)</code>. If <code class="highlighter-rouge">n</code> can be referenced
using its simple name, as shown here, it is eligible as an implicit value.</p>

<p>An implicit value can be introduced into scope by an import statement:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.collection.JavaConverters._
def env = System.getenv().asScala   // extension method enabled by imported implicit
val term = env("TERM")              // it's a Scala Map
</code></pre></div></div>

<p>There may be more than one such value because they have different names.</p>

<p>In that case, overload resolution is used to pick one of them. The algorithm
for overload resolution is the same used to choose the reference for a
given name, when more than one term in scope has that name. For example,
<code class="highlighter-rouge">println</code> is overloaded, and each overload takes a different parameter type.
An invocation of <code class="highlighter-rouge">println</code> requires selecting the correct overloaded method.</p>

<p>In implicit search, overload resolution chooses a value among more than one
that have the same required type. Usually this entails selecting a narrower
type or a value defined in a subclass relative to other eligible values.</p>

<p>The rule that the value must be accessible using its simple name means
that the normal rules for name binding apply.</p>

<p>In summary, a definition for <code class="highlighter-rouge">x</code> shadows a definition in
an enclosing scope. But a binding for <code class="highlighter-rouge">x</code> can also be introduced by
local imports. Imported symbols can’t override definitions of the same
name in an enclosing scope. Similarly, wildcard imports can’t override
an import of a specific name, and names in the current package that are
visible from other source files can’t override imports or local definitions.</p>

<p>These are the normal rules for deciding what <code class="highlighter-rouge">x</code> means in a given context,
and also determine which value <code class="highlighter-rouge">x</code> is accessible by its simple name and
is eligible as an implicit.</p>

<p>This means that an implicit in scope can be disabled by shadowing it with
a term of the same name.</p>

<p>For example, here, <code class="highlighter-rouge">X.f</code> is supplied the imported <code class="highlighter-rouge">X.s</code>: <code class="highlighter-rouge">X.f(s)</code>.
The body of <code class="highlighter-rouge">f</code> uses an implicit <code class="highlighter-rouge">Int</code>, from the immediate scope,
which shadows the <code class="highlighter-rouge">n</code> from <code class="highlighter-rouge">Y</code>, which is therefore not an eligible
implicit value. The parameter <code class="highlighter-rouge">s</code> shadows the member <code class="highlighter-rouge">s</code>.</p>

<p>The method <code class="highlighter-rouge">g</code> does not compile because the implicit <code class="highlighter-rouge">t</code> is shadowed
by a <code class="highlighter-rouge">t</code> that is not implicit, so no implicit <code class="highlighter-rouge">T</code> is in scope.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object Y {
  implicit val n: Int = 17
  trait T {
    implicit val i: Int = 17
    implicit def t: T   = ???
  }
  object X extends T {
    implicit val n: Int = 42
    implicit val s: String = "hello, world\n"
    def f(implicit s: String) = implicitly[String] * implicitly[Int]
    override def t: T = ???
    def g = implicitly[T]
  }
}
import Y.X._
f
</code></pre></div></div>

<p>The invocation of <code class="highlighter-rouge">f</code> was enabled by importing from <code class="highlighter-rouge">Y.X.</code>. But it is
not convenient to require an import to access implicit values
providied by a package.</p>

<p>If an implicit value is not found in lexical scope, implicit search
continues in implicit scope.</p>

<h3 id="implicits-defined-in-implicit-scope">Implicits Defined in Implicit Scope</h3>

<p>Implicit syntax can avoid the <a href="http://jsuereth.com/scala/2011/02/18/2011-implicits-without-tax.html">import tax</a>, which of course is a “sin tax,”
by leveraging “implicit scope”, which depends on the type of the implicit
instead of imports in lexical scope.</p>

<p>When an implicit of type <code class="highlighter-rouge">T</code> is required, implicit scope includes
the companion object <code class="highlighter-rouge">T</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait T
object T { implicit val t: T = new T { } }
</code></pre></div></div>

<p>When an <code class="highlighter-rouge">F[T]</code> is required, implicit scope includes both the companion
of <code class="highlighter-rouge">F</code> and the companion of the type argument, e.g., <code class="highlighter-rouge">object C</code> for <code class="highlighter-rouge">F[C]</code>.</p>

<p>In addition, implicit scope includes the companions of the base classes
of <code class="highlighter-rouge">F</code> and <code class="highlighter-rouge">C</code>, including package objects, such as <code class="highlighter-rouge">p</code> for <code class="highlighter-rouge">p.F</code>.</p>

<h3 id="companion-objects-of-a-type">Companion Objects of a Type</h3>

<p>There are two object companions of note here. First, the object companion of
the “source” type is looked into. For instance, inside the object <code class="highlighter-rouge">Option</code>
there is an implicit conversion to <code class="highlighter-rouge">Iterable</code>, so one can call <code class="highlighter-rouge">Iterable</code>
methods on <code class="highlighter-rouge">Option</code>, or pass <code class="highlighter-rouge">Option</code> to something expecting an <code class="highlighter-rouge">Iterable</code>. For
example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>for {
    x &lt;- List(1, 2, 3)
    y &lt;- Some('x')
} yield (x, y)
</code></pre></div></div>

<p>That expression is translated by the compiler into</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List(1, 2, 3).flatMap(x =&gt; Some('x').map(y =&gt; (x, y)))
</code></pre></div></div>

<p>However, <code class="highlighter-rouge">List.flatMap</code> expects a <code class="highlighter-rouge">TraversableOnce</code>, which <code class="highlighter-rouge">Option</code> is not. The
compiler then looks inside <code class="highlighter-rouge">Option</code>’s object companion and finds the conversion
to <code class="highlighter-rouge">Iterable</code>, which is a <code class="highlighter-rouge">TraversableOnce</code>, making this expression correct.</p>

<p>Second, the companion object of the expected type:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List(1, 2, 3).sorted
</code></pre></div></div>

<p>The method <code class="highlighter-rouge">sorted</code> takes an implicit <code class="highlighter-rouge">Ordering</code>. In this case, it looks inside
the object <code class="highlighter-rouge">Ordering</code>, companion to the class <code class="highlighter-rouge">Ordering</code>, and finds an implicit
<code class="highlighter-rouge">Ordering[Int]</code> there.</p>

<p>Note that companion objects of super classes are also looked into. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A(val n: Int)
object A {
    implicit def str(a: A) = "A: %d" format a.n
}
class B(val x: Int, y: Int) extends A(y)
val b = new B(5, 2)
val s: String = b  // s == "A: 2"
</code></pre></div></div>

<p>This is how Scala found the implicit <code class="highlighter-rouge">Numeric[Int]</code> and <code class="highlighter-rouge">Numeric[Long]</code> in the
opening example, by the way, as they are found inside <code class="highlighter-rouge">Numeric</code>, not <code class="highlighter-rouge">Integral</code>.</p>

<h3 id="implicit-scope-of-an-arguments-type">Implicit scope of an argument’s type</h3>

<p>If you have a method with an argument type <code class="highlighter-rouge">A</code>, then the implicit scope of type
<code class="highlighter-rouge">A</code> will also be considered. Here “implicit scope” means all these rules
will be applied recursively – for example, the companion object of <code class="highlighter-rouge">A</code> will be
searched for implicits, as per the rule above.</p>

<p>Note that this does not mean the implicit scope of <code class="highlighter-rouge">A</code> will be searched for
conversions of that parameter alone, but of the whole expression. For example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A(val n: Int) {
  def +(other: A) = new A(n + other.n)
}
object A {
  implicit def fromInt(n: Int) = new A(n)
}

// This becomes possible:
1 + new A(1)
// because it is converted into this:
A.fromInt(1) + new A(1)
</code></pre></div></div>

<h3 id="implicit-scope-of-type-arguments">Implicit scope of type arguments</h3>

<p>This is required to make the type class pattern really work. Consider
<code class="highlighter-rouge">Ordering</code>, for instance… it comes with some implicits in its companion
object, but you can’t add stuff to it. So how can you make an <code class="highlighter-rouge">Ordering</code> for
your own class that is automatically found?</p>

<p>Let’s start with the implementation:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A(val n: Int)
object A {
    implicit val ord = new Ordering[A] {
        def compare(x: A, y: A) = implicitly[Ordering[Int]].compare(x.n, y.n)
    }
}
</code></pre></div></div>

<p>So, consider what happens when you call</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>List(new A(5), new A(2)).sorted
</code></pre></div></div>

<p>As we saw, the method <code class="highlighter-rouge">sorted</code> expects an <code class="highlighter-rouge">Ordering[A]</code> (actually, it expects
an <code class="highlighter-rouge">Ordering[B]</code>, where <code class="highlighter-rouge">B &gt;: A</code>). There isn’t any such thing inside
<code class="highlighter-rouge">Ordering</code>, and there is no “source” type on which to look. Obviously, it is
finding it inside <code class="highlighter-rouge">A</code>, which is a <em>type argument</em> of <code class="highlighter-rouge">Ordering</code>.</p>

<p>This is also how various collection methods expecting <code class="highlighter-rouge">CanBuildFrom</code> work: the
implicits are found inside companion objects to the type parameters of
<code class="highlighter-rouge">CanBuildFrom</code>.</p>

<p><strong>Note</strong>: <code class="highlighter-rouge">Ordering</code> is defined as <code class="highlighter-rouge">trait Ordering[T]</code>, where <code class="highlighter-rouge">T</code> is a type
parameter. The implicit looked for above is <code class="highlighter-rouge">Ordering[A]</code>, where
<code class="highlighter-rouge">A</code> is an actual type, not type parameter: it is a <em>type argument</em> to
<code class="highlighter-rouge">Ordering</code>. See section 7.2 of the <a href="http://scala-lang.org/files/archive/spec/2.11/07-implicits.html">Scala Specification</a>.</p>

<h3 id="outer-objects-for-nested-types">Outer Objects for Nested Types</h3>

<p>The principle is simple:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class A(val n: Int) {
  class B(val m: Int) { require(m &lt; n) }
}
object A {
  implicit def bToString(b: A#B) = "B: %d" format b.m
}
val a = new A(5)
val b = new a.B(3)
val s: String = b  // s == "B: 3"
</code></pre></div></div>

<p>A real world example of this would be welcome. Please share your example!</p>

<h3 id="package-objects-can-contribute-implicit-values">Package Objects Can Contribute Implicit Values</h3>

<p>An implicit value in a package object can be made available either
in lexical scope or in implicit scope.</p>

<p>To be available in lexical scope, the packages must be declared as nested packages:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">object</span> <span class="n">p</span> <span class="p">{</span> <span class="n">implicit</span> <span class="n">val</span> <span class="n">s</span><span class="p">:</span> <span class="k">String</span> <span class="p">=</span> <span class="s2">"hello, world"</span> <span class="p">}</span>
<span class="k">package</span> <span class="n">p</span> <span class="p">{</span>
  <span class="k">package</span> <span class="n">q</span> <span class="p">{</span>
    <span class="n">object</span> <span class="n">X</span> <span class="p">{</span> <span class="n">def</span> <span class="n">f</span> <span class="p">=</span> <span class="n">implicitly</span><span class="p">[</span><span class="k">String</span><span class="p">]</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is sensitive to name binding rules. The following example compiles
only if the package object is in a separate file, in which case the import is used:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">object</span> <span class="n">p</span> <span class="p">{</span> <span class="n">implicit</span> <span class="n">val</span> <span class="n">s</span><span class="p">:</span> <span class="k">String</span> <span class="p">=</span> <span class="s2">"hello, world"</span> <span class="p">}</span>
<span class="k">package</span> <span class="n">p</span> <span class="p">{</span>
  <span class="k">package</span> <span class="n">q</span> <span class="p">{</span>
    <span class="n">object</span> <span class="n">Y</span> <span class="p">{</span>
      <span class="n">implicit</span> <span class="n">val</span> <span class="n">s</span><span class="p">:</span> <span class="k">String</span> <span class="p">=</span> <span class="s2">"bye"</span>
    <span class="p">}</span>
    <span class="n">object</span> <span class="n">X</span> <span class="p">{</span>
      <span class="n">import</span> <span class="n">Y</span><span class="p">.</span><span class="n">_</span>
      <span class="n">def</span> <span class="n">f</span> <span class="p">=</span> <span class="n">implicitly</span><span class="p">[</span><span class="k">String</span><span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A package object can also offer implicit values of types in subpackages:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">object</span> <span class="n">p</span> <span class="p">{</span> <span class="n">implicit</span> <span class="n">val</span> <span class="n">c</span><span class="p">:</span> <span class="n">q</span><span class="p">.</span><span class="n">C</span> <span class="p">=</span> <span class="n">new</span> <span class="n">q</span><span class="p">.</span><span class="n">C</span> <span class="p">}</span>
<span class="k">package</span> <span class="n">p</span><span class="p">.</span><span class="n">q</span> <span class="p">{</span>
  <span class="n">class</span> <span class="n">C</span>
  <span class="n">object</span> <span class="n">X</span> <span class="p">{</span> <span class="n">def</span> <span class="n">f</span> <span class="p">=</span> <span class="n">implicitly</span><span class="p">[</span><span class="n">C</span><span class="p">]</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here, the implicit is supplied in implicit scope of <code class="highlighter-rouge">C</code>.</p>

<h3 id="call-to-action">Call To Action</h3>

<p>Avoid taking this question as being the final arbiter of what is happening.
If you do notice it has become out-of-date, do <a href="https://github.com/scala/docs.scala-lang/issues">open a ticket about it</a>, or, if
you know how to correct it, please fix it.</p>

<p>Related questions of interest:</p>

<ul>
  <li><a href="context-bounds.html">Context bounds</a></li>
  <li><a href="chaining-implicits.html">Chaining implicits</a></li>
</ul>

<p>This question and answer were originally submitted on <a href="http://stackoverflow.com/q/5598085/53013">Stack Overflow</a>.</p>


				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">

      <ul>
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/finding-symbols.html">How do I find what some symbol means or does?</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/yield.html">How does yield work?</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/context-bounds.html">What are Scala context bounds?</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/stream-view-iterator.html">What is the difference between view, stream and iterator?</a></li>
            
            
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/breakout.html">What is breakOut, and how does it work?</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/chaining-implicits.html">How can I chain/nest implicit conversions?</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/finding-implicits.html">Where does Scala look for implicits?</a></li>
            
            <div id="toc"></div>
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/collections.html">How are the collections structured? Which one should I choose?</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/docs.scala-lang.org/tutorials/FAQ/initialization-order.html">Why is my abstract or overridden val null?</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>

      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_overviews/FAQ/finding-implicits.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/docs.scala-lang.org/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/docs.scala-lang.org/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/docs.scala-lang.org/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/docs.scala-lang.org/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/docs.scala-lang.org/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/docs.scala-lang.org/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/docs.scala-lang.org/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/docs.scala-lang.org/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/docs.scala-lang.org/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/docs.scala-lang.org/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/docs.scala-lang.org/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/docs.scala-lang.org/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/docs.scala-lang.org/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/docs.scala-lang.org/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

