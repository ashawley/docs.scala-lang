<!DOCTYPE html>
<html>
  <head>
    <title>Ein Scala Tutorial für Java Programmierer | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
    <link rel="manifest" href="/resources/site.webmanifest">
    <link rel="mask-icon" href="/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/" class="navigation-bdand">
        <img src="/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/books.html">Books</a>
              </li>
            
              <li>
                <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>Ein Scala Tutorial für Java Programmierer</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p>Von Michel Schinz und Philipp Haller.
Deutsche Übersetzung von Christian Krause.</p>

<h2 id="einleitung">Einleitung</h2>

<p>Dieses Tutorial dient einer kurzen Vorstellung der Programmiersprache Scala und deren Compiler. Sie
ist für fortgeschrittene Programmierer gedacht, die sich einen Überblick darüber verschaffen wollen,
wie man mit Scala arbeitet. Grundkenntnisse in Objekt-orientierter Programmierung, insbesondere
Java, werden vorausgesetzt.</p>

<h2 id="das-erste-beispiel">Das erste Beispiel</h2>

<p>Als erstes folgt eine Implementierung des wohlbekannten <em>Hallo, Welt!</em>-Programmes. Obwohl es sehr
einfach ist, eignet es sich sehr gut, Scalas Funktionsweise zu demonstrieren, ohne dass man viel
über die Sprache wissen muss.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object HalloWelt {
  def main(args: Array[String]) {
    println("Hallo, Welt!")
  }
}
</code></pre></div></div>

<p>Die Struktur des Programmes sollte Java Anwendern bekannt vorkommen: es besteht aus einer Methode
namens <code class="highlighter-rouge">main</code>, welche die Kommandozeilenparameter als Feld (Array) von Zeichenketten (String)
übergeben bekommt. Der Körper dieser Methode besteht aus einem einzelnen Aufruf der vordefinierten
Methode <code class="highlighter-rouge">println</code>, die die freundliche Begrüßung als Parameter übergeben bekommt. Weiterhin hat die
<code class="highlighter-rouge">main</code>-Methode keinen Rückgabewert - sie ist also eine Prozedur. Daher ist es auch nicht notwendig,
einen Rückgabetyp zu spezifizieren.</p>

<p>Was Java-Programmierern allerdings weniger bekannt sein sollte, ist die Deklaration <code class="highlighter-rouge">object
HalloWelt</code>, welche die Methode <code class="highlighter-rouge">main</code> enthält. Eine solche Deklaration stellt dar, was gemeinhin als
<em>Singleton Objekt</em> bekannt ist: eine Klasse mit nur einer Instanz. Im Beispiel oben werden also mit
dem Schlüsselwort <code class="highlighter-rouge">object</code> sowohl eine Klasse namens <code class="highlighter-rouge">HalloWelt</code> als auch die dazugehörige,
gleichnamige Instanz definiert. Diese Instanz wird erst bei ihrer erstmaligen Verwendung erstellt.</p>

<p>Dem aufmerksamen Leser ist vielleicht aufgefallen, dass die <code class="highlighter-rouge">main</code>-Methode nicht als <code class="highlighter-rouge">static</code>
deklariert wurde. Der Grund dafür ist, dass statische Mitglieder (Attribute oder Methoden) in Scala
nicht existieren. Die Mitglieder von Singleton Objekten stellen in Scala dar, was Java und andere
Sprachen mit statischen Mitgliedern erreichen.</p>

<h3 id="das-beispiel-kompilieren">Das Beispiel kompilieren</h3>

<p>Um das obige Beispiel zu kompilieren, wird <code class="highlighter-rouge">scalac</code>, der Scala-Compiler verwendet. <code class="highlighter-rouge">scalac</code> arbeitet
wie die meisten anderen Compiler auch: er akzeptiert Quellcode-Dateien als Parameter, einige weitere
Optionen, und übersetzt den Quellcode in Java-Bytecode. Dieser Bytecode wird in ein oder mehrere
Java-konforme Klassen-Dateien, Dateien mit der Endung <code class="highlighter-rouge">.class</code>, geschrieben.</p>

<p>Schreibt man den obigen Quellcode in eine Datei namens <code class="highlighter-rouge">HalloWelt.scala</code>, kann man diese mit dem
folgenden Befehl kompilieren (das größer-als-Zeichen <code class="highlighter-rouge">&gt;</code> repräsentiert die Eingabeaufforderung und
sollte nicht mit geschrieben werden):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; scalac HalloWelt.scala
</code></pre></div></div>

<p>Damit werden einige Klassen-Dateien in das aktuelle Verzeichnis geschrieben. Eine davon heißt
<code class="highlighter-rouge">HalloWelt.class</code> und enthält die Klasse, die direkt mit dem Befehl <code class="highlighter-rouge">scala</code> ausgeführt werden kann,
was im folgenden Abschnitt erklärt wird.</p>

<h3 id="das-beispiel-ausführen">Das Beispiel ausführen</h3>

<p>Sobald kompiliert, kann ein Scala-Programm mit dem Befehl <code class="highlighter-rouge">scala</code> ausgeführt werden. Die Anwendung
ist dem Befehl <code class="highlighter-rouge">java</code>, mit dem man Java-Programme ausführt, nachempfunden und akzeptiert dieselben
Optionen. Das obige Beispiel kann demnach mit folgendem Befehl ausgeführt werden, was das erwartete
Resultat ausgibt:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt; scala -classpath . HalloWelt
Hallo, Welt!
</code></pre></div></div>

<h2 id="interaktion-mit-java">Interaktion mit Java</h2>

<p>Eine Stärke der Sprache Scala ist, dass man mit ihr sehr leicht mit Java interagieren kann. Alle
Klassen des Paketes <code class="highlighter-rouge">java.lang</code> stehen beispielsweise automatisch zur Verfügung, während andere
explizit importiert werden müssen.</p>

<p>Als nächstes folgt ein Beispiel, was diese Interoperabilität demonstriert. Ziel ist es, das aktuelle
Datum zu erhalten und gemäß den Konventionen eines gewissen Landes zu formatieren, zum Beispiel
Frankreich.</p>

<p>Javas Klassen-Bibliothek enthält viele nützliche Klassen, beispielsweise <code class="highlighter-rouge">Date</code> und <code class="highlighter-rouge">DateFormat</code>.
Dank Scala Fähigkeit, nahtlos mit Java zu interoperieren, besteht keine Notwendigkeit, äquivalente
Klassen in der Scala Klassen-Bibliothek zu implementieren - man kann einfach die entsprechenden
Klassen der Java-Pakete importieren:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.{Date, Locale}
import java.text.DateFormat
import java.text.DateFormat._

object FrenchDate {
  def main(args: Array[String]) {
    val now = new Date
    val df = getDateInstance(LONG, Locale.FRANCE)
    println(df format now)
  }
}
</code></pre></div></div>

<p>Scala Import-Anweisung ähnelt sehr der von Java, obwohl sie viel mächtiger ist. Mehrere Klassen des
gleichen Paketes können gleichzeitig importiert werden, indem sie, wie in der ersten Zeile, in
geschweifte Klammern geschrieben werden. Ein weiterer Unterschied ist, dass, wenn man alle
Mitglieder eines Paketes importieren will, einen Unterstrich (<code class="highlighter-rouge">_</code>) anstelle des Asterisk (<code class="highlighter-rouge">*</code>)
verwendet. Der Grund dafür ist, dass der Asterisk ein gültiger Bezeichner in Scala ist,
beispielsweise als Name für Methoden, wie später gezeigt wird. Die Import-Anweisung der dritten
Zeile importiert demnach alle Mitglieder der Klasse <code class="highlighter-rouge">DateFormat</code>, inklusive der statischen Methode
<code class="highlighter-rouge">getDateInstance</code> und des statischen Feldes <code class="highlighter-rouge">LONG</code>.</p>

<p>Innerhalb der <code class="highlighter-rouge">main</code>-Methode wird zuerst eine Instanz der Java-Klasse <code class="highlighter-rouge">Date</code> erzeugt, welche
standardmäßig das aktuelle Datum enthält. Als nächstes wird mithilfe der statischen Methode
<code class="highlighter-rouge">getDateInstance</code> eine Instanz der Klasse <code class="highlighter-rouge">DateFormat</code> erstellt. Schließlich wird das aktuelle Datum
gemäß der Regeln der lokalisierten <code class="highlighter-rouge">DateFormat</code>-Instanz formatiert ausgegeben. Außerdem
veranschaulicht die letzte Zeile eine interessante Fähigkeit Scalas Syntax: Methoden, die nur einen
Parameter haben, können in der Infix-Syntax notiert werden. Dies bedeutet, dass der Ausdruck</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df format now
</code></pre></div></div>

<p>eine andere, weniger verbose Variante des folgenden Ausdruckes ist:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>df.format(now)
</code></pre></div></div>

<p>Dies scheint nur ein nebensächlicher, syntaktischer Zucker zu sein, hat jedoch bedeutende
Konsequenzen, wie im folgenden Abschnitt gezeigt wird.</p>

<p>Um diesen Abschnitt abzuschließen, soll bemerkt sein, dass es außerdem direkt in Scala möglich ist,
von Java-Klassen zu erben sowie Java-Schnittstellen zu implementieren.</p>

<h2 id="alles-ist-ein-objekt">Alles ist ein Objekt</h2>

<p>Scala ist eine pur Objekt-orientierte Sprache, in dem Sinne dass <em>alles</em> ein Objekt ist, Zahlen und
Funktionen eingeschlossen. Der Unterschied zu Java ist, dass Java zwischen primitiven Typen, wie
<code class="highlighter-rouge">boolean</code> und <code class="highlighter-rouge">int</code>, und den Referenz-Typen unterscheidet und es nicht erlaubt ist, Funktionen wie
Werte zu behandeln.</p>

<h3 id="zahlen-sind-objekte">Zahlen sind Objekte</h3>

<p>Zahlen sind Objekte und haben daher Methoden. Tatsächlich besteht ein arithmetischer Ausdruck wie
der folgende</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 + 2 * 3 / x
</code></pre></div></div>

<p>exklusiv aus Methoden-Aufrufen, da es äquivalent zu folgendem Ausdruck ist, wie in vorhergehenden
Abschnitt gezeigt wurde:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1).+(((2).*(3))./(x))
</code></pre></div></div>

<p>Dies bedeutet außerdem, dass <code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">*</code>, etc. in Scala gültige Bezeichner sind.</p>

<p>Die Zahlen umschließenden Klammern der zweiten Variante sind notwendig, weil Scalas lexikalischer
Scanner eine Regel zur längsten Übereinstimmung der Token verwendet. Daher würde der folgende
Ausdruck:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.+(2)
</code></pre></div></div>

<p>in die Token <code class="highlighter-rouge">1.</code>, <code class="highlighter-rouge">+</code>, und <code class="highlighter-rouge">2</code> zerlegt werden. Der Grund für diese Zerlegung ist, dass <code class="highlighter-rouge">1.</code> eine
längere, gültige Übereinstimmung ist, als <code class="highlighter-rouge">1</code>. Daher würde das Token <code class="highlighter-rouge">1.</code> als das Literal <code class="highlighter-rouge">1.0</code>
interpretiert, also als Gleitkommazahl anstatt als Ganzzahl. Den Ausdruck als</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(1).+(2)
</code></pre></div></div>

<p>zu schreiben, verhindert also, dass <code class="highlighter-rouge">1.</code> als Gleitkommazahl interpretiert wird.</p>

<h3 id="funktionen-sind-objekte">Funktionen sind Objekte</h3>

<p>Vermutlich überraschender für Java-Programmierer ist, dass auch Funktionen in Scala Objekte sind.
Daher ist es auch möglich, Funktionen als Parameter zu übergeben, als Werte zu speichern, und von
anderen Funktionen zurückgeben zu lassen. Diese Fähigkeit, Funktionen wie Werte zu behandeln, ist
einer der Grundsteine eines sehr interessanten Programmier-Paradigmas, der <em>funktionalen
Programmierung</em>.</p>

<p>Ein sehr einfaches Beispiel, warum es nützlich sein kann, Funktionen wie Werte zu behandeln, ist
eine Timer-Funktion, deren Ziel es ist, eine gewisse Aktion pro Sekunde durchzuführen. Wie übergibt
man die durchzuführende Aktion? Offensichtlich als Funktion. Diese einfache Art der Übergabe einer
Funktion sollte den meisten Programmieren bekannt vorkommen: dieses Prinzip wird häufig bei
Schnittstellen für Rückruf-Funktionen (call-back) verwendet, die ausgeführt werden, wenn ein
bestimmtes Ereignis eintritt.</p>

<p>Im folgenden Programm akzeptiert die Timer-Funktion <code class="highlighter-rouge">oncePerSecond</code> eine Rückruf-Funktion als
Parameter. Deren Typ wird <code class="highlighter-rouge">() =&gt; Unit</code> geschrieben und ist der Typ aller Funktionen, die keine
Parameter haben und nichts zurück geben (der Typ <code class="highlighter-rouge">Unit</code> ist das Äquivalent zu <code class="highlighter-rouge">void</code>). Die
<code class="highlighter-rouge">main</code>-Methode des Programmes ruft die Timer-Funktion mit der Rückruf-Funktion auf, die einen Satz
ausgibt. In anderen Worten: das Programm gibt endlos den Satz “Die Zeit vergeht wie im Flug.”
einmal pro Sekunde aus.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object Timer {
  def oncePerSecond(callback: () =&gt; Unit) {
    while (true) {
      callback()
      Thread sleep 1000
    }
  }

  def timeFlies() {
    println("Die Zeit vergeht wie im Flug.")
  }

  def main(args: Array[String]) {
    oncePerSecond(timeFlies)
  }
}
</code></pre></div></div>

<p>Weiterhin ist zu bemerken, dass, um die Zeichenkette auszugeben, die in Scala vordefinierte Methode
<code class="highlighter-rouge">println</code> statt der äquivalenten Methode in <code class="highlighter-rouge">System.out</code> verwendet wird.</p>

<h4 id="anonyme-funktionen">Anonyme Funktionen</h4>

<p>Während das obige Programm schon leicht zu verstehen ist, kann es noch verbessert werden. Als erstes
sei zu bemerken, dass die Funktion <code class="highlighter-rouge">timeFlies</code> nur definiert wurde, um der Funktion <code class="highlighter-rouge">oncePerSecond</code>
als Parameter übergeben zu werden. Dieser nur einmal verwendeten Funktion einen Namen zu geben,
scheint unnötig und es wäre angenehmer, sie direkt mit der Übergabe zu erstellen. Dies ist in Scala
mit <em>anonymen Funktionen</em> möglich, die eine Funktion ohne Namen darstellen. Die überarbeitete
Variante des obigen Timer-Programmes verwendet eine anonyme Funktion anstatt der Funktion
<code class="highlighter-rouge">timeFlies</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object TimerAnonymous {
  def oncePerSecond(callback: () =&gt; Unit) {
    while (true) {
      callback()
      Thread sleep 1000
    }
  }

  def main(args: Array[String]) {
    oncePerSecond(() =&gt; println("Die Zeit vergeht wie im Flug."))
  }
}
</code></pre></div></div>

<p>Die anonyme Funktion erkennt man an dem Rechtspfeil <code class="highlighter-rouge">=&gt;</code>, der die Parameter der Funktion von deren
Körper trennt. In diesem Beispiel ist die Liste der Parameter leer, wie man an den leeren Klammern
erkennen kann. Der Körper der Funktion ist derselbe, wie bei der <code class="highlighter-rouge">timeFlies</code> Funktion des
vorangegangenen Beispiels.</p>

<h2 id="klassen">Klassen</h2>

<p>Wie weiter oben zu sehen war, ist Scala eine pur Objekt-orientierte Sprache, und als solche enthält
sie das Konzept von Klassen (der Vollständigkeit halber soll bemerkt sein, dass nicht alle
Objekt-orientierte Sprachen das Konzept von Klassen unterstützen, aber Scala ist keine von denen).
Klassen in Scala werden mit einer ähnlichen Syntax wie Java deklariert. Ein wichtiger Unterschied
ist jedoch, dass Scalas Klassen Argumente haben. Dies soll mit der folgenden Definition von
komplexen Zahlen veranschaulicht werden:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Complex(real: Double, imaginary: Double) {
  def re() = real
  def im() = imaginary
}
</code></pre></div></div>

<p>Diese Klasse akzeptiert zwei Argumente, den realen und den imaginären Teil der komplexen Zahl. Sie
müssen beim Erzeugen einer Instanz der Klasse übergeben werden:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val c = new Complex(1.5, 2.3)
</code></pre></div></div>

<p>Weiterhin enthält die Klasse zwei Methoden, <code class="highlighter-rouge">re</code> und <code class="highlighter-rouge">im</code>, welche als Zugriffsfunktionen (Getter)
dienen. Außerdem soll bemerkt sein, dass der Rückgabe-Typ dieser Methoden nicht explizit deklariert
ist. Der Compiler schlussfolgert ihn automatisch, indem er ihn aus dem rechten Teil der Methoden
ableitet, dass der Rückgabewert vom Typ <code class="highlighter-rouge">Double</code> ist.</p>

<p>Der Compiler ist nicht immer fähig, auf den Rückgabe-Typ zu schließen, und es gibt leider keine
einfache Regel, vorauszusagen, ob er dazu fähig ist oder nicht. In der Praxis stellt das
üblicherweise kein Problem dar, da der Compiler sich beschwert, wenn es ihm nicht möglich ist.
Scala-Anfänger sollten versuchen, Typ-Deklarationen, die leicht vom Kontext abzuleiten sind,
wegzulassen, um zu sehen, ob der Compiler zustimmt. Nach einer gewissen Zeit, bekommt man ein Gefühl
dafür, wann man auf diese Deklarationen verzichten kann und wann man sie explizit angeben sollte.</p>

<h3 id="methoden-ohne-argumente">Methoden ohne Argumente</h3>

<p>Ein Problem der obigen Methoden <code class="highlighter-rouge">re</code> und <code class="highlighter-rouge">im</code> ist, dass man, um sie zu verwenden, ein leeres
Klammerpaar hinter ihren Namen anhängen muss:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object ComplexNumbers {
  def main(args: Array[String]) {
    val c = new Complex(1.2, 3.4)
    println("imaginary part: " + c.im())
  }
}
</code></pre></div></div>

<p>Besser wäre es jedoch, wenn man den realen und imaginären Teil so abrufen könnte, als wären sie
Felder, also ohne das leere Klammerpaar. Mit Scala ist dies möglich, indem Methoden <em>ohne Argumente</em>
definiert werden. Solche Methoden haben keine Klammern nach ihrem Namen, weder bei ihrer Definition
noch bei ihrer Verwendung. Die Klasse für komplexe Zahlen kann demnach folgendermaßen umgeschrieben
werden:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Complex(real: Double, imaginary: Double) {
  def re = real
  def im = imaginary
}
</code></pre></div></div>

<h3 id="vererbung-und-Überschreibung">Vererbung und Überschreibung</h3>

<p>Alle Klassen in Scala erben von einer Oberklasse. Wird keine Oberklasse angegeben, wie bei der
Klasse <code class="highlighter-rouge">Complex</code> des vorhergehenden Abschnittes, wird implizit <code class="highlighter-rouge">scala.AnyRef</code> verwendet.</p>

<p>Außerdem ist es möglich, von einer Oberklasse vererbte Methoden zu überschreiben. Dabei muss jedoch
explizit das Schlüsselwort <code class="highlighter-rouge">override</code> angegeben werden, um versehentliche Überschreibungen zu
vermeiden. Als Beispiel soll eine Erweiterung der Klasse <code class="highlighter-rouge">Complex</code> dienen, die die Methode
<code class="highlighter-rouge">toString</code> neu definiert:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Complex(real: Double, imaginary: Double) {
  def re = real
  def im = imaginary

  override def toString() =
    "" + re + (if (im &lt; 0) "" else "+") + im + "i"
}
</code></pre></div></div>

<h2 id="container-klassen-und-musterabgleiche">Container-Klassen und Musterabgleiche</h2>

<p>Eine Datenstruktur, die häufig in Programmen vorkommt, ist der Baum. Beispielsweise repräsentieren
Interpreter und Compiler Programme intern häufig als Bäume, XML-Dokumente sind Bäume und einige
Container basieren auf Bäumen, wie Rot-Schwarz-Bäume.</p>

<p>Als nächstes wird anhand eines kleinen Programmes für Berechnungen gezeigt, wie solche Bäume in
Scala repräsentiert und manipuliert werden können. Das Ziel dieses Programmes ist, einfache
arithmetische Ausdrücke zu manipulieren, die aus Summen, Ganzzahlen und Variablen bestehen.
Beispiele solcher Ausdrücke sind: <code class="highlighter-rouge">1+2</code> und <code class="highlighter-rouge">(x+x)+(7+y)</code>.</p>

<p>Dafür muss zuerst eine Repräsentation für die Ausdrücke gewählt werden. Die natürlichste ist ein
Baum, dessen Knoten Operationen (Additionen) und dessen Blätter Werte (Konstanten und Variablen)
darstellen.</p>

<p>In Java würde man solche Bäume am ehesten mithilfe einer abstrakten Oberklasse für den Baum und
konkreten Implementierungen für Knoten und Blätter repräsentieren. In einer funktionalen Sprache
würde man algebraische Datentypen mit dem gleichen Ziel verwenden. Scala unterstützt das Konzept
einer Container-Klasse (case class), die einen gewissen Mittelweg dazwischen darstellen. Der
folgenden Quellcode veranschaulicht deren Anwendung:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abstract class Tree
case class Sum(l: Tree, r: Tree) extends Tree
case class Var(n: String) extends Tree
case class Const(v: Int) extends Tree
</code></pre></div></div>

<p>Die Tatsache, dass die Klassen <code class="highlighter-rouge">Sum</code>, <code class="highlighter-rouge">Var</code> und <code class="highlighter-rouge">Const</code> als Container-Klassen deklariert sind,
bedeutet, dass sie sich in einigen Gesichtspunkten von normalen Klassen unterscheiden:</p>

<ul>
  <li>das Schlüsselwort <code class="highlighter-rouge">new</code> ist nicht mehr notwendig, um Instanzen dieser Klassen zu erzeugen (man
kann also <code class="highlighter-rouge">Const(5)</code> anstelle von <code class="highlighter-rouge">new Const(5)</code> schreiben)</li>
  <li>Zugriffsfunktionen werden automatisch anhand der Parameter des Konstruktors erstellt (man kann
den Wert <code class="highlighter-rouge">v</code> einer Instanz <code class="highlighter-rouge">c</code> der Klasse <code class="highlighter-rouge">Const</code> erhalten, indem man <code class="highlighter-rouge">c.v</code> schreibt)</li>
  <li>der Compiler fügt Container-Klassen automatisch Implementierungen der Methoden <code class="highlighter-rouge">equals</code> und
<code class="highlighter-rouge">hashCode</code> hinzu, die auf der <em>Struktur</em> der Klassen basieren, anstelle deren Identität</li>
  <li>außerdem wird eine <code class="highlighter-rouge">toString</code>-Methode bereitgestellt, die einen Wert in Form der Quelle
darstellt (der String-Wert des Baum-Ausdruckes <code class="highlighter-rouge">x+1</code> ist <code class="highlighter-rouge">Sum(Var(x),Const(1))</code>)</li>
  <li>Instanzen dieser Klassen können mithilfe von Musterabgleichen zerlegt werden, wie weiter unten
zu sehen ist</li>
</ul>

<p>Da jetzt bekannt ist, wie die Datenstruktur der arithmetischen Ausdrücke repräsentiert wird, können
jetzt Operationen definiert werden, um diese zu manipulieren. Der Beginn dessen soll eine Funktion
darstellen, die Ausdrücke in einer bestimmten <em>Umgebung</em> auswertet. Das Ziel einer Umgebung ist es,
Variablen Werte zuzuweisen. Beispielsweise wird der Ausdruck <code class="highlighter-rouge">x+1</code> in der Umgebung, die der Variable
<code class="highlighter-rouge">x</code> den Wert <code class="highlighter-rouge">5</code> zuweist, geschrieben als <code class="highlighter-rouge">{ x -&gt; 5 }</code>, mit dem Resultat <code class="highlighter-rouge">6</code> ausgewertet.</p>

<p>Demnach muss ein Weg gefunden werden, solche Umgebungen auszudrücken. Dabei könnte man sich für eine
assoziative Datenstruktur entscheiden, wie eine Hash-Tabelle, man könnte jedoch auch direkt eine
Funktion verwenden. Eine Umgebung ist nicht mehr als eine Funktion, die Werte mit Variablen
assoziiert. Die obige Umgebung <code class="highlighter-rouge">{ x -&gt; 5 }</code> wird in Scala folgendermaßen notiert:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{ case "x" =&gt; 5 }
</code></pre></div></div>

<p>Diese Schreibweise definiert eine Funktion, welche bei dem String <code class="highlighter-rouge">"x"</code> als Argument die Ganzzahl
<code class="highlighter-rouge">5</code> zurückgibt, und in anderen Fällen mit einer Ausnahme fehlschlägt.</p>

<p>Vor dem Schreiben der Funktionen zum Auswerten ist es sinnvoll, für die Umgebungen einen eigenen Typ
zu definieren. Man könnte zwar immer <code class="highlighter-rouge">String =&gt; Int</code> verwenden, es wäre jedoch besser einen
dedizierten Namen dafür zu verwenden, der das Programmieren damit einfacher macht und die Lesbarkeit
erhöht. Dies wird in Scala mit der folgenden Schreibweise erreicht:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>type Environment = String =&gt; Int
</code></pre></div></div>

<p>Von hier an wird <code class="highlighter-rouge">Environment</code> als Alias für den Typ von Funktionen von <code class="highlighter-rouge">String</code> nach <code class="highlighter-rouge">Int</code>
verwendet.</p>

<p>Nun ist alles für die Definition der Funktion zur Auswertung vorbereitet. Konzeptionell ist die
Definition sehr einfach: der Wert der Summe zweier Ausdrücke ist die Summe der Werte der einzelnen
Ausdrücke, der Wert einer Variablen wird direkt der Umgebung entnommen und der Wert einer Konstante
ist die Konstante selbst. Dies in Scala auszudrücken, ist nicht viel schwieriger:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def eval(t: Tree, env: Environment): Int = t match {
  case Sum(l, r) =&gt; eval(l, env) + eval(r, env)
  case Var(n)    =&gt; env(n)
  case Const(v)  =&gt; v
}
</code></pre></div></div>

<p>Diese Funktion zum Auswerten von arithmetischen Ausdrücken nutzt einen <em>Musterabgleich</em> (pattern
matching) am Baumes <code class="highlighter-rouge">t</code>. Intuitiv sollte die Bedeutung der einzelnen Fälle klar sein:</p>

<ol>
  <li>
    <p>Als erstes wird überprüft, ob <code class="highlighter-rouge">t</code> eine Instanz der Klasse <code class="highlighter-rouge">Sum</code> ist. Falls dem so ist, wird der
linke Teilbaum der Variablen <code class="highlighter-rouge">l</code> und der rechte Teilbaum der Variablen <code class="highlighter-rouge">r</code> zugewiesen. Daraufhin
wird der Ausdruck auf der rechten Seite des Pfeiles ausgewertet, der die auf der linken Seite
gebundenen Variablen <code class="highlighter-rouge">l</code> und <code class="highlighter-rouge">r</code> verwendet.</p>
  </li>
  <li>
    <p>Sollte die erste Überprüfung fehlschlagen, also <code class="highlighter-rouge">t</code> ist keine <code class="highlighter-rouge">Sum</code>, wird der nächste Fall
abgehandelt und überprüft, ob <code class="highlighter-rouge">t</code> eine <code class="highlighter-rouge">Var</code> ist. Ist dies der Fall, wird analog zum ersten Fall der
Wert an <code class="highlighter-rouge">n</code> gebunden und der Ausdruck rechts vom Pfeil ausgewertet.</p>
  </li>
  <li>
    <p>Schlägt auch die zweite Überprüfung fehl, also <code class="highlighter-rouge">t</code> ist weder <code class="highlighter-rouge">Sum</code> noch <code class="highlighter-rouge">Val</code>, wird überprüft,
ob es eine Instanz des Typs <code class="highlighter-rouge">Const</code> ist. Analog wird bei einem Erfolg wie bei den beiden
vorangegangenen Fällen verfahren.</p>
  </li>
  <li>
    <p>Schließlich, sollten alle Überprüfungen fehlschlagen, wird eine Ausnahme ausgelöst, die
signalisiert, dass der Musterabgleich nicht erfolgreich war. Dies wird unweigerlich geschehen,
sollten neue Baum-Unterklassen erstellt werden.</p>
  </li>
</ol>

<p>Die prinzipielle Idee eines Musterabgleiches ist, einen Wert anhand einer Reihe von Mustern
abzugleichen und, sobald ein Treffer erzielt wird, Werte zu extrahieren, mit denen darauf
weitergearbeitet werden kann.</p>

<p>Erfahrene Objekt-orientierte Programmierer werden sich fragen, warum <code class="highlighter-rouge">eval</code> nicht als Methode der
Klasse <code class="highlighter-rouge">Tree</code> oder dessen Unterklassen definiert wurde. Dies wäre möglich, da Container-Klassen
Methoden definieren können, wie normale Klassen auch. Die Entscheidung, einen Musterabgleich oder
Methoden zu verwenden, ist Geschmackssache, hat jedoch wichtige Auswirkungen auf die
Erweiterbarkeit:</p>

<ul>
  <li>einerseits ist es mit Methoden einfach, neue Arten von Knoten als Unterklassen von <code class="highlighter-rouge">Tree</code>
hinzuzufügen, andererseits ist die Ergänzung einer neuen Operation zur Manipulation des Baumes
mühsam, da sie die Modifikation aller Unterklassen von <code class="highlighter-rouge">Tree</code> erfordert</li>
  <li>nutzt man einen Musterabgleich kehrt sich die Situation um: eine neue Art von Knoten erfordert
die Modifikation aller Funktionen die einen Musterabgleich am Baum vollführen, wogegen eine neue
Operation leicht hinzuzufügen ist, indem einfach eine unabhängige Funktion dafür definiert wird</li>
</ul>

<p>Einen weiteren Einblick in Musterabgleiche verschafft eine weitere Operation mit arithmetischen
Ausdrücken: partielle Ableitungen. Dafür gelten zur Zeit folgende Regeln:</p>

<ol>
  <li>die Ableitung einer Summe ist die Summe der Ableitungen</li>
  <li>die Ableitung einer Variablen ist eins, wenn sie die abzuleitende Variable ist, ansonsten <code class="highlighter-rouge">0</code></li>
  <li>die Ableitung einer Konstanten ist <code class="highlighter-rouge">0</code></li>
</ol>

<p>Auch diese Regeln können fast wörtlich in Scala übersetzt werden:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def derive(t: Tree, v: String): Tree = t match {
  case Sum(l, r) =&gt; Sum(derive(l, v), derive(r, v))
  case Var(n) if (v == n) =&gt; Const(1)
  case _ =&gt; Const(0)
}
</code></pre></div></div>

<p>Diese Funktion führt zwei neue, mit dem Musterabgleich zusammenhängende Konzepte ein. Der zweite,
sich auf eine Variable beziehende Fall hat eine <em>Sperre</em> (guard), einen Ausdruck, der dem
Schlüsselwort <code class="highlighter-rouge">if</code> folgt. Diese Sperre verhindert eine Übereinstimmung, wenn der Ausdruck falsch
ist. In diesem Fall wird sie genutzt, die Konstante <code class="highlighter-rouge">1</code> nur zurückzugeben, wenn die Variable die
abzuleitende ist. Die zweite Neuerung ist der <em>Platzhalter</em> <code class="highlighter-rouge">_</code>, der mit allem übereinstimmt, jedoch
ohne einen Namen dafür zu verwenden.</p>

<p>Die volle Funktionalität von Musterabgleichen wurde mit diesen Beispielen nicht demonstriert, doch
soll dies fürs Erste genügen. Eine Vorführung der beiden Funktionen an realen Beispielen steht immer
noch aus. Zu diesem Zweck soll eine <code class="highlighter-rouge">main</code>-Methode dienen, die den Ausdruck <code class="highlighter-rouge">(x+x)+(7+y)</code> als
Beispiel verwendet: zuerst wird der Wert in der Umgebung <code class="highlighter-rouge">{ x -&gt; 5, y -&gt; 7 }</code> berechnet und darauf
die beiden partiellen Ableitungen gebildet:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def main(args: Array[String]) {
  val exp: Tree = Sum(Sum(Var("x"),Var("x")),Sum(Const(7),Var("y")))
  val env: Environment = {
    case "x" =&gt; 5
    case "y" =&gt; 7
  }
  println("Ausdruck: " + exp)
  println("Auswertung mit x=5, y=7: " + eval(exp, env))
  println("Ableitung von x:\n " + derive(exp, "x"))
  println("Ableitung von y:\n " + derive(exp, "y"))
}
</code></pre></div></div>

<p>Führt man das Programm aus, erhält man folgende Ausgabe:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ausdruck: Sum(Sum(Var(x),Var(x)),Sum(Const(7),Var(y)))
Auswertung mit x=5, y=7: 24
Ableitung von x:
 Sum(Sum(Const(1),Const(1)),Sum(Const(0),Const(0)))
Ableitung von y:
 Sum(Sum(Const(0),Const(0)),Sum(Const(0),Const(1)))
</code></pre></div></div>

<p>Beim Anblick dieser Ausgabe ist offensichtlich, dass man die Ergebnisse der Ableitungen noch
vereinfachen sollte. Eine solche Funktion zum Vereinfachen von Ausdrücken, die Musterabgleiche
nutzt, ist ein interessantes, aber gar nicht so einfaches Problem, was als Übung offen steht.</p>

<h2 id="traits">Traits</h2>

<p>Neben dem Vererben von Oberklassen ist es in Scala auch möglich von mehreren, sogenannten <em>Traits</em>
zu erben. Der beste Weg für einen Java-Programmierer einen Trait zu verstehen, ist sich eine
Schnittstelle vorzustellen, die Implementierungen enthält. Wenn in Scala eine Klasse von einem Trait
erbt, implementiert sie dessen Schnittstelle und erbt dessen Implementierungen.</p>

<p>Um die Nützlichkeit von Traits zu demonstrieren, werden wir ein klassisches Beispiel implementieren:
Objekte mit einer natürlichen Ordnung oder Rangfolge. Es ist häufig hilfreich, Instanzen einer
Klasse untereinander vergleichen zu können, um sie beispielsweise sortieren zu können. In Java
müssen die Klassen solcher Objekte die Schnittstelle <code class="highlighter-rouge">Comparable</code> implementieren. In Scala kann dies
mit einer äquivalenten, aber besseren Variante von <code class="highlighter-rouge">Comparable</code> als Trait bewerkstelligt werden, die
im Folgenden <code class="highlighter-rouge">Ord</code> genannt wird.</p>

<p>Wenn Objekte verglichen werden, sind sechs verschiedene Aussagen sinnvoll: kleiner, kleiner gleich,
gleich, ungleich, größer, und größer gleich. Allerdings ist es umständlich, immer alle sechs
Methoden dafür zu implementieren, vor allem in Anbetracht der Tatsache, dass vier dieser sechs durch
die verbliebenen zwei ausgedrückt werden können. Sind beispielsweise die Aussagen für gleich und
kleiner gegeben, kann man die anderen damit ausdrücken. In Scala können diese Beobachtungen mit
dem folgenden Trait zusammengefasst werden:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>trait Ord {
  def &lt; (that: Any): Boolean
  def &lt;=(that: Any): Boolean =  (this &lt; that) || (this == that)
  def &gt; (that: Any): Boolean = !(this &lt;= that)
  def &gt;=(that: Any): Boolean = !(this &lt; that)
}
</code></pre></div></div>

<p>Diese Definition erzeugt sowohl einen neuen Typ namens <code class="highlighter-rouge">Ord</code>, welcher dieselbe Rolle wie Javas
Schnittstelle <code class="highlighter-rouge">Comparable</code> spielt, und drei vorgegebenen Funktionen, die auf einer vierten,
abstrakten basieren. Die Methoden für Gleichheit und Ungleichheit erscheinen hier nicht, da sie
bereits in allen Objekten von Scala vorhanden sind.</p>

<p>Der Typ <code class="highlighter-rouge">Any</code>, welcher oben verwendet wurde, stellt den Ober-Typ aller Typen in Scala dar. Er kann
als noch allgemeinere Version von Javas <code class="highlighter-rouge">Object</code> angesehen werden, da er außerdem Ober-Typ der
Basis-Typen wie <code class="highlighter-rouge">Int</code> und <code class="highlighter-rouge">Float</code> ist.</p>

<p>Um Objekte einer Klasse vergleichen zu können, ist es also hinreichend, Gleichheit und die
kleiner-als-Beziehung zu implementieren, und dieses Verhalten gewissermaßen mit der eigentlichen
Klasse zu vermengen (mix in). Als Beispiel soll eine Klasse für Datumsangaben dienen, die Daten
eines gregorianischen Kalenders repräsentiert. Solche Daten bestehen aus Tag, Monat und Jahr, welche
durch Ganzzahlen dargestellt werden:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Date(y: Int, m: Int, d: Int) extends Ord {
  def year  = y
  def month = m
  def day   = d

  override def toString = year + "-" + month + "-" + day
</code></pre></div></div>

<p>Der wichtige Teil dieser Definition ist die Deklaration <code class="highlighter-rouge">extends Ord</code>, welche dem Namen der Klasse
und deren Parametern folgt. Sie sagt aus, dass <code class="highlighter-rouge">Date</code> vom Trait <code class="highlighter-rouge">Ord</code> erbt.</p>

<p>Nun folgt eine Re-Implementierung der Methode <code class="highlighter-rouge">equals</code>, die von <code class="highlighter-rouge">Object</code> geerbt wird, so dass die
Daten korrekt nach ihren Feldern verglichen werden. Die vorgegebene Implementierung von <code class="highlighter-rouge">equals</code> ist
dafür nicht nützlich, da in Java Objekte physisch, also nach deren Adressen im Speicher, verglichen
werden. Daher verwenden wir folgende Definition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  override def equals(that: Any): Boolean =
    that.isInstanceOf[Date] &amp;&amp; {
      val o = that.asInstanceOf[Date]
      o.day == day &amp;&amp; o.month == month &amp;&amp; o.year == year
    }
</code></pre></div></div>

<p>Diese Methode verwendet die vordefinierten Methoden <code class="highlighter-rouge">isInstanceOf</code> und <code class="highlighter-rouge">asInstanceOf</code>. Erstere
entspricht Javas <code class="highlighter-rouge">instanceof</code>-Operator und gibt <code class="highlighter-rouge">true</code> zurück, wenn das zu testende Objekt eine
Instanz des angegebenen Typs ist. Letztere entspricht Javas Operator für Typ-Umwandlungen (cast):
ist das Objekt eine Instanz des angegebenen Typs, kann es als solcher angesehen und gehandhabt
werden, ansonsten wird eine <code class="highlighter-rouge">ClassCastException</code> ausgelöst.</p>

<p>Schließlich kann die letzte Methode definiert werden, die für <code class="highlighter-rouge">Ord</code> notwendig ist, und die
kleiner-als-Beziehung implementiert. Diese nutzt eine andere, vordefinierte Methode, namens <code class="highlighter-rouge">error</code>,
des Paketes <code class="highlighter-rouge">sys</code>, welche eine <code class="highlighter-rouge">RuntimeException</code> mit der angegebenen Nachricht auslöst.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def &lt;(that: Any): Boolean = {
    if (!that.isInstanceOf[Date])
      sys.error("cannot compare " + that + " and a Date")

    val o = that.asInstanceOf[Date]
    (year &lt; o.year) ||
    (year == o.year &amp;&amp; (month &lt; o.month ||
                       (month == o.month &amp;&amp; day &lt; o.day)))
  }
}
</code></pre></div></div>

<p>Diese Methode vervollständigt die Definition der <code class="highlighter-rouge">Date</code>-Klasse. Instanzen dieser Klasse stellen
sowohl Daten als auch vergleichbare Objekte dar. Vielmehr implementiert diese Klasse alle sechs
Methoden, die für das Vergleichen von Objekten notwendig sind: <code class="highlighter-rouge">equals</code> und <code class="highlighter-rouge">&lt;</code>, die direkt in der
Definition von <code class="highlighter-rouge">Date</code> vorkommen, sowie die anderen, in dem Trait <code class="highlighter-rouge">Ord</code> definierten Methoden.</p>

<p>Traits sind nützlich in Situationen wie der obigen, den vollen Funktionsumfang hier zu zeigen, würde
allerdings den Rahmen dieses Dokumentes sprengen.</p>

<h2 id="generische-programmierung">Generische Programmierung</h2>

<p>Eine weitere Charakteristik Scalas, die in diesem Tutorial vorgestellt werden soll, behandelt das
Konzept der generischen Programmierung. Java-Programmierer, die die Sprache noch vor der Version 1.5
kennen, sollten mit den Problemen vertraut sein, die auftreten, wenn generische Programmierung nicht
unterstützt wird.</p>

<p>Generische Programmierung bedeutet, Quellcode nach Typen zu parametrisieren. Beispielsweise stellt
sich die Frage für einen Programmierer bei der Implementierung einer Bibliothek für verkettete
Listen, welcher Typ für die Elemente verwendet werden soll. Da diese Liste in verschiedenen
Zusammenhängen verwendet werden soll, ist es nicht möglich, einen spezifischen Typ, wie <code class="highlighter-rouge">Int</code>, zu
verwenden. Diese willkürliche Wahl wäre sehr einschränkend.</p>

<p>Aufgrund dieser Probleme griff man in Java vor der Einführung der generischen Programmierung zu dem
Mittel, <code class="highlighter-rouge">Object</code>, den Ober-Typ aller Typen, als Element-Typ zu verwenden. Diese Lösung ist
allerdings auch weit entfernt von Eleganz, da sie sowohl ungeeignet für die Basis-Typen, wie <code class="highlighter-rouge">int</code>
oder <code class="highlighter-rouge">float</code>, ist, als auch viele explizite Typ-Umwandlungen für den nutzenden Programmierer
bedeutet.</p>

<p>Scala ermöglicht es, generische Klassen und Methoden zu definieren, um diesen Problemen aus dem Weg
zu gehen. Für die Demonstration soll ein einfacher, generischer Container als Referenz-Typ dienen,
der leer sein kann, oder auf ein Objekt des generischen Typs zeigt:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Reference[T] {
  private var contents: T = _

  def get: T = contents

  def set(value: T) {
    contents = value
  }
}
</code></pre></div></div>

<p>Die Klasse <code class="highlighter-rouge">Reference</code> ist anhand des Types <code class="highlighter-rouge">T</code> parametrisiert, der den Element-Typ repräsentiert.
Dieser Typ wird im Körper der Klasse genutzt, wie bei dem Feld <code class="highlighter-rouge">contents</code>. Dessen Argument wird
durch die Methode <code class="highlighter-rouge">get</code> abgefragt und mit der Methode <code class="highlighter-rouge">set</code> verändert.</p>

<p>Der obige Quellcode führt veränderbare Variablen in Scala ein, welche keiner weiteren Erklärung
erfordern sollten. Schon interessanter ist der initiale Wert dieser Variablen, der mit <code class="highlighter-rouge">_</code>
gekennzeichnet wurde. Dieser Standardwert ist für numerische Typen <code class="highlighter-rouge">0</code>, <code class="highlighter-rouge">false</code> für Wahrheitswerte,
<code class="highlighter-rouge">()</code> für den Typ <code class="highlighter-rouge">Unit</code> und <code class="highlighter-rouge">null</code> für alle anderen Typen.</p>

<p>Um diese Referenz-Klasse zu verwenden, muss der generische Typ bei der Erzeugung einer Instanz
angegeben werden. Für einen Ganzzahl-Container soll folgendes Beispiel dienen:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object IntegerReference {
  def main(args: Array[String]) {
    val cell = new Reference[Int]
    cell.set(13)
    println("Reference contains the half of " + (cell.get * 2))
  }
}
</code></pre></div></div>

<p>Wie in dem Beispiel zu sehen ist, muss der Wert, der von der Methode <code class="highlighter-rouge">get</code> zurückgegeben wird, nicht
umgewandelt werden, wenn er als Ganzzahl verwendet werden soll. Es wäre außerdem nicht möglich,
einen Wert, der keine Ganzzahl ist, in einem solchen Container zu speichern, da er speziell und
ausschließlich für Ganzzahlen erzeugt worden ist.</p>

<h2 id="zusammenfassung">Zusammenfassung</h2>

<p>Dieses Dokument hat einen kurzen Überblick über die Sprache Scala gegeben und dazu einige einfache
Beispiele verwendet. Interessierte Leser können beispielsweise mit dem Dokument <em>Scala by Example</em>
fortfahren, welches fortgeschrittenere Beispiele enthält, und die <em>Scala Language Specification</em>
konsultieren, sofern nötig.</p>

				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">
      <div id="toc"></div>
      
         
         
        <ul id="available-languages" style="display: none;">
          <li><a href="/tutorials/scala-for-java-programmers.html">English</a></li>
          
            
            <li><a href="/es/tutorials/scala-for-java-programmers.html" class="lang">Español</a></li>
          
            
            <li><a href="/ko/tutorials/scala-for-java-programmers.html" class="lang">한국어</a></li>
          
            
            <li><a href="/de/tutorials/scala-for-java-programmers.html" class="lang">Deutsch</a></li>
          
            
            <li><a href="/it/tutorials/scala-for-java-programmers.html" class="lang">Italiano</a></li>
          
            
            <li><a href="/zh-tw/tutorials/scala-for-java-programmers.html" class="lang">中文 (繁體)</a></li>
          
        </ul>
      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_de/tutorials/scala-for-java-programmers.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

