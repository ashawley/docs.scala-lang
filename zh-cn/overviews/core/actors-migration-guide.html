<!DOCTYPE html>
<html>
  <head>
    <title>Scala Actors迁移指南 | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
    <link rel="manifest" href="/resources/site.webmanifest">
    <link rel="mask-icon" href="/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/" class="navigation-bdand">
        <img src="/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/books.html">Books</a>
              </li>
            
              <li>
                <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>Scala Actors迁移指南</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p><strong>Vojin Jovanovic 和 Philipp Haller 著</strong></p>

<h2 id="概述">概述</h2>

<p>从Scala的2.11.0版本开始，Scala的Actors库已经过时了。早在Scala2.10.0的时候，默认的actor库即是Akka。</p>

<p>为了方便的将Scala Actors迁移到Akka，我们提供了Actor迁移工具包（AMK）。通过在一个项目的类路径中添加scala-actors-migration.jar，AMK包含了一个针对Scala Actors扩展。此外，Akka 2.1包含一些特殊功能，比如ActorDSL singleton，可以实现更简单的转换功能，使Scala Actors代码变成Akka代码。本章内容的目的是用来指导用户完成迁移过程，并解释如何使用AMK。</p>

<p>本指南包括以下内容：在“迁移工具的局限性”章节中，我们在此概述了迁移工具的主要局限性。在“迁移概述”章节中我们描述了迁移过程和谈论了Scala的变化分布，使得迁移成为一种可能。最后，在“一步一步指导迁移到Akka”章节里，我们展示了一些迁移工作的例子，以及各个步骤，如果需要从Scala Actors迁移至Akka’s actors，本节是推荐阅读的。</p>

<p>免责声明:并发代码是臭名昭著的，当出现bug时很难调试和修复。由于两个actor的不同实现，这种差异导致可能出现错误。迁移过程每一步后都建议进行完全的代码测试。</p>

<h2 id="迁移工具的局限性">迁移工具的局限性</h2>

<p>由于Akka和Scala的actor模型的完整功能不尽相同导致两者之间不能平滑地迁移。下面的列表解释了很难迁移的部分行为：</p>

<ol>
  <li>
    <p>依靠终止原因和双向行为链接方法 - Scala和Akka actors有不同的故障处理和actor monitoring模型。在Scala actors模型中，如果一个相关联部分异常终止，相关联的actors终止。如果终止是显式跟踪(通过self.trapExit)，actor可以从失败的actor收到终止的原因。通过Akka这个功能不能迁移到AMK。AMK允许迁移的只是<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html#What_Lifecycle_Monitoring_Means">Akka monitoring</a>机制。Monitoring不同于连接,因为它是单向(unindirectional)的并且终止的原因是现在已知的。如果仅仅是monitoring机制是无法满足需求的,迁移的链接必须推迟到最后一刻(步骤5的迁移)。然后,当迁移到Akka,用户必须创建一个<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html">监督层次(supervision hierarchy)</a>,处理故障。</p>
  </li>
  <li>
    <p>使用restart方法——Akka不提供显式的重启actors，因此上述例子我们不能提供平滑迁移。用户必须更改系统,所以没有使用重启方法(restart method)。</p>
  </li>
  <li>
    <p>使用getState方法 - Akka actors没有显式状态,此功能无法迁移。用户代码必须没有getState调用。</p>
  </li>
  <li>
    <p>实例化后没有启动actors - Akka actors模型会在实例化后自动启动actors，所以用户不需要重塑系统来显式的在实例化后启动actors。</p>
  </li>
  <li>
    <p>mailboxSize方法不存在Akka中,因此不能迁移。这种方法很少使用,很容易被删除。</p>
  </li>
</ol>

<h2 id="迁移概述">迁移概述</h2>

<h3 id="迁移工具">迁移工具</h3>

<p>在Scal 2.10.0 actors 是在<a href="http://www.scala-lang.org/downloads">Scala distribution</a>中作为一个单独包（scala-actors.jar）存在的，并且他们的接口已被弃用。这种分布也包含在Akka actors的akka-actor.jar里。AMK同时存在Scala actors 和 akka-actor.jar之中。未来的主要版本的Scala将不包含Scala actors和AMK。</p>

<p>开始迁移，用户需要添加scala-actors.jar和scala-actors-migration.jar来构建他们的项目。添加scala-actors.jar和scala-actors-migration.jar允许使用下面描述的AMK。这些jar位于Scala Tools库和<a href="http://www.scala-lang.org/downloads">Scala distribution</a>库中。</p>

<h3 id="一步一步来迁移">一步一步来迁移</h3>

<p>Actor迁移工具使用起来应该有5步骤。每一步都设计为引入的基于代码的最小变化。在前四个迁移步骤的代码中将使用Scala actors来实现，并在该步完成后运行所有的系统测试。然而,方法和类的签名将被转换为与Akka相似。迁移工具在Scal方面引入了一种新的actor类型（ActWithStash）和强制执行actors的ActorRef接口。</p>

<p>该结果同样强制通过一个特殊的方法在ActorDSL 对象上创建actors。在这些步骤可以每次迁移一个actor。这降低了在同一时刻引入多个bug的可能性，同样降低了bug的复杂程度。</p>

<p>在Scala方面迁移完成后，用户应该改变import语句并变成使用Akka库。在Akka方面，ActorDSL和ActWithStash允许对Scala Actors和他们的生态系的react construct进行建模。这个步骤迁移所有actors到Akka的后端，会在系统中引入bug。一旦代码迁移到Akka,用户将能够使用Akka的所有的功能的。</p>

<h3 id="一步一步指导迁移到akka">一步一步指导迁移到Akka</h3>

<p>在这一章中,我们将通过actor迁移的5个步骤。在每一步之后的代码都要为可能的错误进行检测。在前4个步骤中可以一边迁移一个actor和一边测试功能。然而,最后一步迁移所有actors到Akka后它只能作为一个整体进行测试。在这个步骤之后系统应该具有和之前一样相同的功能，不过它将使用Akka actor库。</p>

<h3 id="步骤1万物皆是actor">步骤1——万物皆是Actor</h3>

<p>Scala actors库提供了公共访问多个类型的actors。他们被组织在类层次结构和每个子类提供了稍微更丰富的功能。为了进一步的使迁移步骤更容易，我们将首先更改Actor类型系统中的每一个actor。这种迁移步骤很简单，因为Actor类位于层次结构的底部，并提供了广泛的功能。</p>

<p>来自Scala库的Actors应根据以下规则进行迁移：</p>

<ol>
  <li>class MyServ extends Reactor[T] -&gt; class MyServ extends Actor</li>
</ol>

<p>注意,反应器提供了一个额外的类型参数代表了类型的消息收到。如果用户代码中使用这些信息，那么一个需要：i）应用模式匹配与显式类型,或者ii）做一个向下的消息来自任何泛型T。</p>

<ol>
  <li>
    <p>class MyServ extends ReplyReactor -&gt; class MyServ extends Actor</p>
  </li>
  <li>
    <p>class MyServ extends DaemonActor -&gt; class MyServ extends Actor</p>
  </li>
</ol>

<p>为了为DaemonActor提供配对功能，将下列代码添加到类的定义。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def scheduler: IScheduler = DaemonScheduler
</code></pre></div></div>

<h3 id="步骤2---实例化">步骤2 - 实例化</h3>

<p>在Akka中,actors可以访问只有通过ActorRef接口。ActorRef的实例可以通过在ActorDSL对象上调用actor方法或者通过调用ActorRefFactory实例的actorOf方法来获得。在Scala的AMK工具包中，我们提供了Akka ActorRef和ActorDSL的一个子集，该子集实际上是Akka库的一个单例对象(singleton object)。</p>

<p>这一步的迁移使所有actors访问通过ActorRefs。首先，我们现实如何迁移普通模式的实例化Sacla Actors。然后，我们将展示如何分别克服问题的ActorRef和Actor的不同接口。</p>

<h4 id="actor实例化">Actor实例化</h4>

<p>actor实例的转换规则（以下规则需要import scala.actors.migration._）：</p>

<ol>
  <li>
    <p>构造器调用实例化</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> val myActor = new MyActor(arg1, arg2)
 myActor.start()
</code></pre></div>    </div>
  </li>
</ol>

<p>应该被替换</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActorDSL.actor(new MyActor(arg1, arg2))
</code></pre></div></div>

<ol>
  <li>
    <p>用于创建Actors的DSL(译注：领域专用语言(Domain Specific Language))</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> val myActor = actor {
   // actor 定义
 } 应该被替换

 val myActor = ActorDSL.actor(new Actor {
    def act() {
      // actor 定义
    }
 })
</code></pre></div>    </div>
  </li>
  <li>
    <p>从Actor Trait扩展来的对象</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> object MyActor extends Actor {
   // MyActor 定义
 }
 MyActor.start() 应该被替换

 class MyActor extends Actor {
   // MyActor 定义
 }

 object MyActor {
   val ref = ActorDSL.actor(new MyActor)
 } 所有的MyActor地想都应该被替换成MyActor.ref。
</code></pre></div>    </div>
  </li>
</ol>

<p>需要注意的是Akka actors在实例化的同时开始运行。actors创建并开始在迁移的系统的情况下，actors在不同的位置以及改变这可能会影响系统的行为，用户需要更改代码，以使得actors在实例化后立即开始执行。</p>

<p>远程actors也需要被获取作为ActorRefs。为了得到一个远程actor ActorRef需使用方法selectActorRef。</p>

<h4 id="不同的方法签名signatures">不同的方法签名(signatures)</h4>

<p>至此为止我们已经改变了所有的actor实例化，返回ActorRefs，然而，我们还没有完成迁移工作。有不同的接口在ActorRefs和Actors中，因此我们需要改变在每个迁移实例上触发的方法。不幸的是，Scala Actors提供的一些方法不能迁移。对下列方法的用户需要找到一个解决方案:</p>

<ol>
  <li>
    <p>getState()——Akka中的actors 默认情况下由其监管actors(supervising actors)负责管理和重启。在这种情况下,一个actor的状态是不相关的。</p>
  </li>
  <li>
    <p>restart() - 显式的重启一个Scala actor。在Akka中没有相应的功能。</p>
  </li>
</ol>

<p>所有其他Actor方法需要转换为两个ActorRef中的方法。转换是通过下面描述的规则。请注意,所有的规则需要导入以下内容:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent.duration._
import scala.actors.migration.pattern.ask
import scala.actors.migration._
import scala.concurrent._ 额外规则1-3的作用域定义在无限的时间需要一个隐含的超时。然而，由于Akka不允许无限超时，我们会使用100年。例如：

implicit val timeout = Timeout(36500 days)
</code></pre></div></div>

<p>规则：</p>

<ol>
  <li>
    <p>!!(msg: Any): Future[Any] 被？替换。这条规则会改变一个返回类型到scala.concurrent.Future这可能导致类型不匹配。由于scala.concurrent.Future比过去的返回值具有更广泛的功能，这种类型的错误可以很容易地固定在与本地修改：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> actor !! message -&gt; respActor ? message
</code></pre></div>    </div>
  </li>
  <li>
    <p>!![A] (msg: Any, handler: PartialFunction[Any, A]): Future[A] 被？取代。处理程序可以提取作为一个单独的函数，并用来生成一个future对象结果。处理的结果应给出另一个future对象结果,就像在下面的例子:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> val handler: PartialFunction[Any, T] = ... // handler
 actor !! (message, handler) -&gt; (respActor ? message) map handler
</code></pre></div>    </div>
  </li>
  <li>
    <p>!? (msg: Any):任何被？替换都将阻塞在返回的future对象上</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> actor !? message -&gt;
   Await.result(respActor ? message, Duration.Inf)
</code></pre></div>    </div>
  </li>
  <li>
    <p>!? (msec: Long, msg: Any): Option[Any]任何被？替换都将显式的阻塞在future对象</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> actor !? (dur, message) -&gt;
   val res = respActor.?(message)(Timeout(dur milliseconds))
   val optFut = res map (Some(_)) recover { case _ =&gt; None }
   Await.result(optFut, Duration.Inf)
</code></pre></div>    </div>
  </li>
</ol>

<p>这里没有提到的公共方法是为了actors DSL被申明为公共的。他们只能在定义actor时使用，所以他们的这一步迁移是不相关的。</p>

<p>###第3步 -  从Actor 到 ActWithStash</p>

<p>到目前为止，所有的控制器都继承自Actor trait。我们通过指定的工厂方法来实例化控制器，所有的控制器都可以通过接口ActorRef 来进行访问。现在我们需要把所有的控制器迁移的AMK 的 ActWithStash 类上。这个类的行为方式和Scala的Actor几乎完全一致，它提供了另外一些方法，对应于Akka的Actor trait。这使得控制器更易于逐步的迁移到Akka。</p>

<p>为了达到这个目的，所有的从Actor继承的类，按照下列的方式，需要改为继承自ActWithStash：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MyActor extends Actor -&gt; class MyActor extends ActWithStash
</code></pre></div></div>

<p>经过这样修改以后，代码会无法通过编译。因为ActWithStash中的receive 方法不能在act中像原来那样使用。要使代码通过编译，需要在所有的 receive 调用中加上类型参数。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  receive { case x: Int =&gt; "Number" } -&gt;
    receive[String] { case x: Int =&gt; "Number" }
</code></pre></div></div>

<p>另外，要使代码通过编译，还要在act方法前加上 override关键字，并且定义一个空的receive方法。act方法需要被重写，因为它在ActWithStash 的实现中模拟了Akka的消息处理循环。需要修改的地方请看下面的例子：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  class MyActor extends ActWithStash {

     // 空的 receive 方法 (现在还没有用)
     def receive = {case _ =&gt; }

     override def act() {
       // 原来代码中的 receive 方法改为 react。
     }
  } ActWithStash 的实例中，变量trapExit 的缺省值是true。如果希望改变，可以在初始化方法中把它设置为false。
</code></pre></div></div>

<p>远程控制器在ActWithStash 下无法直接使用，register(‘name, this)方法需要被替换为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	registerActorRef('name, self)
</code></pre></div></div>

<p>在后面的步骤中， registerActorRef 和 alive 方法的调用与其它方法一样。</p>

<p>现在，用户可以测试运行，整个系统的运行会和原来一样。ActWithStash 和Actor 拥有相同的基本架构，所以系统的运行会与原来没有什么区别。</p>

<h3 id="第4步---去掉act-方法">第4步 - 去掉act 方法</h3>

<p>在这一节，我们讨论怎样从ActWithStash中去掉act方法，以及怎样修改其他方法，使它与Akka更加契合. 这一环节会比较繁杂，所以我们建议最好一次只修改一个控制器。在Scala中，控制器的行为主要是在act方法的中定义。逻辑上来说，控制器是一个并发执行act方法的过程，执行完成后过程终止。在Akka中，控制器用一个全局消息处理器来依次处理它的的消息队列中的消息。这个消息处理器是一个receive函数返回的偏函数(partial function)，该偏函数被应用与每一条消息上。</p>

<p>因为ActWithStash中Akka方法的行为依赖于移除的act方法，所以我们首先要做的是去掉act方法。然后，我们需要按照给定的规则修改scala.actors.Actor中每个方法的。</p>

<h4 id="怎样去除act-方法">怎样去除act 方法</h4>

<p>在下面的列表中，我们给出了通用消息处理模式的修改规则。这个列表并不包含所有的模式，它只是覆盖了其中一些通用的模式。然而用户可以通过参考这些规则，通过扩展简单规则，将act方法移植到Akka。</p>

<p>嵌套调用react/reactWithin需要注意：消息处理偏函数需要做结构扩展，使它更接近Akka模式。尽管这种修改会很复杂，但是它允许任何层次的嵌套被移植。下面有相关的例子。</p>

<p>在复杂控制流中使用receive/receiveWithin需要注意：这个移植会比较复杂，因为它要求重构act方法。在消息处理偏函数中使用react 和 andThen可以使receive的调用模型化。下面是一些简单的例子。</p>

<ol>
  <li>
    <p>如果在act方法中有一些代码在第一个包含react的loop之前被执行，那么这些代码应该被放在preStart方法中。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def act() {
   //初始化的代码放在这里
   loop {
     react { ... }
   }
 } 应该被替换
</code></pre></div>    </div>

    <p>override def preStart() {
     //初始化的代码放在这里
   }</p>

    <p>def act() {
     loop {
       react{ … }
     }
   }
其他的模式，如果在第一个react 之前有一些代码，也可以使用这个规则。</p>
  </li>
  <li>
    <p>当act 的形式为：一个简单loop循环嵌套react，用下面的方法。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def act() = {
   loop {
     react {
       // body
     }
   }
 } 应该被替换
</code></pre></div>    </div>

    <p>def receive = {
     // body
   }</p>
  </li>
  <li>
    <p>当act包含一个loopWhile 结构，用下面的方法。</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def act() = {
   loopWhile(c) {
     react {
       case x: Int =&gt;
         // do task
         if (x == 42) {
           c = false
         }
     }
   }
 } 应该被替换
</code></pre></div>    </div>

    <p>def receive = {
   case x: Int =&gt;
     // do task
     if (x == 42) {
       context.stop(self)
     }
 }</p>
  </li>
  <li>
    <p>当act包含嵌套的react，用下面的规则：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def act() = {
   var c = true
   loopWhile(c) {
   react {
     case x: Int =&gt;
       // do task
       if (x == 42) {
         c = false
       } else {
         react {
           case y: String =&gt;
             // do nested task
         }
       }
     }
   }
 } 应该被替换
</code></pre></div>    </div>

    <p>def receive = {
     case x: Int =&gt;
       // do task
       if (x == 42) {
         context.stop(self)
       } else {
         context.become(({
           case y: String =&gt;
           // do nested task
         }: Receive).andThen(x =&gt; {
           unstashAll()
           context.unbecome()
        }).orElse { case x =&gt; stash(x) })
       }
   }</p>
  </li>
  <li>
    <p>reactWithin方法使用下面的修改规则：</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> loop {
   reactWithin(t) {
     case TIMEOUT =&gt; // timeout processing code
     case msg =&gt; // message processing code
   }
 } 应该被替换

 import scala.concurrent.duration._

 context.setReceiveTimeout(t millisecond)
 def receive = {
   case ReceiveTimeout =&gt; // timeout processing code
   case msg =&gt; // message processing code
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>在Akka中，异常处理用另一种方式完成。如果要模拟Scala控制器的方式，那就用下面的方法</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def act() = {
   loop {
     react {
       case msg =&gt;
       // 可能会失败的代码
     }
   }
 }

 override def exceptionHandler = {
   case x: Exception =&gt; println("got exception")
 } 应该被替换
</code></pre></div>    </div>

    <p>def receive = PFCatch({
     case msg =&gt;
       // 可能会失败的代码
   }, { case x: Exception =&gt; println(“got exception”) })
   PFCatch 的定义</p>

    <p>class PFCatch(f: PartialFunction[Any, Unit],
     handler: PartialFunction[Exception, Unit])
     extends PartialFunction[Any, Unit] {</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> def apply(x: Any) = {
   try {
     f(x)
   } catch {
     case e: Exception if handler.isDefinedAt(e) =&gt;
       handler(e)
   }
 }

 def isDefinedAt(x: Any) = f.isDefinedAt(x)    }
</code></pre></div>    </div>

    <p>object PFCatch {
     def apply(f: PartialFunction[Any, Unit],
       handler: PartialFunction[Exception, Unit]) =
         new PFCatch(f, handler)
   }</p>
  </li>
</ol>

<p>PFCatch并不包含在AMK之中，所以它可以保留在移植代码中，AMK将会在下一版本中被删除。当整个移植完成后，错误处理也可以改由Akka来监管。</p>

<h4 id="修改actor的方法">修改Actor的方法</h4>

<p>当我们移除了act方法以后，我们需要替换在Akka中不存在，但是有相似功能的方法。在下面的列表中，我们给出了两者的区别和替换方法：</p>

<ol>
  <li>
    <p>exit()/exit(reason) - 需要由 context.stop(self) 替换</p>
  </li>
  <li>
    <p>receiver - 需要由 self 替换</p>
  </li>
  <li>
    <p>reply(msg) - 需要由 sender ! msg 替换</p>
  </li>
  <li>
    <p>link(actor) - 在Akka中，控制器之间的链接一部分由<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html#What_Supervision_Means">supervision</a>来完成，一部分由<a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html#What_Lifecycle_Monitoring_Means">actor monitoring</a>来完成。在AMK中，我们只支持监测方法。因此，这部分Scala功能可以被完整的移植。</p>
  </li>
</ol>

<p>linking 和 watching 之间的区别在于：watching actor总是接受结束通知。然而，不像Scala的Exit消息包含结束的原因，Akka的watching 返回Terminated(a: ActorRef)消息，只包含ActorRef。获取结束原因的功能无法被移植。在Akka中，这一步骤可以在第4步之后，通过组织控制器的监管层级 <a href="http://doc.akka.io/docs/akka/2.1.0/general/supervision.html">supervision hierarchy</a>来完成。</p>

<p>如果watching actors收到的消息不撇陪结束消息，控制器会被终止并抛出DeathPactException异常。注意就算watching actors正常的结束，也会发生这种情况。在Scala中，linked actors只要一方不正常的终止，另一方就会以相同的原因终止。</p>

<p>如果系统不能单独的用 watch actors来 移植，用户可以像原来那样用link和exit(reason)来使用。然而，因为act()重载了Exit消息，需要做如下的修改：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  case Exit(actor, reason) =&gt;
    println("sorry about your " + reason)
    ... 应该被替换

  case t @ Terminated(actorRef) =&gt;
    println("sorry about your " + t.reason)
    ... 注意：在Scala和Akka的actor之间有另一种细微的区别：在Scala， link/watch 到已经终止的控制器不会有任何影响。在Akka中，看管已经终止的控制器会导致发送终止消息。这会在系统移植的第5 步导致不可预料的结果。
</code></pre></div></div>

<h3 id="第5步---akka后端的移植">第5步 - Akka后端的移植</h3>

<p>到目前为止，用户代码已经做好了移植到Akka actors的准备工作。现在我们可以把Scala actors迁移到Akka actor上。为了完成这一目标，需要配置build，去掉scala-actors.jar 和 scala-actors-migration.jar，把 akka-actor.jar 和 typesafe-config.jar加进来。AMK只能在Akka actor 2.1下正常工作，Akka actor 2.1已经包含在分发包 <a href="http://www.scala-lang.org/downloads">Scala distribution</a>中， 可以用这样的方法配置。</p>

<p>经过这一步骤以后，因为包名的不同和API之间的细微差别，编译会失败。我们必须将每一个导入的actor从scala 修改为Akka。下列是部分需要修改的包名：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  scala.actors._ -&gt; akka.actor._
  scala.actors.migration.ActWithStash -&gt; akka.actor.ActorDSL._
  scala.actors.migration.pattern.ask -&gt; akka.pattern.ask
  scala.actors.migration.Timeout -&gt; akka.util.Timeout
</code></pre></div></div>

<p>当然，ActWithStash 中方法的声明 def receive = 必须加上前缀override。</p>

<p>在Scala actor中，stash 方法需要一个消息做为参数。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  def receive = {
    ...
    case x =&gt; stash(x)
  }
</code></pre></div></div>

<p>在Akka中，只有当前处理的消息可以被隐藏(stashed)。因此，上面的例子可以替换为：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    def receive = {
      ...
      case x =&gt; stash()
    }
</code></pre></div></div>

<h4 id="添加actor-system">添加Actor System</h4>

<p>Akka actor 组织在<a href="http://doc.akka.io/docs/akka/2.1.0/general/actor-systems.html">Actor systems</a>系统中。每一个被实例化的actor必须属于某一个ActorSystem。因此，要添加一个ActorSystem 实例作为每个actor 实例调用的第一个参数。下面给出了例子。</p>

<p>为了完成该转换，你需要有一个actor system 实例。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val system = ActorSystem("migration-system")
</code></pre></div></div>

<p>然后，做如下转换：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActorDSL.actor(...) -&gt; ActorDSL.actor(system)(...)
</code></pre></div></div>

<p>如果对actor 的调用都使用同一个ActorSystem ，那么它可以作为隐式参数来传递。例如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ActorDSL.actor(...) -&gt;
    import project.implicitActorSystem
    ActorDSL.actor(...)
</code></pre></div></div>

<p>当所有的主线程和actors结束后，Scala程序会终止。迁移到Akka后，当所有的主线程结束，所有的actor systems关闭后，程序才会结束。Actor systems 需要在程序退出前明确的中止。这需要通过在Actor system中调用shutdown 方法来完成。</p>

<h4 id="远程-actors">远程 Actors</h4>

<p>当代码迁移到Akka，远程actors就不再工作了。 registerActorFor 和 alive 方法需要被移除。 在Akka中，远程控制通过配置独立的完成。更多细节请参考<a href="http://doc.akka.io/docs/akka/2.1.0/scala/remoting.html">Akka remoting documentation</a>。</p>

<h4 id="样例和问题">样例和问题</h4>

<p>这篇文档中的所有程序片段可以在<a href="http://github.com/scala/actors-migration/tree/master/src/test/">Actors Migration test suite</a>中找到，这些程序做为测试文件，前缀为actmig。</p>

<p>这篇文档和Actor移植组件由 <a href="http://people.epfl.ch/vojin.jovanovic">Vojin Jovanovic</a>和<a href="http://lampwww.epfl.ch/~phaller/">Philipp Haller</a>编写。</p>

<p>如果你发现任何问题或不完善的地方，请把它们报告给 <a href="https://github.com/scala/actors-migration/issues">Scala Bugtracker</a>。</p>

				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">
      <div id="toc"></div>
      
         
         
        <ul id="available-languages" style="display: none;">
          <li><a href="/overviews/core/actors-migration-guide.html">English</a></li>
          
            
            <li><a href="/zh-cn/overviews/core/actors-migration-guide.html" class="lang">中文 (简体)</a></li>
          
        </ul>
      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_zh-cn/overviews/core/actors-migration-guide.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

