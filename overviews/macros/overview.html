<!DOCTYPE html>
<html>
  <head>
    <title>Def Macros | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/resources/favicon-16x16.png">
    <link rel="manifest" href="/resources/site.webmanifest">
    <link rel="mask-icon" href="/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/" class="navigation-bdand">
        <img src="/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/books.html">Books</a>
              </li>
            
              <li>
                <a href="/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">Macros</div>
          
          <h1>Def Macros</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box">
				<div class="toc-context">
					<p><span class="tag" style="float: right;">EXPERIMENTAL</span></p>

<p><strong>Eugene Burmako</strong></p>

<p>Def macros are shipped as an experimental feature of Scala since version 2.10.0.
A subset of def macros, pending a thorough specification, is tentatively scheduled to become stable in one of the future versions of Scala.</p>

<p><span class="label success">UPDATE</span> This guide has been written for Scala 2.10.0, and now we’re well into the Scala 2.11.x release cycle,
so naturally the contents of the document are outdated. Nevertheless, this guide is not obsolete -
everything written here will still work in both Scala 2.10.x and Scala 2.11.x, so it will be helpful to read it through.
After reading the guide, take a look at the docs on <a href="/overviews/quasiquotes/intro.html">quasiquotes</a>
and <a href="bundles.html">macro bundles</a> to familiarize yourself with latest developments
that dramatically simplify writing macros. Then it might be a good idea to follow
<a href="https://github.com/scalamacros/macrology201">our macro workshop</a> for more in-depth examples.</p>

<h2 id="intuition">Intuition</h2>

<p>Here is a prototypical macro definition:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def m(x: T): R = macro implRef
</code></pre></div></div>

<p>At first glance macro definitions are equivalent to normal function definitions, except for their body, which starts with the conditional keyword <code class="highlighter-rouge">macro</code> and is followed by a possibly qualified identifier that refers to a static macro implementation method.</p>

<p>If, during type-checking, the compiler encounters an application of the macro <code class="highlighter-rouge">m(args)</code>, it will expand that application by invoking the corresponding macro implementation method, with the abstract-syntax trees of the argument expressions args as arguments. The result of the macro implementation is another abstract syntax tree, which will be inlined at the call site and will be type-checked in turn.</p>

<p>The following code snippet declares a macro definition assert that references a macro implementation Asserts.assertImpl (definition of assertImpl is provided below):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def assert(cond: Boolean, msg: Any) = macro Asserts.assertImpl
</code></pre></div></div>

<p>A call <code class="highlighter-rouge">assert(x &lt; 10, "limit exceeded")</code> would then lead at compile time to an invocation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assertImpl(c)(&lt;[ x &lt; 10 ]&gt;, &lt;[ “limit exceeded” ]&gt;)
</code></pre></div></div>

<p>where <code class="highlighter-rouge">c</code> is a context argument that contains information collected by the compiler at the call site, and the other two arguments are abstract syntax trees representing the two expressions <code class="highlighter-rouge">x &lt; 10</code> and <code class="highlighter-rouge">limit exceeded</code>.</p>

<p>In this document, <code class="highlighter-rouge">&lt;[ expr ]&gt;</code> denotes the abstract syntax tree that represents the expression expr. This notation has no counterpart in our proposed extension of the Scala language. In reality, the syntax trees would be constructed from the types in trait <code class="highlighter-rouge">scala.reflect.api.Trees</code> and the two expressions above would look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Literal(Constant("limit exceeded"))

Apply(
  Select(Ident(TermName("x")), TermName("$less"),
  List(Literal(Constant(10)))))
</code></pre></div></div>

<p>Here is a possible implementation of the <code class="highlighter-rouge">assert</code> macro:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.reflect.macros.Context
import scala.language.experimental.macros

object Asserts {
  def raise(msg: Any) = throw new AssertionError(msg)
  def assertImpl(c: Context)
    (cond: c.Expr[Boolean], msg: c.Expr[Any]) : c.Expr[Unit] =
   if (assertionsEnabled)
      &lt;[ if (!cond) raise(msg) ]&gt;
      else
      &lt;[ () ]&gt;
}
</code></pre></div></div>

<p>As the example shows, a macro implementation takes several parameter lists. First comes a single parameter, of type <code class="highlighter-rouge">scala.reflect.macros.Context</code>. This is followed by a list of parameters that have the same names as the macro definition parameters. But where the original macro parameter has type <code class="highlighter-rouge">T</code>, a macro implementation parameter has type <code class="highlighter-rouge">c.Expr[T]</code>. <code class="highlighter-rouge">Expr[T]</code> is a type defined in <code class="highlighter-rouge">Context</code> that wraps an abstract syntax tree of type <code class="highlighter-rouge">T</code>. The result type of the <code class="highlighter-rouge">assertImpl</code> macro implementation is again a wrapped tree, of type <code class="highlighter-rouge">c.Expr[Unit]</code>.</p>

<p>Also note that macros are considered an experimental and advanced feature,
so in order to write macros you need to enable them.
Do that either with <code class="highlighter-rouge">import scala.language.experimental.macros</code> on per-file basis
or with <code class="highlighter-rouge">-language:experimental.macros</code> (providing a compiler switch) on per-compilation basis.
Your users, however, don’t need to enable anything - macros look like normal methods
and can be used as normal methods, without any compiler switches or additional configurations.</p>

<h3 id="generic-macros">Generic macros</h3>

<p>Macro definitions and macro implementations may both be generic. If a macro implementation has type parameters, actual type arguments must be given explicitly in the macro definition’s body. Type parameters in an implementation may come with <code class="highlighter-rouge">WeakTypeTag</code> context bounds. In that case the corresponding type tags describing the actual type arguments instantiated at the application site will be passed along when the macro is expanded.</p>

<p>The following code snippet declares a macro definition <code class="highlighter-rouge">Queryable.map</code> that references a macro implementation <code class="highlighter-rouge">QImpl.map</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Queryable[T] {
 def map[U](p: T =&gt; U): Queryable[U] = macro QImpl.map[T, U]
}

object QImpl {
 def map[T: c.WeakTypeTag, U: c.WeakTypeTag]
        (c: Context)
        (p: c.Expr[T =&gt; U]): c.Expr[Queryable[U]] = ...
}
</code></pre></div></div>

<p>Now consider a value <code class="highlighter-rouge">q</code> of type <code class="highlighter-rouge">Queryable[String]</code> and a macro call</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q.map[Int](s =&gt; s.length)
</code></pre></div></div>

<p>The call is expanded to the following reflective macro invocation</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QImpl.map(c)(&lt;[ s =&gt; s.length ]&gt;)
   (implicitly[WeakTypeTag[String]], implicitly[WeakTypeTag[Int]])
</code></pre></div></div>

<h2 id="a-complete-example">A complete example</h2>

<p>This section provides an end-to-end implementation of a <code class="highlighter-rouge">printf</code> macro, which validates and applies the format string at compile-time.
For the sake of simplicity the discussion uses console Scala compiler, but as explained below macros are also supported by Maven and sbt.</p>

<p>Writing a macro starts with a macro definition, which represents the facade of the macro.
Macro definition is a normal function with anything one might fancy in its signature.
Its body, though, is nothing more that a reference to an implementation.
As mentioned above, to define a macro one needs to import <code class="highlighter-rouge">scala.language.experimental.macros</code>
or to enable a special compiler switch, <code class="highlighter-rouge">-language:experimental.macros</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.language.experimental.macros
def printf(format: String, params: Any*): Unit = macro printf_impl
</code></pre></div></div>

<p>Macro implementation must correspond to macro definitions that use it (typically there’s only one, but there might also be many). In a nutshell, every parameter of type <code class="highlighter-rouge">T</code> in the signature of a macro definition must correspond to a parameter of type <code class="highlighter-rouge">c.Expr[T]</code> in the signature of a macro implementation. The full list of rules is quite involved, but it’s never a problem, because if the compiler is unhappy, it will print the signature it expects in the error message.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.reflect.macros.Context
def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = ...
</code></pre></div></div>

<p>Compiler API is exposed in <code class="highlighter-rouge">scala.reflect.macros.Context</code>. Its most important part, reflection API, is accessible via <code class="highlighter-rouge">c.universe</code>.
It’s customary to import <code class="highlighter-rouge">c.universe._</code>, because it includes a lot of routinely used functions and types</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import c.universe._
</code></pre></div></div>

<p>First of all, the macro needs to parse the provided format string.
Macros run during the compile-time, so they operate on trees, not on values.
This means that the format parameter of the <code class="highlighter-rouge">printf</code> macro will be a compile-time literal, not an object of type <code class="highlighter-rouge">java.lang.String</code>.
This also means that the code below won’t work for <code class="highlighter-rouge">printf(get_format(), ...)</code>, because in that case <code class="highlighter-rouge">format</code> won’t be a string literal, but rather an AST that represents a function application.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val Literal(Constant(s_format: String)) = format.tree
</code></pre></div></div>

<p>Typical macros (and this macro is not an exception) need to create ASTs (abstract syntax trees) which represent Scala code.
To learn more about generation of Scala code, take a look at <a href="/overviews/reflection/overview.html">the overview of reflection</a>. Along with creating ASTs the code provided below also manipulates types.
Note how we get a hold of Scala types that correspond to <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">String</code>.
Reflection overview linked above covers type manipulations in detail.
The final step of code generation combines all the generated code into a <code class="highlighter-rouge">Block</code>.
Note the call to <code class="highlighter-rouge">reify</code>, which provides a shortcut for creating ASTs.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val evals = ListBuffer[ValDef]()
def precompute(value: Tree, tpe: Type): Ident = {
  val freshName = TermName(c.fresh("eval$"))
  evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)
  Ident(freshName)
}

val paramsStack = Stack[Tree]((params map (_.tree)): _*)
val refs = s_format.split("(?&lt;=%[\\w%])|(?=%[\\w%])") map {
  case "%d" =&gt; precompute(paramsStack.pop, typeOf[Int])
  case "%s" =&gt; precompute(paramsStack.pop, typeOf[String])
  case "%%" =&gt; Literal(Constant("%"))
  case part =&gt; Literal(Constant(part))
}

val stats = evals ++ refs.map(ref =&gt; reify(print(c.Expr[Any](ref).splice)).tree)
c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))
</code></pre></div></div>

<p>The snippet below represents a complete definition of the <code class="highlighter-rouge">printf</code> macro.
To follow the example, create an empty directory and copy the code to a new file named <code class="highlighter-rouge">Macros.scala</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.reflect.macros.Context
import scala.collection.mutable.{ListBuffer, Stack}

object Macros {
  def printf(format: String, params: Any*): Unit = macro printf_impl

  def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {
    import c.universe._
    val Literal(Constant(s_format: String)) = format.tree

    val evals = ListBuffer[ValDef]()
    def precompute(value: Tree, tpe: Type): Ident = {
      val freshName = TermName(c.fresh("eval$"))
      evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)
      Ident(freshName)
    }

    val paramsStack = Stack[Tree]((params map (_.tree)): _*)
    val refs = s_format.split("(?&lt;=%[\\w%])|(?=%[\\w%])") map {
      case "%d" =&gt; precompute(paramsStack.pop, typeOf[Int])
      case "%s" =&gt; precompute(paramsStack.pop, typeOf[String])
      case "%%" =&gt; Literal(Constant("%"))
      case part =&gt; Literal(Constant(part))
    }

    val stats = evals ++ refs.map(ref =&gt; reify(print(c.Expr[Any](ref).splice)).tree)
    c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))
  }
}
</code></pre></div></div>

<p>To use the <code class="highlighter-rouge">printf</code> macro, create another file <code class="highlighter-rouge">Test.scala</code> in the same directory and put the following code into it.
Note that using a macro is as simple as calling a function. It also doesn’t require importing <code class="highlighter-rouge">scala.language.experimental.macros</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>object Test extends App {
  import Macros._
  printf("hello %s!", "world")
}
</code></pre></div></div>

<p>An important aspect of macrology is separate compilation. To perform macro expansion, compiler needs a macro implementation in executable form. Thus macro implementations need to be compiled before the main compilation, otherwise you might see the following error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Projects/Kepler/sandbox$ scalac -language:experimental.macros Macros.scala Test.scala
Test.scala:3: error: macro implementation not found: printf (the most common reason for that is that
you cannot use macro implementations in the same compilation run that defines them)
pointing to the output of the first phase
  printf("hello %s!", "world")
        ^
one error found

~/Projects/Kepler/sandbox$ scalac Macros.scala &amp;&amp; scalac Test.scala &amp;&amp; scala Test
hello world!
</code></pre></div></div>

<h2 id="tips-and-tricks">Tips and tricks</h2>

<h3 id="using-macros-with-the-command-line-scala-compiler">Using macros with the command-line Scala compiler</h3>

<p>This scenario is covered in the previous section. In short, compile macros and their usages using separate invocations of <code class="highlighter-rouge">scalac</code>, and everything should work fine. If you use REPL, then it’s even better, because REPL processes every line in a separate compilation run, so you’ll be able to define a macro and use it right away.</p>

<h3 id="using-macros-with-maven-or-sbt">Using macros with Maven or sbt</h3>

<p>The walkthrough in this guide uses the simplest possible command-line compilation, but macros also work with build tools such as Maven and sbt. Check out <a href="https://github.com/scalamacros/sbt-example">https://github.com/scalamacros/sbt-example</a> or <a href="https://github.com/scalamacros/maven-example">https://github.com/scalamacros/maven-example</a> for end-to-end examples, but in a nutshell you only need to know two things:</p>
<ul>
  <li>Macros needs scala-reflect.jar in library dependencies.</li>
  <li>The separate compilation restriction requires macros to be placed in a separate project.</li>
</ul>

<h3 id="using-macros-with-scala-ide-or-intellij-idea">Using macros with Scala IDE or Intellij IDEA</h3>

<p>Both in Scala IDE and in Intellij IDEA macros are known to work fine, given they are moved to a separate project.</p>

<h3 id="debugging-macros">Debugging macros</h3>

<p>Debugging macros (i.e. the logic that drives macro expansion) is fairly straightforward. Since macros are expanded within the compiler, all that you need is to run the compiler under a debugger. To do that, you need to: 1) add all (!) the libraries from the lib directory in your Scala home (which include such jar files as <code class="highlighter-rouge">scala-library.jar</code>, <code class="highlighter-rouge">scala-reflect.jar</code> and <code class="highlighter-rouge">scala-compiler.jar</code>) to the classpath of your debug configuration, 2) set <code class="highlighter-rouge">scala.tools.nsc.Main</code> as an entry point, 3) provide the <code class="highlighter-rouge">-Dscala.usejavacp=true</code> system property for the JVM (very important!), 4) set command-line arguments for the compiler as <code class="highlighter-rouge">-cp &lt;path to the classes of your macro&gt; Test.scala</code>, where <code class="highlighter-rouge">Test.scala</code> stands for a test file containing macro invocations to be expanded. After all that is done, you should be able to put a breakpoint inside your macro implementation and launch the debugger.</p>

<p>What really requires special support in tools is debugging the results of macro expansion (i.e. the code that is generated by a macro). Since this code is never written out manually, you cannot set breakpoints there, and you won’t be able to step through it. Scala IDE and Intellij IDEA teams will probably add support for this in their debuggers at some point, but for now the only way to debug macro expansions are diagnostic prints: <code class="highlighter-rouge">-Ymacro-debug-lite</code> (as described below), which prints out the code emitted by macros, and println to trace the execution of the generated code.</p>

<h3 id="inspecting-generated-code">Inspecting generated code</h3>

<p>With <code class="highlighter-rouge">-Ymacro-debug-lite</code> it is possible to see both pseudo-Scala representation of the code generated by macro expansion and raw AST representation of the expansion. Both have their merits: the former is useful for surface analysis, while the latter is invaluable for fine-grained debugging.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Projects/Kepler/sandbox$ scalac -Ymacro-debug-lite Test.scala
typechecking macro expansion Macros.printf("hello %s!", "world") at
source-C:/Projects/Kepler/sandbox\Test.scala,line-3,offset=52
{
  val eval$1: String = "world";
  scala.this.Predef.print("hello ");
  scala.this.Predef.print(eval$1);
  scala.this.Predef.print("!");
  ()
}
Block(List(
ValDef(Modifiers(), TermName("eval$1"), TypeTree().setType(String), Literal(Constant("world"))),
Apply(
  Select(Select(This(TypeName("scala")), TermName("Predef")), TermName("print")),
  List(Literal(Constant("hello")))),
Apply(
  Select(Select(This(TypeName("scala")), TermName("Predef")), TermName("print")),
  List(Ident(TermName("eval$1")))),
Apply(
  Select(Select(This(TypeName("scala")), TermName("Predef")), TermName("print")),
  List(Literal(Constant("!"))))),
Literal(Constant(())))
</code></pre></div></div>

<h3 id="macros-throwing-unhandled-exceptions">Macros throwing unhandled exceptions</h3>

<p>What happens if macro throws an unhandled exception? For example, let’s crash the <code class="highlighter-rouge">printf</code> macro by providing invalid input.
As the printout shows, nothing dramatic happens. Compiler guards itself against misbehaving macros, prints relevant part of a stack trace, and reports an error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Projects/Kepler/sandbox$ scala
Welcome to Scala version 2.10.0-20120428-232041-e6d5d22d28 (Java HotSpot(TM) 64-Bit Server VM, Java 1.6.0_25).
Type in expressions to have them evaluated.
Type :help for more information.

scala&gt; import Macros._
import Macros._

scala&gt; printf("hello %s!")
&lt;console&gt;:11: error: exception during macro expansion:
java.util.NoSuchElementException: head of empty list
        at scala.collection.immutable.Nil$.head(List.scala:318)
        at scala.collection.immutable.Nil$.head(List.scala:315)
        at scala.collection.mutable.Stack.pop(Stack.scala:140)
        at Macros$$anonfun$1.apply(Macros.scala:49)
        at Macros$$anonfun$1.apply(Macros.scala:47)
        at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:237)
        at scala.collection.TraversableLike$$anonfun$map$1.apply(TraversableLike.scala:237)
        at scala.collection.IndexedSeqOptimized$class.foreach(IndexedSeqOptimized.scala:34)
        at scala.collection.mutable.ArrayOps.foreach(ArrayOps.scala:39)
        at scala.collection.TraversableLike$class.map(TraversableLike.scala:237)
        at scala.collection.mutable.ArrayOps.map(ArrayOps.scala:39)
        at Macros$.printf_impl(Macros.scala:47)

              printf("hello %s!")
                    ^
</code></pre></div></div>

<h3 id="reporting-warnings-and-errors">Reporting warnings and errors</h3>

<p>The canonical way to interact with the user is through the methods of <code class="highlighter-rouge">scala.reflect.macros.FrontEnds</code>.
<code class="highlighter-rouge">c.error</code> reports a compilation error, <code class="highlighter-rouge">c.warning</code> issues a warning, <code class="highlighter-rouge">c.abort</code> reports an error and terminates
execution of a macro.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; def impl(c: Context) =
  c.abort(c.enclosingPosition, "macro has reported an error")
impl: (c: scala.reflect.macros.Context)Nothing

scala&gt; def test = macro impl
defined term macro test: Any

scala&gt; test
&lt;console&gt;:32: error: macro has reported an error
              test
              ^
</code></pre></div></div>

<p>Note that at the moment reporting facilities don’t support multiple warnings or errors per position as described in
<a href="https://issues.scala-lang.org/browse/SI-6910">SI-6910</a>. This means that only the first error or warning per position
will be reported, and the others will be lost (also errors trump warnings at the same position, even if those are reported earlier).</p>

<h3 id="writing-bigger-macros">Writing bigger macros</h3>

<p>When the code of a macro implementation grows big enough to warrant modularization beyond the body of the implementation method, it becomes apparent that one needs to carry around the context parameter, because most things of interest are path-dependent on the context.</p>

<p>One of the approaches is to write a class that takes a parameter of type <code class="highlighter-rouge">Context</code> and then split the macro implementation into a series of methods of that class. This is natural and simple, except that it’s hard to get it right. Here’s a typical compilation error.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; class Helper(val c: Context) {
     | def generate: c.Tree = ???
     | }
defined class Helper

scala&gt; def impl(c: Context): c.Expr[Unit] = {
     | val helper = new Helper(c)
     | c.Expr(helper.generate)
     | }
&lt;console&gt;:32: error: type mismatch;
 found   : helper.c.Tree
    (which expands to)  helper.c.universe.Tree
 required: c.Tree
    (which expands to)  c.universe.Tree
       c.Expr(helper.generate)
                     ^
</code></pre></div></div>

<p>The problem in this snippet is in a path-dependent type mismatch. The Scala compiler does not understand that <code class="highlighter-rouge">c</code> in <code class="highlighter-rouge">impl</code> is the same object as <code class="highlighter-rouge">c</code> in <code class="highlighter-rouge">Helper</code>, even though the helper is constructed using the original <code class="highlighter-rouge">c</code>.</p>

<p>Luckily just a small nudge is all that is needed for the compiler to figure out what’s going on. One of the possible ways of doing that is using refinement types (the example below is the simplest application of the idea; for example, one could also write an implicit conversion from <code class="highlighter-rouge">Context</code> to <code class="highlighter-rouge">Helper</code> to avoid explicit instantiations and simplify the calls).</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; abstract class Helper {
     | val c: Context
     | def generate: c.Tree = ???
     | }
defined class Helper

scala&gt; def impl(c1: Context): c1.Expr[Unit] = {
     | val helper = new { val c: c1.type = c1 } with Helper
     | c1.Expr(helper.generate)
     | }
impl: (c1: scala.reflect.macros.Context)c1.Expr[Unit]
</code></pre></div></div>

<p>An alternative approach is to pass the identity of the context in an explicit type parameter. Note how the constructor of <code class="highlighter-rouge">Helper</code> uses <code class="highlighter-rouge">c.type</code> to express the fact that <code class="highlighter-rouge">Helper.c</code> is the same as the original <code class="highlighter-rouge">c</code>. Scala’s type inference can’t figure this out on its own, so we need to help it.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scala&gt; class Helper[C &lt;: Context](val c: C) {
     | def generate: c.Tree = ???
     | }
defined class Helper

scala&gt; def impl(c: Context): c.Expr[Unit] = {
     | val helper = new Helper[c.type](c)
     | c.Expr(helper.generate)
     | }
impl: (c: scala.reflect.macros.Context)c.Expr[Unit]
</code></pre></div></div>

				</div>

				<div class="content-contributors">
    <h3>Contributors to this page:</h3>
    <div id="contributors" class="contributors-container"></div>
</div>

			</div>
		</div>

		<!-- TOC -->
		<div class="content-nav">
	<div class="inner-box sidebar-toc-wrapper" style="">
		<h5 class="contents">Contents</h5>
		<div class="inner-toc" id="sidebar-toc">

      <ul>
        
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/usecases.html">Use Cases</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/blackbox-whitebox.html">Blackbox Vs Whitebox</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/overview.html">Def Macros</a></li>
            
            <div id="toc"></div>
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/quasiquotes.html">Quasiquotes</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/bundles.html">Macro Bundles</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/implicits.html">Implicit Macros</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/extractors.html">Extractor Macros</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/typeproviders.html">Type Providers</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/annotations.html">Macro Annotations</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/paradise.html">Macro Paradise</a></li>
            
            
          
        
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/roadmap.html">Roadmap</a></li>
            
            
          
        
          
        
          
        
          
             <!-- this must be English, so get the other documents' titles -->
            <li><a href="/overviews/macros/changelog211.html">Changes in Scala 2.11</a></li>
            
            
          
        
          
        
          
        
          
        
          
        
          
        
      </ul>

      
        <ul id="available-languages" style="display: none;">
          <li><a href="/overviews/macros/overview.html">English</a></li>
          
            
            
      			
      			<li><a href="/ja/overviews/macros/overview.html" class="lang">日本語</a></li>
          
        </ul>
      
		</div>
		<hr>
		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_overviews/macros/overview.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
	</div>
</div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

