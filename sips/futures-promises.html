<!DOCTYPE html>
<html>
  <head>
    <title>SIP-14 - Futures and Promises | Scala Documentation</title>
    
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="icon" type="image/png" href="/docs.scala-lang/resources/favicon.ico">
    <link rel="shortcut icon" type="image/png" href="/docs.scala-lang/resources/favicon.ico">
    <link rel="apple-touch-icon" sizes="180x180" href="/docs.scala-lang/resources/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/docs.scala-lang/resources/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/docs.scala-lang/resources/favicon-16x16.png">
    <link rel="manifest" href="/docs.scala-lang/resources/site.webmanifest">
    <link rel="mask-icon" href="/docs.scala-lang/resources/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#15a9ce">
    <meta name="theme-color" content="#ffffff">

    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    <!-- Custom stylesheet -->
    <link href="/docs.scala-lang/resources/css/unslider-dots.css" rel="stylesheet" type="text/css">
    <link href="/docs.scala-lang/resources/css/unslider.css" rel="stylesheet" type="text/css">
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/highlightjs.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/style.css" type="text/css" />
    <link rel="stylesheet" href="/docs.scala-lang/resources/css/monospace.css" type="text/css" />

    <!-- Atom feeds -->
    <link rel="alternate" type="application/atom+xml" title="News Feed" href="http://scala-lang.org/feed/index.xml" />
    <link rel="alternate" type="application/atom+xml" title="Blog Feed" href="http://scala-lang.org/feed/blog.xml" />

    <!-- Algolia stylesheet -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />


  </head>
  <body>


<div class="navigation-fade-screen"></div>

<header id="site-header">
  <div class="wrap">
    <nav class="navigation" role="menu">
      <a href="http://scala-lang.org" class="navigation-bdand">
        <img src="/docs.scala-lang/resources/img/frontpage/scala-logo-white@2x.png" alt="">
      </a>
      <div class="navigation-panel-button">
        <i class="fa fa-bars"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/" class="active">Documentation</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/download/" >Download</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/community/" >Community</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://index.scala-lang.org" >Libraries</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/contribute/" >Contribute</a>
            </li>
        
            <li class="navigation-menu-item">
              <a href="https://www.scala-lang.org/blog/" >Blog</a>
            </li>
        
      </ul>
    </nav>
  </div>
</header>
<header id="doc-header">
  <div class="wrap" style="padding: 0px;">
    <nav class="doc-navigation" role="menu">
      <a href="/docs.scala-lang/" class="navigation-bdand">
        <img src="/docs.scala-lang/resources/img/documentation-logo@2x.png" alt="">
      </a>
      <div class="navigation-ellipsis">
        <i class="fa fa-ellipsis-v"></i>
      </div>
      <ul class="navigation-menu">
        
            <li class="navigation-menu-item">
              <a href="#" id="api" >API</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="https://www.scala-lang.org/api/current/">Current</a>
                  </li>
                
                  <li>
                    <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/api/all.html">All Versions</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="learn" >Learn</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang/getting-started.html">Getting Started</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tour/tour-of-scala.html">Tour of Scala</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/learn.html">Online Resources</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="#" id="reference" >Reference</a>
                
                <ul class="navigation-dropdown">
                
                  <li>
                    <a href="/docs.scala-lang/overviews/index.html">Guides & Overviews</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/books.html">Books</a>
                  </li>
                
                  <li>
                    <a href="/docs.scala-lang/tutorials/FAQ/index.html">Scala FAQs</a>
                  </li>
                
                  <li>
                    <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
                  </li>
                
                </ul>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/style/index.html" id="style guide" >Style Guide</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/cheatsheets/index.html" id="cheatsheet" >Cheatsheet</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/glossary/index.html" id="glossary" >Glossary</a>
                
            </li>
        
            <li class="navigation-menu-item">
              <a href="/docs.scala-lang/sips/index.html" id="sips" >SIPs</a>
                
            </li>
        
      </ul>
    </nav>
    <nav class="doc-navigation-submenus">
      
        
          <ul class="navigation-submenu" id="api" style="display: none;">
            
              <li>
                <a href="https://www.scala-lang.org/api/current/">Current</a>
              </li>
            
              <li>
                <a href="https://www.scala-lang.org/files/archive/nightly/2.12.x/api/2.12.x/">Nightly</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/api/all.html">All Versions</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="learn" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang/getting-started.html">Getting Started</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tour/tour-of-scala.html">Tour of Scala</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tutorials/scala-for-java-programmers.html">Scala for Java Programmers</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/learn.html">Online Resources</a>
              </li>
            
          </ul>
        
      
        
          <ul class="navigation-submenu" id="reference" style="display: none;">
            
              <li>
                <a href="/docs.scala-lang/overviews/index.html">Guides & Overviews</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/books.html">Books</a>
              </li>
            
              <li>
                <a href="/docs.scala-lang/tutorials/FAQ/index.html">Scala FAQs</a>
              </li>
            
              <li>
                <a href="http://scala-lang.org/files/archive/spec/2.12/">Language Spec</a>
              </li>
            
          </ul>
        
      
        
      
        
      
        
      
        
      
      <ul class="navigation-submenu ellipsis-menu" style="display: none;">
        
          
        
          
        
          
        
          
            <li><a href="/docs.scala-lang/style/index.html">Style Guide</a></li>
          
        
          
            <li><a href="/docs.scala-lang/cheatsheets/index.html">Cheatsheet</a></li>
          
        
          
            <li><a href="/docs.scala-lang/glossary/index.html">Glossary</a></li>
          
        
          
            <li><a href="/docs.scala-lang/sips/index.html">SIPs</a></li>
          
        
      </ul>
    </nav>
  </div>
</header>


<main id="inner-main">

  <!-- Title -->
  <section class="title-page">
    <div class="wrap">
      <div class="content-title-documentation">
        <div class="titles">
          
            <div class="supertitle">&nbsp;</div>
          
          <h1>SIP-14 - Futures and Promises</h1>
        </div>
        <div class="language-dropdown">
          <div id="dd" class="wrapper-dropdown" tabindex="1">
            <span>Language</span>
              <ul class="dropdown"></ul>
          </div>
      </div>
    </div>
  </section>

  
  <section class="content">
	<div class="wrap">
		<div class="content-primary documentation">
			<div class="inner-box toc-context">
				<p><strong>By: Philipp Haller, Aleksandar Prokopec, Heather Miller, Viktor Klang, Roland Kuhn, and Vojin Jovanovic</strong></p>

<p>This SIP is part of two SIPs, which together constitute a redesign of <code class="highlighter-rouge">scala.concurrent</code> into a unified substrate for a variety of parallel frameworks.
This proposal focuses on futures and promises.</p>

<h2 id="introduction">Introduction</h2>

<p>Futures provide a nice way to reason about performing many operations
in parallel– in an efficient and non-blocking way. The idea
is simple, a <code class="highlighter-rouge">Future</code> is a sort of placeholder object that you can
create for a result that doesn’t yet exist. Generally, the result of
the <code class="highlighter-rouge">Future</code> is computed concurrently and can be later collected. Composing concurrent tasks in this way tends to result in faster, asynchronous, non-blocking parallel code.</p>

<p>This is particularly evident due to the fact that within the Scala ecosystem alone, several frameworks aiming to provide a full-featured implementation of futures and promises have arisen, including the futures available in the Scala Actors package [<a href="http://www.scala-lang.org/api/2.9.3/scala/actors/Future.html" title="SActorsFutures">4</a>], Akka [<a href="https://doc.akka.io/docs/akka/current/futures.html" title="AkkaFutures">3</a>], Finagle [<a href="http://twitter.github.com/scala_school/finagle.html" title="Finagle">2</a>], and Scalaz [<a href="http://code.google.com/p/scalaz/" title="Scalaz">5</a>].</p>

<p>The redesign of <code class="highlighter-rouge">scala.concurrent</code> provides a new Futures and Promises
API, meant to act as a common foundation for multiple parallel
frameworks and libraries to utilize both within Scala’s standard
library, and externally.</p>

<p>By default, futures and promises are non-blocking, making use of
callbacks instead of typical blocking operations. In an effort to
facilitate, and make use of callbacks on a higher-level, we provide
combinators such as <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">foreach</code>, and <code class="highlighter-rouge">filter</code> for composing
futures in a non-blocking way. For cases where blocking is absolutely
necessary, futures can be blocked on (although it is discouraged).</p>

<p>The futures and promises API builds upon the notion of an
<code class="highlighter-rouge">ExecutionContext</code>, an execution environment designed to manage
resources such as thread pools between parallel frameworks and
libraries (detailed in an accompanying SIP, forthcoming). Futures and
promises are created through such <code class="highlighter-rouge">ExecutionContext</code>s. For example, this makes it possible, in the case of an application which requires blocking futures, for an underlying execution environment to resize itself if necessary to guarantee progress.</p>

<h2 id="futures">Futures</h2>

<p>A future is an abstraction which represents a value which may become
available at some point. A <code class="highlighter-rouge">Future</code> object either holds a result of a
computation or an exception in the case that the computation failed.
An important property of a future is that it is in effect immutable–
it can never be written to or failed by the holder of the <code class="highlighter-rouge">Future</code> object.</p>

<p>The simplest way to create a future object is to invoke the <code class="highlighter-rouge">future</code>
method which starts an asynchronous computation and returns a
future holding the result of that computation.
The result becomes available once the future completes.</p>

<p>Here is an example. Let’s assume that we want to use the API of some
popular social network to obtain a list of friends for a given user.
After opening a new session we want to create an asynchronous request to the
server for this list:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent.Future

val session = socialNetwork.createSessionFor("user", credentials)
val f: Future[List[Friend]] = Future {
  session.getFriends
}
</code></pre></div></div>

<p>The list of friends becomes available in the future <code class="highlighter-rouge">f</code> once the server
responds.</p>

<p>An unsuccessful attempt may result in an exception. In
the following example, the <code class="highlighter-rouge">session</code> value is incorrectly
initialized, so the future will hold a <code class="highlighter-rouge">NullPointerException</code> instead of the value:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val session = null
val f: Future[List[Friend]] = Future {
  session.getFriends
}
</code></pre></div></div>

<h3 id="callbacks">Callbacks</h3>

<p>We are generally interested in the result value of the computation. To
obtain the future’s result, a client of the future would have to block
until the future is completed. Although this is allowed by the <code class="highlighter-rouge">Future</code>
API as we will show later in this document, a better way to do it is in a
completely non-blocking way, by registering a callback on the future. This
callback is called asynchronously once the future is completed. If the
future has already been completed when registering the callback, then
the callback may either be executed asynchronously, or sequentially on
the same thread.</p>

<p>The most general form of registering a callback is by using the <code class="highlighter-rouge">onComplete</code>
method, which takes a callback function of type <code class="highlighter-rouge">Either[Throwable, T] =&gt; U</code>.
The callback is applied to the value
of type <code class="highlighter-rouge">Right[T]</code> if the future completes successfully, or to a value
of type <code class="highlighter-rouge">Left[Throwable]</code> otherwise. The <code class="highlighter-rouge">onComplete</code> method is
parametric in the return type of the callback, but it discards the
result of the callback.</p>

<p>Coming back to our social network example, let’s assume we want to
fetch a list of our own recent posts and render them to the screen.
We do so by calling the method <code class="highlighter-rouge">getRecentPosts</code> which returns a <code class="highlighter-rouge">List[String]</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onComplete {
  case Right(posts) =&gt; for (post &lt;- posts) render(post)
  case Left(t)  =&gt; render("An error has occured: " + t.getMessage)
}
</code></pre></div></div>

<p>The <code class="highlighter-rouge">onComplete</code> method is general in the sense that it allows the
client to handle the result of both failed and successful future
computations. To handle only successful results, the <code class="highlighter-rouge">onSuccess</code>
callback is used (which takes a partial function):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onSuccess {
  case posts =&gt; for (post &lt;- posts) render(post)
}
</code></pre></div></div>

<p>To handle failed results, the <code class="highlighter-rouge">onFailure</code> callback is used:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f: Future[List[String]] = Future {
  session.getRecentPosts
}

f onFailure {
  case t =&gt; render("An error has occured: " + t.getMessage)
}
f onSuccess {
  case posts =&gt; for (post &lt;- posts) render(post)
}
</code></pre></div></div>

<p>The <code class="highlighter-rouge">onFailure</code> callback is only executed if the future fails, that
is, if it contains an exception. The <code class="highlighter-rouge">onComplete</code>, <code class="highlighter-rouge">onSuccess</code>, and
<code class="highlighter-rouge">onFailure</code> methods have result type <code class="highlighter-rouge">Unit</code>, which means invocations
of these methods cannot be chained. This is an intentional design
decision which was made to avoid suggesting that chained
invocations may imply an ordering on the execution of the registered
callbacks (callbacks registered on the same future are unordered).</p>

<p>Since partial functions have the <code class="highlighter-rouge">isDefinedAt</code> method, the
<code class="highlighter-rouge">onFailure</code> method only triggers the callback if it is defined for a
particular <code class="highlighter-rouge">Throwable</code>. In the following example the registered callback is never triggered:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future {
  2 / 0
}

f onFailure {
  case npe: NullPointerException =&gt;
    println("I'd be amazed if this printed out.")
}
</code></pre></div></div>

<p>Having a regular function callback as an argument to <code class="highlighter-rouge">onFailure</code> would
require including the default case in every failure callback, which is
cumbersome– omitting the default case would lead to <code class="highlighter-rouge">MatchError</code>s later.</p>

<p>Second, <code class="highlighter-rouge">try-catch</code> blocks also expect a <code class="highlighter-rouge">PartialFunction</code>
value. That means that if there are generic partial function exception
handlers present in the application then they will be compatible with the <code class="highlighter-rouge">onFailure</code> method.</p>

<p>In conclusion, the semantics of callbacks are as follows:</p>

<ol>
  <li>
    <p>Registering an <code class="highlighter-rouge">onComplete</code> callback on the future
ensures that the corresponding closure is invoked after
the future is completed, eventually.</p>
  </li>
  <li>
    <p>Registering an <code class="highlighter-rouge">onSuccess</code> or <code class="highlighter-rouge">onFailure</code> callback has the same
semantics as <code class="highlighter-rouge">onComplete</code>, with the difference that the closure is only called
if the future is completed successfully or fails, respectively.</p>
  </li>
  <li>
    <p>Registering a callback on the future which is already completed
will result in the callback being executed eventually (as implied by
1). Furthermore, the callback may even be executed synchronously on
the same thread that registered the callback if this does not cancel
progress of that thread.</p>
  </li>
  <li>
    <p>In the event that multiple callbacks are registered on the future,
the order in which they are executed is not defined. In fact, the
callbacks may be executed concurrently with one another.
However, a particular <code class="highlighter-rouge">Future</code> implementation may have a well-defined
order.</p>
  </li>
  <li>
    <p>In the event that some of the callbacks throw an exception, the
other callbacks are executed regardlessly.</p>
  </li>
  <li>
    <p>In the event that some of the callbacks never complete (e.g. the
callback contains an infinite loop), the other callbacks may not be
executed at all. In these cases, a potentially blocking callback must
use the <code class="highlighter-rouge">blocking</code> construct (see below).</p>
  </li>
  <li>
    <p>Once executed, the callbacks are removed from the future object,
thus being eligible for GC.</p>
  </li>
</ol>

<!--
The `onTimeout` method registers callbacks triggered when the future fails with a `FutureTimeoutException`. This case can also be handled by the `onFailure` method if the partial function is defined for that exception type.
-->

<!--
Note that all three latter on-callback methods can be expressed in terms of the `onComplete` method. As such they are by default implemented in the `scala.concurrent.Future` trait. Future implementations extending this trait must implement the `onComplete` method, but may choose to also override the other on-callback methods for performance reasons.
-->

<h3 id="functional-composition-and-for-comprehensions">Functional Composition and For-Comprehensions</h3>

<p>The examples we have shown so far lend themselves naturally
to the functional composition of futures. Assume we have an API for
interfacing with a currency trading service. Suppose we want to buy US
dollars, but only when it’s profitable. We first show how this could
be done using callbacks:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val rateQuote = Future {
  connection.getCurrentValue(USD)
}

rateQuote onSuccess { case quote =&gt;
  val purchase = Future {
    if (isProfitable(quote)) connection.buy(amount, quote)
    else throw new Exception("not profitable")
  }

  purchase onSuccess {
    case _ =&gt; println("Purchased " + amount + " USD")
  }
}
</code></pre></div></div>

<p>We start by creating a future which fetches the current exchange
rate. After it’s successfully obtained from the server, we create
another future which makes a decision to buy only if it’s profitable
to do so, and then sends a requests.</p>

<p>This works, but is inconvenient for two reasons. First, we have to use
<code class="highlighter-rouge">onSuccess</code>, and we have to nest the second <code class="highlighter-rouge">purchase</code> future within
it.  Second, the <code class="highlighter-rouge">purchase</code> future is not in the scope of the rest of
the code.</p>

<p>For these two reasons, futures provide combinators which allow a
more straightforward composition. One of the basic combinators
is <code class="highlighter-rouge">map</code>, which, given a future and a mapping function for the value of
the future, produces a new future that is completed with the
mapped value once the original future is successfully completed. Let’s
rewrite the previous example using the <code class="highlighter-rouge">map</code> combinator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val rateQuote = Future {
  connection.getCurrentValue(USD)
}

val purchase = rateQuote map {
  quote =&gt; if (isProfitable(quote)) connection.buy(amount, quote)
           else throw new Exception("not profitable")
}

purchase onSuccess {
  case _ =&gt; println("Purchased " + amount + " USD")
}
</code></pre></div></div>

<p>The semantics of <code class="highlighter-rouge">map</code> is as follows. If the original future is
completed successfully then the returned future is completed with a
mapped value from the original future. If the mapping function throws
an exception the future is completed with that exception. If the
original future fails with an exception then the returned future also
contains the same exception. This exception propagating semantics is
present in the rest of the combinators, as well.</p>

<p>To enable for-comprehensions, futures also have the <code class="highlighter-rouge">flatMap</code>, <code class="highlighter-rouge">filter</code> and
<code class="highlighter-rouge">foreach</code> combinators. The <code class="highlighter-rouge">flatMap</code> method takes a function that maps the value
to a new future <code class="highlighter-rouge">g</code>, and then returns a future which is completed once
<code class="highlighter-rouge">g</code> is completed.</p>

<p>Lets assume that we want to exchange US dollars for Swiss francs
(CHF). We have to fetch quotes for both currencies, and then decide on
buying based on both quotes.
Here is an example of <code class="highlighter-rouge">flatMap</code> usage within for-comprehensions:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val usdQuote = Future { connection.getCurrentValue(USD) }
val chfQuote = Future { connection.getCurrentValue(CHF) }

val purchase = for {
  usd &lt;- usdQuote
  chf &lt;- chfQuote
  if isProfitable(usd, chf)
} yield connection.buy(amount, chf)

purchase onSuccess {
  case _ =&gt; println("Purchased " + amount + " CHF")
}
</code></pre></div></div>

<p>The <code class="highlighter-rouge">filter</code> combinator creates a new future which contains the value
of the original future only if it satisfies some predicate. Otherwise,
the new future is failed with a <code class="highlighter-rouge">NoSuchElementException</code>.</p>

<p>It is important to note that calling the <code class="highlighter-rouge">foreach</code> combinator does not
block. Instead, the function for the <code class="highlighter-rouge">foreach</code> gets asynchronously
executed only if the future is completed successfully. This means that
the <code class="highlighter-rouge">foreach</code> has exactly the same semantics as the <code class="highlighter-rouge">onSuccess</code>
callback.</p>

<p>Since the <code class="highlighter-rouge">Future</code> trait can conceptually contain two types of values
(computation results and exceptions), there exists a need for
combinators which handle exceptions.</p>

<p>Let’s assume that based on the <code class="highlighter-rouge">rateQuote</code> we decide to buy a certain
amount. The <code class="highlighter-rouge">connection.buy</code> method takes an <code class="highlighter-rouge">amount</code> to buy and the expected
<code class="highlighter-rouge">quote</code>. It returns the amount bought. If the
<code class="highlighter-rouge">quote</code> has changed in the meanwhile, it will throw a
<code class="highlighter-rouge">QuoteChangedException</code> and it will not buy anything. If we want our
future to contain <code class="highlighter-rouge">0</code> instead of the exception, we use the <code class="highlighter-rouge">recover</code>
combinator:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val purchase: Future[Int] = rateQuote map {
  quote =&gt; connection.buy(amount, quote)
} recover {
  case quoteExc: QuoteChangedException =&gt; 0
}
</code></pre></div></div>

<p>The <code class="highlighter-rouge">recover</code> combinator creates a new future which holds the same
result as the original future if it completed successfully. If it did
not then the partial function argument is applied to the <code class="highlighter-rouge">Throwable</code>
which failed the original future. If it maps the <code class="highlighter-rouge">Throwable</code> to some
value, then the new future is successfully completed with that value.</p>

<p>The <code class="highlighter-rouge">recoverWith</code> combinator creates a new future which holds the
same result as the original future if it completed successfully.
Otherwise, the partial function is applied to the <code class="highlighter-rouge">Throwable</code> which
failed the original future. If it maps the <code class="highlighter-rouge">Throwable</code> to some future,
then this future is completed with the result of that future.
Its relation to <code class="highlighter-rouge">recover</code> is similar to that of <code class="highlighter-rouge">flatMap</code> to <code class="highlighter-rouge">map</code>.</p>

<p>Combinator <code class="highlighter-rouge">fallbackTo</code> creates a new future which holds the result
of this future if it was completed successfully, or otherwise the
successful result of the argument future. In the event that both this
future and the argument future fail, the new future is completed with
the exception from this future, as in the following example which
tries to print US dollar value, but prints the Swiss franc value in
the case it fails to obtain the dollar value:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val usdQuote = Future {
  connection.getCurrentValue(USD)
} map {
  usd =&gt; "Value: " + usd + "$"
}
val chfQuote = Future {
  connection.getCurrentValue(CHF)
} map {
  chf =&gt; "Value: " + chf + "CHF"
}

val anyQuote = usdQuote fallbackTo chfQuote

anyQuote onSuccess { println(_) }
</code></pre></div></div>

<p>The <code class="highlighter-rouge">either</code> combinator creates a new future which either holds
the result of this future or the argument future, whichever completes
first, irregardless of success or failure. Here is an example in which
the quote which is returned first gets printed:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val usdQuote = Future {
  connection.getCurrentValue(USD)
} map {
  usd =&gt; "Value: " + usd + "$"
}
val chfQuote = Future {
  connection.getCurrentValue(CHF)
} map {
  chf =&gt; "Value: " + chf + "CHF"
}

val anyQuote = usdQuote either chfQuote

anyQuote onSuccess { println(_) }
</code></pre></div></div>

<p>The <code class="highlighter-rouge">andThen</code> combinator is used purely for side-effecting purposes.
It returns a new future with exactly the same result as the current
future, irregardless of whether the current future failed or not.
Once the current future is completed with the result, the closure
corresponding to the <code class="highlighter-rouge">andThen</code> is invoked and then the new future is
completed with the same result as this future. This ensures that
multiple <code class="highlighter-rouge">andThen</code> calls are ordered, as in the following example
which stores the recent posts from a social network to a mutable set
and then renders all the posts to the screen:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val allposts = mutable.Set[String]()

Future {
  session.getRecentPosts
} andThen {
  case Success(posts) =&gt; allposts ++= posts
} andThen {
  case _ =&gt;
  clearAll()
  for (post &lt;- allposts) render(post)
}
</code></pre></div></div>

<p>In summary, the combinators on futures are purely functional.
Every combinator returns a new future which is related to the
future it was derived from.</p>

<h3 id="projections">Projections</h3>

<p>To enable for-comprehensions on a result returned as an exception,
futures also have projections. If the original future fails, the
<code class="highlighter-rouge">failed</code> projection returns a future containing a value of type
<code class="highlighter-rouge">Throwable</code>. If the original future succeeds, the <code class="highlighter-rouge">failed</code> projection
fails with a <code class="highlighter-rouge">NoSuchElementException</code>. The following is an example
which prints the exception to the screen:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future {
  2 / 0
}
for (exc &lt;- f.failed) println(exc)
</code></pre></div></div>

<p>The following example does not print anything to the screen:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future {
  4 / 2
}
for (exc &lt;- f.failed) println(exc)
</code></pre></div></div>

<!--
There is another projection called `timedout` which is specific to the
`FutureTimeoutException`. It works in exactly the same way as the
`failed` projection, but is triggered only for this exception type. In
all other cases, it fails with a `NoSuchElementException`.
-->

<!--
TODO: the `failed` projection can be extended to be parametric in
the throwable types it matches.
-->

<!--
Invoking the `future` construct uses an implicit execution context to start an asynchronous computation. In the case the client desires to use a custom execution context to start an asynchronous computation:

    val f = Future {
      4 / 2
    }(customExecutionContext)
-->

<h3 id="extending-futures">Extending Futures</h3>

<p>Support for extending the Futures API with additional utility methods is planned. This will allow external frameworks to provide more specialized utilities.</p>

<h2 id="blocking">Blocking</h2>

<p>As mentioned earlier, blocking on a future is strongly discouraged –
for the sake of performance and for the prevention of deadlocks –
in favour of using callbacks and combinators on futures. However,
blocking may be necessary in certain situations and is supported by
the Futures API.</p>

<p>In the currency trading example above, one place to block is at the
end of the application to make sure that all of the futures have been completed.
Here is an example of how to block on the result of a future:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent._

def main(args: Array[String]) {
  val rateQuote = Future {
    connection.getCurrentValue(USD)
  }

  val purchase = rateQuote map {
    quote =&gt; if (isProfitable(quote)) connection.buy(amount, quote)
             else throw new Exception("not profitable")
  }

  blocking(purchase, 0 ns)
}
</code></pre></div></div>

<p>In the case that the future fails, the caller is forwarded the
exception that the future is failed with. This includes the <code class="highlighter-rouge">failed</code>
projection– blocking on it results in a <code class="highlighter-rouge">NoSuchElementException</code>
being thrown if the original future is completed successfully.</p>

<p>The <code class="highlighter-rouge">Future</code> trait implements the <code class="highlighter-rouge">Awaitable</code> trait with a single
method <code class="highlighter-rouge">await()</code>. The <code class="highlighter-rouge">await()</code> method contains code which can
potentially result in a long running computation, block on some
external condition or which may not complete the computation at all. The
<code class="highlighter-rouge">await()</code> method cannot be called directly by the clients, it can
only be called by the execution context implementation itself. To block
on the future to obtain its result, the <code class="highlighter-rouge">blocking</code> method must be used.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future { 1 }
val one: Int = blocking(f, 0 ns)
</code></pre></div></div>

<p>To allow clients to call 3rd party code which is potentially blocking
and avoid implementing the <code class="highlighter-rouge">Awaitable</code> trait, the same
<code class="highlighter-rouge">blocking</code> primitive can also be used in the following form:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>blocking {
  potentiallyBlockingCall()
}
</code></pre></div></div>

<p>The blocking code may also throw an exception. In this case, the
exception is forwarded to the caller.</p>

<h2 id="exceptions">Exceptions</h2>

<p>When asynchronous computations throw unhandled exceptions, futures
associated with those computations fail. Failed futures store an
instance of <code class="highlighter-rouge">Throwable</code> instead of the result value. <code class="highlighter-rouge">Future</code>s provide
the <code class="highlighter-rouge">onFailure</code> callback method, which accepts a <code class="highlighter-rouge">PartialFunction</code> to
be applied to a <code class="highlighter-rouge">Throwable</code>. The following special exceptions are
treated differently:</p>

<ol>
  <li><code class="highlighter-rouge">TimeoutException</code> - stored when the computation is not
completed before some timeout (typically managed by an external
scheduler).</li>
</ol>

<!--
This exception has a reference to the original future
which was timed out (if any).
-->

<ol>
  <li>
    <p><code class="highlighter-rouge">scala.runtime.NonLocalReturnControl[_]</code> - this exception holds a value
associated with the return. Typically, <code class="highlighter-rouge">return</code> constructs in method
bodies are translated to <code class="highlighter-rouge">throw</code>s with this exception. Instead of
keeping this exception, the associated value is stored into the future or a promise.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">ExecutionException</code> - stored when the computation fails due to an
unhandled <code class="highlighter-rouge">InterruptedException</code>, <code class="highlighter-rouge">Error</code> or a
<code class="highlighter-rouge">scala.util.control.ControlThrowable</code>. In this case the
<code class="highlighter-rouge">ExecutionException</code> has the unhandled exception as its cause.  These
exceptions are rethrown in the thread executing the failed
asynchronous computation. The rationale behind this is to prevent
propagation of critical and control-flow related exceptions normally
not handled by the client code and at the same time inform the client
in which future the computation failed.</p>
  </li>
</ol>

<h2 id="promises">Promises</h2>

<p>While futures are defined as a type of read-only placeholder object
created for a result which doesn’t yet exist, a promise can be thought
of as a writeable, single-assignment container, which completes a
future. That is, a promise can be used to successfully complete a
future with a value (by “completing” the promise) using the <code class="highlighter-rouge">success</code>
method. Conversely, a promise can also be used to complete a future
with an exception, by failing the promise, using the <code class="highlighter-rouge">failure</code> method.</p>

<p>A promise <code class="highlighter-rouge">p</code> completes the future returned by <code class="highlighter-rouge">p.future</code>. This future
is specific to the promise <code class="highlighter-rouge">p</code>. Depending on the implementation, it
may be the case that <code class="highlighter-rouge">p.future == p</code>.</p>

<p>Consider the following producer-consumer example:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent.{ Future, Promise }

val p = Promise[T]()
val f = p.future

val producer = Future {
  val r = produceSomething()
  p success r
  continueDoingSomethingUnrelated()
}

val consumer = Future {
  startDoingSomething()
  f onSuccess {
    case r =&gt; doSomethingWithResult()
  }
}
</code></pre></div></div>

<p>Here, we create a promise and use its <code class="highlighter-rouge">future</code> method to obtain the
<code class="highlighter-rouge">Future</code> that it completes. Then, we begin two asynchronous
computations. The first does some computation, resulting in a value
<code class="highlighter-rouge">r</code>, which is then used to complete the future <code class="highlighter-rouge">f</code>, by fulfilling
<code class="highlighter-rouge">p</code>. The second does some computation, and then reads the result <code class="highlighter-rouge">r</code>
of the completed future <code class="highlighter-rouge">f</code>. Note that the <code class="highlighter-rouge">consumer</code> can obtain the
result before the <code class="highlighter-rouge">producer</code> task is finished executing
the <code class="highlighter-rouge">continueDoingSomethingUnrelated()</code> method.</p>

<p>As mentioned before, promises have single-assignment semantics. As
such, they can be completed only once. Calling <code class="highlighter-rouge">success</code> on a
promise that has already been completed (or failed) will throw an
<code class="highlighter-rouge">IllegalStateException</code>.</p>

<p>The following example shows how to fail a promise.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val p = Promise[T]()
val f = p.future

val producer = Future {
  val r = someComputation
  if (isInvalid(r))
    p failure (new IllegalStateException)
  else {
    val q = doSomeMoreComputation(r)
    p success q
  }
}
</code></pre></div></div>

<p>Here, the <code class="highlighter-rouge">producer</code> computes an intermediate result <code class="highlighter-rouge">r</code>, and checks
whether it’s valid. In the case that it’s invalid, it fails the
promise by completing the promise <code class="highlighter-rouge">p</code> with an exception. In this case,
the associated future <code class="highlighter-rouge">f</code> is failed. Otherwise, the <code class="highlighter-rouge">producer</code>
continues its computation, and finally completes the future <code class="highlighter-rouge">f</code> with a
valid result, by completing promise <code class="highlighter-rouge">p</code>.</p>

<p>Promises can also be completed with a <code class="highlighter-rouge">complete</code> method which takes
either a failed result of type <code class="highlighter-rouge">Left[Throwable]</code> or a
successful result of type <code class="highlighter-rouge">Right[T]</code>.</p>

<p>Analogous to <code class="highlighter-rouge">success</code>, calling <code class="highlighter-rouge">failure</code> and <code class="highlighter-rouge">complete</code> on a promise that has already
been completed will throw an <code class="highlighter-rouge">IllegalStateException</code>.</p>

<p>One nice property of programs written using promises with operations
described so far and futures which are composed through monadic
operations without side-effects is that these programs are
deterministic. Deterministic here means that, given that no exception
is thrown in the program, the result of the program (values observed
in the futures) will always be the same, irregardless of the execution
schedule of the parallel program.</p>

<p>In some cases the client may want to complete the promise only if it
has not been completed yet (e.g., there are several HTTP requests being
executed from several different futures and the client is interested only
in the first HTTP response - corresponding to the first future to
complete the promise). For these reasons methods <code class="highlighter-rouge">tryComplete</code>,
<code class="highlighter-rouge">trySuccess</code> and <code class="highlighter-rouge">tryFailure</code> exist on future. The client should be
aware that using these methods results in programs which are not
deterministic, but depend on the execution schedule.</p>

<p>The method <code class="highlighter-rouge">completeWith</code> completes the promise with another
future. After the future is completed, the promise gets completed with
the result of that future as well. The following program prints <code class="highlighter-rouge">1</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val f = Future { 1 }
val p = Promise[Int]()

p completeWith f

p.future onSuccess {
  case x =&gt; println(x)
}
</code></pre></div></div>

<p>When failing a promise with an exception, three subtypes of <code class="highlighter-rouge">Throwable</code>s
are handled specially. If the <code class="highlighter-rouge">Throwable</code> used to break the promise is
a <code class="highlighter-rouge">scala.runtime.NonLocalReturnControl</code>, then the promise is completed with
the corresponding value. If the <code class="highlighter-rouge">Throwable</code> used to break the promise is
an instance of <code class="highlighter-rouge">Error</code>, <code class="highlighter-rouge">InterruptedException</code>, or
<code class="highlighter-rouge">scala.util.control.ControlThrowable</code>, the <code class="highlighter-rouge">Throwable</code> is wrapped as
the cause of a new <code class="highlighter-rouge">ExecutionException</code> which, in turn, is failing
the promise.</p>

<!--
## Migration p

scala.actor.Futures?
for clients


## Implementing custom futures and promises p
for library writers
-->

<h2 id="utilities">Utilities</h2>

<p>To simplify handling of time in concurrent applications <code class="highlighter-rouge">scala.concurrent</code>
 will introduce a <code class="highlighter-rouge">Duration</code> abstraction. Duration is not supposed be yet another
 general time abstraction. It is meant to be used with concurrency libraries and
 will reside in <code class="highlighter-rouge">scala.concurrent.util</code> package.</p>

<p><code class="highlighter-rouge">Duration</code> is the base class representing length of time. It can be either finite or infinite.
 Finite duration is represented with <code class="highlighter-rouge">FiniteDuration</code> class which is constructed from <code class="highlighter-rouge">Long</code> length and
 <code class="highlighter-rouge">java.util.concurrent.TimeUnit</code>. Infinite durations, also extended from <code class="highlighter-rouge">Duration</code>,
 exist in only two instances , <code class="highlighter-rouge">Duration.Inf</code> and <code class="highlighter-rouge">Duration.MinusInf</code>. Library also
 provides several <code class="highlighter-rouge">Duration</code> subclasses for implicit conversion purposes and those should
 not be used.</p>

<p>Abstract <code class="highlighter-rouge">Duration</code> contains methods that allow :</p>

<ol>
  <li>Conversion to different time units (<code class="highlighter-rouge">toNanos</code>, <code class="highlighter-rouge">toMicros</code>, <code class="highlighter-rouge">toMillis</code>,
<code class="highlighter-rouge">toSeconds</code>, <code class="highlighter-rouge">toMinutes</code>, <code class="highlighter-rouge">toHours</code>, <code class="highlighter-rouge">toDays</code> and <code class="highlighter-rouge">toUnit(unit: TimeUnit)</code>).</li>
  <li>Comparison of durations (<code class="highlighter-rouge">&lt;</code>, <code class="highlighter-rouge">&lt;=</code>, <code class="highlighter-rouge">&gt;</code> and <code class="highlighter-rouge">&gt;=</code>).</li>
  <li>Arithmetic operations (<code class="highlighter-rouge">+</code>, <code class="highlighter-rouge">-</code>, <code class="highlighter-rouge">*</code>, <code class="highlighter-rouge">/</code> and <code class="highlighter-rouge">unary_-</code>).</li>
  <li>Minimum and maximum between <code class="highlighter-rouge">this</code> duration and the one supplied in the argument (<code class="highlighter-rouge">min</code>, <code class="highlighter-rouge">max</code>).</li>
  <li>Check if the duration is finite (<code class="highlighter-rouge">finite_?</code>).</li>
</ol>

<p><code class="highlighter-rouge">Duration</code> can be instantiated in the following ways:</p>

<ol>
  <li>Implicitly from types <code class="highlighter-rouge">Int</code> and <code class="highlighter-rouge">Long</code>. For example <code class="highlighter-rouge">val d = 100 millis</code>.</li>
  <li>By passing a <code class="highlighter-rouge">Long</code> length and a <code class="highlighter-rouge">java.util.concurrent.TimeUnit</code>.
For example <code class="highlighter-rouge">val d = Duration(100, MILLISECONDS)</code>.</li>
  <li>By parsing a string that represent a time period. For example <code class="highlighter-rouge">val d = Duration("1.2 µs")</code>.</li>
</ol>

<p>Duration also provides <code class="highlighter-rouge">unapply</code> methods so it can be used in pattern matching constructs.
Examples:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import scala.concurrent.util.Duration
import scala.concurrent.util.duration._
import java.util.concurrent.TimeUnit._

// instantiation
val d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit
val d2 = Duration(100, "millis") // from Long and String
val d3 = 100 millis // implicitly from Long, Int or Double
val d4 = Duration("1.2 µs") // from String

// pattern matching
val Duration(length, unit) = 5 millis
</code></pre></div></div>

<h2 id="references">References</h2>
<ol>
  <li><a href="http://www.microsoft.com/download/en/details.aspx?id=19957" title="NETAsync">The Task-Based Asynchronous Pattern, Stephen Toub, Microsoft, April 2011</a></li>
  <li><a href="http://twitter.github.com/scala_school/finagle.html" title="Finagle">Finagle Documentation</a></li>
  <li><a href="https://doc.akka.io/docs/akka/current/futures.html" title="AkkaFutures">Akka Documentation: Futures</a></li>
  <li><a href="http://www.scala-lang.org/api/2.9.3/scala/actors/Future.html" title="SActorsFutures">Scala Actors Futures</a></li>
  <li><a href="http://code.google.com/p/scalaz/" title="Scalaz">Scalaz Futures</a></li>
</ol>

<h2 id="appendix-a-api-traits">Appendix A: API Traits</h2>

<p>An implementation is available at <a href="https://github.com/phaller/scala/tree/execution-context/src/library/scala/concurrent">http://github.com/phaller/scala</a>. (Reasonably stable implementation, though possibility of flux.)</p>

			</div>
		</div>

		<!-- TOC -->
    <div class="content-nav">
    	<div class="inner-box sidebar-toc-wrapper sip-toc" style="">
      
        <h5 class="contents">SIP Committee Decision</h5>
         <div class="tag" style="background-color: #859900">Complete</div>
           <p class="vote-text" style="color: #859900">
             This SIP has already been accepted and completed.
           </p>
        
    		<h5 class="contents">SIP Contents</h5>
    		<div class="inner-toc" id="sidebar-toc">
          <div id="toc"></div>
    		</div>
    		<hr>
    		<div class="help-us"><a href="https://github.com/scala/docs.scala-lang/blob/master/_sips/sips/2012-01-21-futures-promises.md"><i class="fa fa-pencil" aria-hidden="true"></i> Problem with this page?<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Please help us fix it!</a></div>
    	</div>
    </div>

	</div>
</section>


</main>

<footer id="site-footer">
    <div class="wrap">
      <div class="site-footer-top">
        
          <ul class="documentation">
            <li><h3>Documentation</h3></li>
            
              <li><a href="/docs.scala-lang/getting-started.html">Getting Started</a></li>
            
              <li><a href="https://www.scala-lang.org/api/current/index.html">API</a></li>
            
              <li><a href="/docs.scala-lang/overviews">Overviews/Guides</a></li>
            
              <li><a href="http://scala-lang.org/files/archive/spec/2.12/">Language Specification</a></li>
            
          </ul>
        
          <ul class="download">
            <li><h3>Download</h3></li>
            
              <li><a href="http://scala-lang.org/download/">Current Version</a></li>
            
              <li><a href="http://scala-lang.org/download/all.html">All versions</a></li>
            
          </ul>
        
          <ul class="community">
            <li><h3>Community</h3></li>
            
              <li><a href="http://scala-lang.org/community/">Community</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#mailing-lists">Mailing Lists</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#chat-rooms">Chat Rooms & More</a></li>
            
              <li><a href="http://scala-lang.org/community/index.html#community-libraries-and-tools">Libraries and Tools</a></li>
            
              <li><a href="http://scala.epfl.ch/">The Scala Center</a></li>
            
          </ul>
        
          <ul class="contribute">
            <li><h3>Contribute</h3></li>
            
              <li><a href="http://scala-lang.org/contribute/">How to help</a></li>
            
              <li><a href="http://scala-lang.org/contribute/bug-reporting-guide.html">Report an Issue</a></li>
            
          </ul>
        
          <ul class="scala">
            <li><h3>Scala</h3></li>
            
              <li><a href="http://scala-lang.org/blog/">Blog</a></li>
            
              <li><a href="http://scala-lang.org/conduct/">Code of Conduct</a></li>
            
              <li><a href="http://scala-lang.org/license/">License</a></li>
            
          </ul>
        
          <ul class="social">
            <li><h3>Social</h3></li>
            
              <li><a href="https://github.com/scala/scala">GitHub</a></li>
            
              <li><a href="https://twitter.com/scala_lang">Twitter</a></li>
            
          </ul>
        
      </div>
      <div class="site-footer-bottom">
        <p></p>
        <img src="/docs.scala-lang/resources/img/frontpage/scala-logo-white.png" alt="">
      </div>
    </div>
    <a class="back-to-top in" href="#" id="scroll-to-top-btn">
      <i class="fa fa-angle-up"></i>
    </a>
</footer>

<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js" integrity="sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7" crossorigin="anonymous"></script>
<script>(window.jQuery) || document.write('<script src="/docs.scala-lang/scripts/jquery-3.1.1.min.js"><\/script>');</script>
<script src="/docs.scala-lang/resources/js/vendor/jquery.autocomplete.js" type="text/javascript"></script>

<!-- moment js -->
<script src="/docs.scala-lang/resources/js/vendor/moment.min.js" type="text/javascript"></script>

<!-- tweet feed -->
<script src="/docs.scala-lang/resources/js/tweetMachine-update.js" type="text/javascript"></script>

<!-- prettify js -->
<script src="/docs.scala-lang/resources/js/vendor/prettify/prettify.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/prettify/lang-scala.js" type="text/javascript"></script>

<!-- unslider js -->
<script src="/docs.scala-lang/resources/js/vendor/unslider.js" type="text/javascript"></script>

<!-- Highlight -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/java.min.js" type="text/javascript"></script>

<!-- CodeMirror -->
<script src="/docs.scala-lang/resources/js/vendor/codemirror/codemirror.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/codemirror/clike.js" type="text/javascript"></script>

<!-- TOC -->
<script src="/docs.scala-lang/resources/js/vendor/jquery.sticky.js" type="text/javascript"></script>
<script src="/docs.scala-lang/resources/js/vendor/toc.js" type="text/javascript"></script>

<!-- Blog search -->
<script src="/docs.scala-lang/resources/js/vendor/jekyll.search.min.js" type="text/javascript"></script>

<!-- Custom javascript -->
<script src="/docs.scala-lang/resources/js/functions.js" type="text/javascript"></script>



<!-- Alogolia search for doc -->
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript"> docsearch({
apiKey: 'fbc439670f5d4e3730cdcb715c359391',
indexName: 'scala-lang',
inputSelector: '#doc-search-bar',
algoliaOptions: { 'facetFilters': ["language:en"] },
debug: false // Set debug to true if you want to inspect the dropdown
});
</script>
</body>

</html>

